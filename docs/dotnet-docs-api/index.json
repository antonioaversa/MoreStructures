{
  "api/index.html": {
    "href": "api/index.html",
    "title": "More Structures .NET API Documentation",
    "keywords": "More Structures .NET API Documentation This is the entrypoint of the .NET API documentation of More Structures. More Structures provides: mostly basic, and some more advanced, data structures such as Trees, Tries, Burrows-Wheeler Transform and Matrix wrappers etc. implementation of well-known algorithms running on them, such as Suffix Trie and Tree construction, Hukkonen algorithm, Burrows-Wheeler Transform pattern matching, etc. Functionalities provided Burrows-Wheeler Transform and Matrix : builders, inversion, pattern matching Recursively Defined Trees : descendants counting, stringification Lists : binary search Suffix Tries : builders, pattern matching, conversion into trees Suffix Trees : builders, pattern matching, conversion into tries, Hukkonen algorithm for linear time building Design aspects The library is conceived with a few key aspects in mind: type-safety immutability value-based semantics performance 100% statement and condition coverage extensive auto-generated documentation warnings as errors Type-safety All concepts have wrappers around standard types provided by the framework, enforcing data structure-specific constraints: For example, all terminator-terminated strings used by Suffix Trees and Tries are mapped to a specific record named TextWithTerminator , which ensures that the string is properly formed. Similarly, all cyclic rotations of a text are wrapped into a RotatedTextWithTerminator . This approch allows to avoid in most cases dangerous casting operations, sometimes leading to runtime errors. Type-safety is preserved by generic constraints whenever possible. For example, by binding together interfaces of different objects of the same data structure by some variants of the Curiously recurring template pattern : public interface IRecImmDictIndexedTreeEdge<TEdge, TNode> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> { } public interface IRecImmDictIndexedTreeNode<TEdge, TNode> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> { IDictionary<TEdge, TNode> Children { get; } } The notation can be heavy at times, especially when defining new data structures implementing such interfaces. public record SuffixTreeEdge(int Start, int Length) : ISuffixStructureEdge<SuffixTreeEdge, SuffixTreeNode>, IComparable<SuffixTreeEdge> { ... } public abstract record SuffixTreeNode(IDictionary<SuffixTreeEdge, SuffixTreeNode> Children, int? Start) : ISuffixStructureNode<SuffixTreeEdge, SuffixTreeNode> { ... } However, the advantages of type-safety more often than not outrun the disadvantages, keeping data structures coherent and predictable at compile time. Another typical source of runtime errors are null reference exceptions. These are avoided by: requiring use of nullable reference types , introduced in C# 8, everywhere in the project; limiting to the maximum extent possible the use of null-forgiving operator ; avoiding the semantic abuse of null . Immutability Whenever possible, structures are kept immutable, meaning that, whenever possible: fields are made readonly , and either assigned in-line or in the constructor; properties are made either { get; } or { get; init; } , and either assigned in-line or in the constructor; methods don't change object state; complex object initialization which may require multiple steps and intermediate incoherent states are externalized to a Builder object. Value-based semantics C# 9 introduced records which are classes or struct with value-based equality . This library makes extensive use of such construct, especially when wrapping other objects, in order to give them a domain-specific semantics: public record TextWithTerminator( IEnumerable<char> Text, char Terminator = TextWithTerminator.DefaultTerminator, bool ValidateInput = true) : IValueEnumerable<char> ... public record BWTransform(TextWithTerminator Text, RotatedTextWithTerminator Content) ... public record BWMatrix(TextWithTerminator Text, IList<string> Content) ... public sealed record CountTreeEdge<TEdge, TNode>(TEdge WrappedEdge) : IRecImmDictIndexedTreeEdge<CountTreeEdge<TEdge, TNode>, CountTreeNode<TEdge, TNode>> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> ... Performance While type soundness has the priority in the design of this library, performance is measured and optimized. Due to lack of proper tail-recurse optimization in the .NET runtime, all operations on deep recursive structures are implemented in at least two variants: a fully recursive, typically functional fashion, where no mutation of any type (not even local) happens; an iterative, Stack or Queue based, where some local mutations are allowed; sometimes the two approaches are combined. 100% statement and condition coverage The code is currently covered by tests in its entirety. There is mostly a 1-to-1 mapping between every public class and method, and their corresponding test class and method in the MoreStructures.Test project. Every folder under the MoreStructure project, containing source code, has its counterpart under MoreStructure.Tests ; Most public method MethodX of public class MoreStructures.Package.ClassA have a MethodX_Aspect unit test, defined under the class MoreStructures.Tests.Package.ClassATests . Tests are a great source of documentation, showing working and reproducible examples of how to use this library. When looking for directions about how to use a data structure or invoke an algorithm, it's highly recommended to also have a look at unit tests covering that functionality. Extensive auto-generated documentation All public members and their parameters and generic types are documented. Warnings as errors All warnings according to the Latest .NET analyzer are treated as errors. Coding style File Scoped Namespaces are encouraged, as they reduce the levels of nesting, making the code more readable. They also promote the use of a single namespace per file, which is strongly encouraged."
  },
  "api/MoreStructures.Benchmarks.BenchmarkUtilities.html": {
    "href": "api/MoreStructures.Benchmarks.BenchmarkUtilities.html",
    "title": "Class BenchmarkUtilities",
    "keywords": "Class BenchmarkUtilities Inheritance System.Object BenchmarkUtilities Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Benchmarks Assembly : MoreStructures.Benchmarks.dll Syntax public static class BenchmarkUtilities Fields | Improve this Doc View Source TestDataRandomIntsFrom0To1000 Declaration public const string TestDataRandomIntsFrom0To1000 = \"Resources/TestDataRandomIntsFrom0To1000.txt\" Field Value Type Description System.String"
  },
  "api/MoreStructures.Benchmarks.html": {
    "href": "api/MoreStructures.Benchmarks.html",
    "title": "Namespace MoreStructures.Benchmarks",
    "keywords": "Namespace MoreStructures.Benchmarks Classes BenchmarkUtilities"
  },
  "api/MoreStructures.Benchmarks.Lists.Sorting.html": {
    "href": "api/MoreStructures.Benchmarks.Lists.Sorting.html",
    "title": "Namespace MoreStructures.Benchmarks.Lists.Sorting",
    "keywords": "Namespace MoreStructures.Benchmarks.Lists.Sorting Classes ShellSortGapSequences"
  },
  "api/MoreStructures.Benchmarks.Lists.Sorting.ShellSortGapSequences.html": {
    "href": "api/MoreStructures.Benchmarks.Lists.Sorting.ShellSortGapSequences.html",
    "title": "Class ShellSortGapSequences",
    "keywords": "Class ShellSortGapSequences Inheritance System.Object ShellSortGapSequences Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Benchmarks.Lists.Sorting Assembly : MoreStructures.Benchmarks.dll Syntax public class ShellSortGapSequences Constructors | Improve this Doc View Source ShellSortGapSequences() Declaration public ShellSortGapSequences() Properties | Improve this Doc View Source NumberOfChunks Declaration public int NumberOfChunks { get; set; } Property Value Type Description System.Int32 | Improve this Doc View Source NumberOfItems Declaration public int NumberOfItems { get; set; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source GapsCiura01() Declaration public void GapsCiura01() | Improve this Doc View Source GapsPositiveInts() Declaration public void GapsPositiveInts() | Improve this Doc View Source GapsPowerOf2() Declaration public void GapsPowerOf2() | Improve this Doc View Source GapsSedgewick82() Declaration public void GapsSedgewick82() | Improve this Doc View Source GapsSingleInsertionSort() Declaration public void GapsSingleInsertionSort() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.Builders.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Builders.html",
    "title": "Namespace MoreStructures.BurrowsWheelerTransform.Builders",
    "keywords": "Namespace MoreStructures.BurrowsWheelerTransform.Builders Classes LastFirstPropertyBasedBuilder An extension of NaiveBuilder which takes advantange of the last-first property to reduce the complexity of InvertTransform(RotatedTextWithTerminator) . NaiveBuilder This implementation adopts the simplest approach at BWMatrix building, which results in a more than quadratic time and space. BWTransform is calculated via the BWMatrix , therefore same level of Time and Space Complexity. Interfaces IBuilder Builds Burrows-Wheeler objects, such as BWMatrix and BWTransform of the provided TextWithTerminator ."
  },
  "api/MoreStructures.BurrowsWheelerTransform.Builders.IBuilder.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Builders.IBuilder.html",
    "title": "Interface IBuilder",
    "keywords": "Interface IBuilder Builds Burrows-Wheeler objects, such as BWMatrix and BWTransform of the provided TextWithTerminator . Namespace : MoreStructures.BurrowsWheelerTransform.Builders Assembly : MoreStructures.dll Syntax public interface IBuilder Methods | Improve this Doc View Source BuildMatrix(BWTransform) Rebuilds the original BWMatrix from a BWTransform representing the last column of the Burrows-Wheeler Matrix (which is also the Burrows-Wheeler Transform). Declaration BWMatrix BuildMatrix(BWTransform lastBWMColumn) Parameters Type Name Description BWTransform lastBWMColumn The last column of the Burrows-Wheeler Matrix. Returns Type Description BWMatrix The matrix, wrapped into a BWMatrix object. Remarks Because the entire Burrows-Wheeler Matrix is built from the text with an invertible function, and the same happens for the Burrows-Wheeler Transform of the text, it's possible to get back the entire matrix from its last column. | Improve this Doc View Source BuildMatrix(TextWithTerminator) Build a BWMatrix of the provided text, which is a n-ary search tree in which edges coming out of a node are substrings of text which identify edges shared by all paths to leaves, starting from the node. Declaration BWMatrix BuildMatrix(TextWithTerminator text) Parameters Type Name Description TextWithTerminator text The text to build the BWM, with its terminator (required). Returns Type Description BWMatrix The matrix, wrapped into a BWMatrix object. Remarks Examples Code: var builder = ... builder.BuildMatrix(new(\"mississippi\")).Content Result: { \"$mississippi\", \"i$mississipp\", \"ippi$mississ\", \"issippi$miss\", \"ississippi$m\", \"mississippi$\", \"pi$mississip\", \"ppi$mississi\", \"sippi$missis\", \"sissippi$mis\", \"ssippi$missi\", \"ssissippi$mi\", } | Improve this Doc View Source BuildTransform(BWMatrix) Builds the Burrows-Wheeler Transform from the provided BWMatrix . Declaration BWTransform BuildTransform(BWMatrix matrix) Parameters Type Name Description BWMatrix matrix The matrix, whose BWT has to be calculated. Returns Type Description BWTransform The transform, wrapped into a BWTransform object. Remarks | Improve this Doc View Source BuildTransform(TextWithTerminator) Builds the Burrows-Wheeler Transform from the provided TextWithTerminator . Declaration BWTransform BuildTransform(TextWithTerminator text) Parameters Type Name Description TextWithTerminator text The text, whose BWT has to be calculated. Returns Type Description BWTransform The transform, wrapped into a BWTransform object. Remarks | Improve this Doc View Source InvertMatrix(BWMatrix) Rebuilds the original TextWithTerminator from the BWMatrix . Declaration TextWithTerminator InvertMatrix(BWMatrix matrix) Parameters Type Name Description BWMatrix matrix The matrix, whose original text has to be calculated. Returns Type Description TextWithTerminator The text which corresponds to the provided matrix. | Improve this Doc View Source InvertTransform(RotatedTextWithTerminator) Rebuilds the original TextWithTerminator from a RotatedTextWithTerminator representing the last column of the Burrows-Wheeler Matrix (which is also the Burrows-Wheeler Transform). Declaration TextWithTerminator InvertTransform(RotatedTextWithTerminator lastBWMColumn) Parameters Type Name Description RotatedTextWithTerminator lastBWMColumn The last column of the Burrows-Wheeler Matrix. Returns Type Description TextWithTerminator The text which corresponds to the provided text which produced a BWM whose last column is the one provided. Remarks REQUIREMENT lastBWMColumn requires a terminator to be specified in order to correctly compare strings, since the terminator should always be considered smaller than any other char. ALGORITHM Multiple strategies for inversion are possible: via n-mers construction, via last-first property, ... Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders.BinarySearchFinder.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders.BinarySearchFinder.html",
    "title": "Class BinarySearchFinder",
    "keywords": "Class BinarySearchFinder A NaiveFinder refinement which iterates over BWT and uses binary search on SortedBWT , taking advantage of the fact that it is sorted. Inheritance System.Object NaiveFinder BinarySearchFinder PrecomputedFinder Implements ILastFirstFinder Inherited Members NaiveFinder.CharComparer NaiveFinder.BWT NaiveFinder.SortedBWT NaiveFinder.FindIndexOfNthOccurrenceInBWT(Int32, Int32) NaiveFinder.FindOccurrenceRankOfCharInBWT(Int32) NaiveFinder.LastToFirst(Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders Assembly : MoreStructures.dll Syntax public class BinarySearchFinder : NaiveFinder, ILastFirstFinder Remarks COMPLEXITY - Search over BWT has Time Complexity = O(n), as it is not sorted and there's nothing better than a linear scan without precomputing additional structures helping the search. - Search over SortedBWT has Time Complexity O(log(n)), as it is sorted and binary search can be applied. - Space Complexity = O(1) for both search operations, as no additional structure is precomputed and/or stored. Constructors | Improve this Doc View Source BinarySearchFinder(RotatedTextWithTerminator, RotatedTextWithTerminator) Declaration public BinarySearchFinder(RotatedTextWithTerminator lastBWMColumn, RotatedTextWithTerminator firstBWMColumn) Parameters Type Name Description RotatedTextWithTerminator lastBWMColumn RotatedTextWithTerminator firstBWMColumn Remarks Properties | Improve this Doc View Source OrderedAscListSearch The ISearch implementation to be used when searching for items in lists sorted in ascending order. Declaration protected static ISearch OrderedAscListSearch { get; } Property Value Type Description ISearch Methods | Improve this Doc View Source FindIndexOfNthOccurrenceInSortedBWT(Int32, Int32) Declaration public override int FindIndexOfNthOccurrenceInSortedBWT(int indexOfCharInBWT, int occurrenceRank) Parameters Type Name Description System.Int32 indexOfCharInBWT System.Int32 occurrenceRank Returns Type Description System.Int32 Overrides NaiveFinder.FindIndexOfNthOccurrenceInSortedBWT(Int32, Int32) Remarks This implementation takes advantage of the fact that SortedBWT is sorted. Time Complexity = O(log(n)). Space Complexity = O(1). | Improve this Doc View Source FindOccurrenceRankOfCharInSortedBWT(Int32) Declaration public override int FindOccurrenceRankOfCharInSortedBWT(int indexOfCharInSortedBWT) Parameters Type Name Description System.Int32 indexOfCharInSortedBWT Returns Type Description System.Int32 Overrides NaiveFinder.FindOccurrenceRankOfCharInSortedBWT(Int32) Remarks This implementation takes advantage of the fact that SortedBWT is sorted. Time Complexity = O(log(n)). Space Complexity = O(1). Implements ILastFirstFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders.html",
    "title": "Namespace MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders",
    "keywords": "Namespace MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders Classes BinarySearchFinder A NaiveFinder refinement which iterates over BWT and uses binary search on SortedBWT , taking advantage of the fact that it is sorted. NaiveFinder A ILastFirstFinder implementation which just iterates over BWT and its sorted version SortedBWT every time. PrecomputedFinder A BinarySearchFinder refinement which precalculate an hash-map of all the positions by each char, for both BWT and its sorted version, which takes ~ 2 * n space and makes calls to FindIndexOfNthOccurrenceInBWT(Int32, Int32) and FindIndexOfNthOccurrenceInSortedBWT(Int32, Int32) executed in constant time. Interfaces ILastFirstFinder A stategy used by a IBuilder to find chars in BWT and in its sorted version SortedBWT ."
  },
  "api/MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders.ILastFirstFinder.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders.ILastFirstFinder.html",
    "title": "Interface ILastFirstFinder",
    "keywords": "Interface ILastFirstFinder A stategy used by a IBuilder to find chars in BWT and in its sorted version SortedBWT . Namespace : MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders Assembly : MoreStructures.dll Syntax public interface ILastFirstFinder Properties | Improve this Doc View Source BWT The Burrows-Wheeler Transform. Also, the last column of the Burrows-Wheeler Matrix. Declaration RotatedTextWithTerminator BWT { get; } Property Value Type Description RotatedTextWithTerminator | Improve this Doc View Source CharComparer The used to compare chars of BWT or SortedBWT . Declaration IComparer<char> CharComparer { get; } Property Value Type Description IComparer < System.Char > Remarks The of System.Char cannot be used because the terminator in BWT and SortedBWT has to be treated in a special way ( Terminator is always to be considered smaller than any other char: as such it always appears in first position in the SortedBWT ). | Improve this Doc View Source SortedBWT The sorted version of the Burrows-Wheeler Transform. Also, the first column of the Burrows-Wheeler Matrix. Declaration RotatedTextWithTerminator SortedBWT { get; } Property Value Type Description RotatedTextWithTerminator Methods | Improve this Doc View Source FindIndexOfNthOccurrenceInBWT(Int32, Int32) Find the index of the n-th occurrence (0-based) in BWT , of the char in BWT at the provided index indexOfCharInBWT . Declaration int FindIndexOfNthOccurrenceInBWT(int indexOfCharInBWT, int occurrenceRank) Parameters Type Name Description System.Int32 indexOfCharInBWT The index of the char in BWT , to find the n-th occurrence of, again in BWT . System.Int32 occurrenceRank The 0-based occurrence rank to find. 0 = 1st occurrence. Returns Type Description System.Int32 The index of the n-th occurrence of the char in BWT at indexOfCharInBWT . | Improve this Doc View Source FindIndexOfNthOccurrenceInSortedBWT(Int32, Int32) Find the index of the n-th occurrence (0-based) in SortedBWT , of the char in BWT at the provided index indexOfCharInBWT . Declaration int FindIndexOfNthOccurrenceInSortedBWT(int indexOfCharInBWT, int occurrenceRank) Parameters Type Name Description System.Int32 indexOfCharInBWT The index of the char in BWT , to find the n-th occurrence of, in SortedBWT . System.Int32 occurrenceRank The 0-based occurrence rank to find. 0 = 1st occurrence. Returns Type Description System.Int32 The index in SortedBWT of the n-th occurrence of the char in BWT at index indexOfCharInBWT . | Improve this Doc View Source FindOccurrenceRankOfCharInBWT(Int32) Find the occurrence rank in BWT of the char in BWT at the provided index indexOfCharInBWT . Declaration int FindOccurrenceRankOfCharInBWT(int indexOfCharInBWT) Parameters Type Name Description System.Int32 indexOfCharInBWT The index of the char in BWT . Returns Type Description System.Int32 The 0-based occurrence rank of the char at index indexOfCharInBWT . | Improve this Doc View Source FindOccurrenceRankOfCharInSortedBWT(Int32) Find the occurrence rank in SortedBWT of the char in SortedBWT at the provided index indexOfCharInSortedBWT . Declaration int FindOccurrenceRankOfCharInSortedBWT(int indexOfCharInSortedBWT) Parameters Type Name Description System.Int32 indexOfCharInSortedBWT The index of the char in SortedBWT . Returns Type Description System.Int32 The 0-based occurrence rank of the char at index indexOfCharInSortedBWT . | Improve this Doc View Source LastToFirst(Int32) Given the index of a char in BWT , it finds the index of the corresponding char in the SortedBWT and its occurrence rank. Declaration (int indexInSortedBWT, int occurrenceRank) LastToFirst(int indexOfCharInBWT) Parameters Type Name Description System.Int32 indexOfCharInBWT The index (0-based) of the char in BWT . Returns Type Description System.ValueTuple < System.Int32 , System.Int32 > The index of the char in the SortedBWT and its occurence rank (0-based). Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders.NaiveFinder.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders.NaiveFinder.html",
    "title": "Class NaiveFinder",
    "keywords": "Class NaiveFinder A ILastFirstFinder implementation which just iterates over BWT and its sorted version SortedBWT every time. Inheritance System.Object NaiveFinder BinarySearchFinder Implements ILastFirstFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders Assembly : MoreStructures.dll Syntax public class NaiveFinder : ILastFirstFinder Remarks Each operation has Time Complexity = O(n) and Space Complexity = O(1), since no additional structure is precomputed and/or stored. Constructors | Improve this Doc View Source NaiveFinder(RotatedTextWithTerminator, RotatedTextWithTerminator) Builds an instance of this finder, for the provided lastBWMColumn and firstBWMColumn . Because both columns of the BWM are provided, no sorting happens. Declaration public NaiveFinder(RotatedTextWithTerminator lastBWMColumn, RotatedTextWithTerminator firstBWMColumn) Parameters Type Name Description RotatedTextWithTerminator lastBWMColumn The last column of the Burrows-Wheeler Matrix. Corresponds to the BWT . RotatedTextWithTerminator firstBWMColumn The first column of the Burrows-Wheeler Matrix. Corresponds to the SortedBWT . Properties | Improve this Doc View Source BWT The Burrows-Wheeler Transform. Also, the last column of the Burrows-Wheeler Matrix. Declaration public RotatedTextWithTerminator BWT { get; } Property Value Type Description RotatedTextWithTerminator | Improve this Doc View Source CharComparer The used to compare chars of BWT or SortedBWT . Declaration public IComparer<char> CharComparer { get; } Property Value Type Description IComparer < System.Char > Remarks The of System.Char cannot be used because the terminator in BWT and SortedBWT has to be treated in a special way ( Terminator is always to be considered smaller than any other char: as such it always appears in first position in the SortedBWT ). | Improve this Doc View Source SortedBWT The sorted version of the Burrows-Wheeler Transform. Also, the first column of the Burrows-Wheeler Matrix. Declaration public RotatedTextWithTerminator SortedBWT { get; } Property Value Type Description RotatedTextWithTerminator Methods | Improve this Doc View Source FindIndexOfNthOccurrenceInBWT(Int32, Int32) Declaration public virtual int FindIndexOfNthOccurrenceInBWT(int indexOfCharInBWT, int occurrenceRank) Parameters Type Name Description System.Int32 indexOfCharInBWT System.Int32 occurrenceRank Returns Type Description System.Int32 Remarks This implementation just iterates over BWT every time. Time Complexity = O(n). Space Complexity = O(1). | Improve this Doc View Source FindIndexOfNthOccurrenceInSortedBWT(Int32, Int32) Declaration public virtual int FindIndexOfNthOccurrenceInSortedBWT(int indexOfCharInBWT, int occurrenceRank) Parameters Type Name Description System.Int32 indexOfCharInBWT System.Int32 occurrenceRank Returns Type Description System.Int32 Remarks This implementation just iterates over SortedBWT every time. Time Complexity = O(n). Space Complexity = O(1). | Improve this Doc View Source FindOccurrenceRankOfCharInBWT(Int32) Declaration public virtual int FindOccurrenceRankOfCharInBWT(int indexOfCharInBWT) Parameters Type Name Description System.Int32 indexOfCharInBWT Returns Type Description System.Int32 Remarks This implementation just iterates over BWT every time. Time Complexity = O(n). Space Complexity = O(1). | Improve this Doc View Source FindOccurrenceRankOfCharInSortedBWT(Int32) Declaration public virtual int FindOccurrenceRankOfCharInSortedBWT(int indexOfCharInSortedBWT) Parameters Type Name Description System.Int32 indexOfCharInSortedBWT Returns Type Description System.Int32 Remarks This implementation just iterates over SortedBWT every time. Time Complexity = O(n). Space Complexity = O(1). | Improve this Doc View Source LastToFirst(Int32) Declaration public virtual (int indexInSortedBWT, int occurrenceRank) LastToFirst(int indexOfCharInBWT) Parameters Type Name Description System.Int32 indexOfCharInBWT Returns Type Description System.ValueTuple < System.Int32 , System.Int32 > Remarks First executes FindOccurrenceRankOfCharInBWT(Int32) , to find the occurrence rank of the char at index indexOfCharInBWT and then uses the last-to-first property to find the corresponding char in SortedBWT by using FindIndexOfNthOccurrenceInSortedBWT(Int32, Int32) . Time and Space Complexity depends on the implementation of FindOccurrenceRankOfCharInBWT(Int32) and FindIndexOfNthOccurrenceInSortedBWT(Int32, Int32) . Implements ILastFirstFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders.PrecomputedFinder.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders.PrecomputedFinder.html",
    "title": "Class PrecomputedFinder",
    "keywords": "Class PrecomputedFinder A BinarySearchFinder refinement which precalculate an hash-map of all the positions by each char, for both BWT and its sorted version, which takes ~ 2 * n space and makes calls to FindIndexOfNthOccurrenceInBWT(Int32, Int32) and FindIndexOfNthOccurrenceInSortedBWT(Int32, Int32) executed in constant time. Inheritance System.Object NaiveFinder BinarySearchFinder PrecomputedFinder Implements ILastFirstFinder Inherited Members BinarySearchFinder.OrderedAscListSearch NaiveFinder.CharComparer NaiveFinder.BWT NaiveFinder.SortedBWT NaiveFinder.LastToFirst(Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.BurrowsWheelerTransform.Builders.LastFirstFinders Assembly : MoreStructures.dll Syntax public class PrecomputedFinder : BinarySearchFinder, ILastFirstFinder Remarks Calls to FindOccurrenceRankOfCharInBWT(Int32) are still executed in O(n / sigma) time, where sigma is the size of the alphabet, or the number of distinct values in the BWT. If sigma is constant w.r.t. n, complexity is still linear. Calls to FindOccurrenceRankOfCharInSortedBWT(Int32) are still executed in O(log(n / sigma)), which is O(log(n)) when sigma is constant w.r.t. n. Constructors | Improve this Doc View Source PrecomputedFinder(RotatedTextWithTerminator, RotatedTextWithTerminator) Declaration public PrecomputedFinder(RotatedTextWithTerminator lastBWMColumn, RotatedTextWithTerminator firstBWMColumn) Parameters Type Name Description RotatedTextWithTerminator lastBWMColumn RotatedTextWithTerminator firstBWMColumn Remarks Properties | Improve this Doc View Source UnorderedListSearch The ISearch implementation to be used when searching for items in lists not sorted in any order. Declaration protected static ISearch UnorderedListSearch { get; } Property Value Type Description ISearch Methods | Improve this Doc View Source FindIndexOfNthOccurrenceInBWT(Int32, Int32) Declaration public override int FindIndexOfNthOccurrenceInBWT(int indexOfCharInBWT, int occurrenceRank) Parameters Type Name Description System.Int32 indexOfCharInBWT System.Int32 occurrenceRank Returns Type Description System.Int32 Overrides NaiveFinder.FindIndexOfNthOccurrenceInBWT(Int32, Int32) Remarks This implementation uses a precomputed hash-map of all the positions by each char. Time Complexity = O(1). Space Complexity = O(1). | Improve this Doc View Source FindIndexOfNthOccurrenceInSortedBWT(Int32, Int32) Declaration public override int FindIndexOfNthOccurrenceInSortedBWT(int indexOfCharInBWT, int occurrenceRank) Parameters Type Name Description System.Int32 indexOfCharInBWT System.Int32 occurrenceRank Returns Type Description System.Int32 Overrides BinarySearchFinder.FindIndexOfNthOccurrenceInSortedBWT(Int32, Int32) Remarks | Improve this Doc View Source FindOccurrenceRankOfCharInBWT(Int32) Declaration public override int FindOccurrenceRankOfCharInBWT(int indexOfCharInBWT) Parameters Type Name Description System.Int32 indexOfCharInBWT Returns Type Description System.Int32 Overrides NaiveFinder.FindOccurrenceRankOfCharInBWT(Int32) Remarks ALGORITHM This implementation uses a precomputed hash-map of all the positions by each char. However, unlike SortedBWT , BWT is not sorted, so the precomputed list storing all the indexes where the char of BWT at index indexOfCharInBWT appears can be accessed in O(1) but has to be iterated over linearly. Such a list has in average n / sigma elements, where sigma is the number of distinct chars in the text. If sigma is constant, the Time Complexity is O(n). Space Complexity is always O(1), since O(n * sigma) space has already been allocated to host the result of counts and first occurrences precomputation. | Improve this Doc View Source FindOccurrenceRankOfCharInSortedBWT(Int32) Declaration public override int FindOccurrenceRankOfCharInSortedBWT(int indexOfCharInSortedBWT) Parameters Type Name Description System.Int32 indexOfCharInSortedBWT Returns Type Description System.Int32 Overrides BinarySearchFinder.FindOccurrenceRankOfCharInSortedBWT(Int32) Remarks ALGORITHM This implementation uses a precomputed hash-map of all the positions by each char. It also takes advantage of the fact that SortedBWT is sorted, by running a Binary Search on it, which takes logarithmic time over the list of indexes for the char at position indexOfCharInSortedBWT in BWT . Such list has average size = n / sigma, where n = number of chars in SortedBWT and sigma = size of the alphabet of SortedBWT . If sigma is constant, the list has a size O(n). COMPLEXITY Therefore, Time Complexity = O(log(n)) and Space Complexity = O(1). Implements ILastFirstFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.Builders.LastFirstPropertyBasedBuilder.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Builders.LastFirstPropertyBasedBuilder.html",
    "title": "Class LastFirstPropertyBasedBuilder",
    "keywords": "Class LastFirstPropertyBasedBuilder An extension of NaiveBuilder which takes advantange of the last-first property to reduce the complexity of InvertTransform(RotatedTextWithTerminator) . Inheritance System.Object NaiveBuilder LastFirstPropertyBasedBuilder Implements IBuilder Inherited Members NaiveBuilder.BuildMatrix(TextWithTerminator) NaiveBuilder.BuildMatrix(BWTransform) NaiveBuilder.BuildTransform(BWMatrix) NaiveBuilder.BuildTransform(TextWithTerminator) NaiveBuilder.InvertMatrix(BWMatrix) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.BurrowsWheelerTransform.Builders Assembly : MoreStructures.dll Syntax public class LastFirstPropertyBasedBuilder : NaiveBuilder, IBuilder Remarks A ILastFirstFinder , built by FirstLastFinderBuilder is used to jump between the BWT and its sorted version. Properties | Improve this Doc View Source FirstLastFinderBuilder The strategy by which this builder finds chars in the BWT and its sorted version. Declaration public Func<RotatedTextWithTerminator, ILastFirstFinder> FirstLastFinderBuilder { get; set; } Property Value Type Description Func < RotatedTextWithTerminator , ILastFirstFinder > Methods | Improve this Doc View Source InvertTransform(RotatedTextWithTerminator) Declaration public override TextWithTerminator InvertTransform(RotatedTextWithTerminator lastBWMColumn) Parameters Type Name Description RotatedTextWithTerminator lastBWMColumn Returns Type Description TextWithTerminator Overrides NaiveBuilder.InvertTransform(RotatedTextWithTerminator) Remarks ALGORITHM This implementation inverts the BWT by using the last-first property. - First column of the matrix (sBWT) is just the last column (BWT), sorted. - By last-first property, the 1-st (and only) occurrence of terminator in sBWT at sBWT[0] corresponds to the 1st occurrence of terminator in BWT at BWT[i0]. BWTs[i0] is the 1-st char of the text. - Again by last-first property, the n-th occurrence of c in BWTs at sBWTs[i0] corresponds to the n-th occurrence of c in BWT at BWT[i1]. BWTs[i1] is the 2-st char of the text. - And so on, until BWTs[i(n-1)], the terminator, is reached. COMPLEXITY - Before any iteration, Sorted BWT is computed, taking O(n * log(n)) time, where n is the length of lastBWMColumn . If the alphabet is of constant size sigma, Counting Sort reduces the overall Time Complexity of this step to O(n). - After that the finder may also preallocate other supporting structures, to speed up searches (such the dictionary used in PrecomputedFinder . Although it depends on the specific implementation built by FirstLastFinderBuilder , we may assume this cost to also be linear with n. - From terminator to terminator, there are n top-level iterations. Each iteration takes m1 + m2, where m1 is the cost of FindIndexOfNthOccurrenceInBWT(Int32, Int32) and m2 is the cost of FindOccurrenceRankOfCharInSortedBWT(Int32) . - Finally, the used as accumulator generates the text string. At most O(n). - So total Time Complexity is O(n * (m1 + m2)) and Space Complexity is O(n). Using NaiveFinder , m1 and m2 are both O(n), so Time Complexity is O(n^2). Using BinarySearchFinder , m1 is O(n) and m2 is O(log(n)), so overall Time Complexity is still O(n^2). Using PrecomputedFinder , m1 is O(1), whereas m2 is O(log(n / sigma)) where sigma is the size of the alphabet, so overall Time Complexity is O(n * log(n)) if sigma is constant. Implements IBuilder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.Builders.NaiveBuilder.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Builders.NaiveBuilder.html",
    "title": "Class NaiveBuilder",
    "keywords": "Class NaiveBuilder This implementation adopts the simplest approach at BWMatrix building, which results in a more than quadratic time and space. BWTransform is calculated via the BWMatrix , therefore same level of Time and Space Complexity. Inheritance System.Object NaiveBuilder LastFirstPropertyBasedBuilder Implements IBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.BurrowsWheelerTransform.Builders Assembly : MoreStructures.dll Syntax public class NaiveBuilder : IBuilder Remarks Check specific builder methods, such as BuildMatrix(TextWithTerminator) , for further information about the complexity of each operation. Methods | Improve this Doc View Source BuildMatrix(BWTransform) Rebuilds the original BWMatrix from a BWTransform representing the last column of the Burrows-Wheeler Matrix (which is also the Burrows-Wheeler Transform). Declaration public BWMatrix BuildMatrix(BWTransform lastBWMColumn) Parameters Type Name Description BWTransform lastBWMColumn The last column of the Burrows-Wheeler Matrix. Returns Type Description BWMatrix The matrix, wrapped into a BWMatrix object. Remarks Because the entire Burrows-Wheeler Matrix is built from the text with an invertible function, and the same happens for the Burrows-Wheeler Transform of the text, it's possible to get back the entire matrix from its last column. | Improve this Doc View Source BuildMatrix(TextWithTerminator) Builds Burrows-Wheeler objects, such as BWMatrix and BWTransform of the provided TextWithTerminator . Declaration public virtual BWMatrix BuildMatrix(TextWithTerminator text) Parameters Type Name Description TextWithTerminator text The text to build the BWM, with its terminator (required). Returns Type Description BWMatrix The matrix, wrapped into a BWMatrix object. Remarks COMPLEXITY Since this operation requires computing a n * n matrix, where n is the Length of text , it can be intensive operation, both in time. Time Complexity: - Sorting a large number of strings on a large non-constant alphabet takes n * log(n) * m, where m is the cost of a comparison of two n-sized strings, which is O(n). - Therefore Time Complexity is O(n^2 * log(n)). - If the alphabet can be considered of constant size and comparison between two strings happens in constant time, the complexity is O(n * log(n)). Space Complexity: - The output is a n * n matrix of chars (all cyclic rotations of a n-sized string). - Therefore Space Complexity is O(n^2 * m), when no assumption is made on the size of a char being constant, where m = log(w, M), with w = size of a word in memory and M = size of the alphabet. - If the alphabet can be considered of constant size, the complexity is O(n^2). | Improve this Doc View Source BuildTransform(BWMatrix) Builds the Burrows-Wheeler Transform from the provided BWMatrix . Declaration public virtual BWTransform BuildTransform(BWMatrix matrix) Parameters Type Name Description BWMatrix matrix The matrix, whose BWT has to be calculated. Returns Type Description BWTransform The transform, wrapped into a BWTransform object. Remarks | Improve this Doc View Source BuildTransform(TextWithTerminator) Declaration public virtual BWTransform BuildTransform(TextWithTerminator text) Parameters Type Name Description TextWithTerminator text Returns Type Description BWTransform Remarks COMPLEXITY - Done without constructing the BWMatrix of text , which would requires O(n^2) space. - Instead, n VirtuallyRotatedTextWithTerminator objects are created (one per char of text ), mapping a specific rotation of the original text and taking into account the rotation in its all its char-position dependent functionalities, such as CompareTo(VirtuallyRotatedTextWithTerminator) , GetEnumerator() etc. | Improve this Doc View Source InvertMatrix(BWMatrix) Declaration public virtual TextWithTerminator InvertMatrix(BWMatrix matrix) Parameters Type Name Description BWMatrix matrix Returns Type Description TextWithTerminator Remarks COMPLEXITY - No computation to be done, except for building the string of the TextWithTerminator . - Time Complexity = O(n), Space Complexity = O(n), where n = edge of matrix . | Improve this Doc View Source InvertTransform(RotatedTextWithTerminator) Declaration public virtual TextWithTerminator InvertTransform(RotatedTextWithTerminator lastBWMColumn) Parameters Type Name Description RotatedTextWithTerminator lastBWMColumn Returns Type Description TextWithTerminator Remarks ALGORITHM This implementation inverts the BWT by iteratively building n+1-mers from n-mers. - 1-mers (first column of the matrix) is just the last column (BWT), sorted. That gives a matrix M0 of 1 columns and n rows (where n = length of lastBWMColumn ). - 2-mers are derived from 1-mers, by juxtaposing side-by-side last column (BWT) and M0, sorted. That gives a matrix M1 of 2 columns and n rows. - 3-mers are derived from 2-mers, by juxtaposing side-by-side last column (BWT) and M1, sorted. That gives a matrix M2 of 3 columns and n rows. - And so on, up to (n - 1)-mers and matrix M(n - 2) of n - 1 columns and n rows. - The last column is already known (BWT), so the text can be extracted from the first line: the first char is the separator, the rest is the text without separator. COMPLEXITY - There are n top-level iterations, where n is the length of lastBWMColumn . - Each iteration takes n * log(n) * m time to sort, where m is the length of strings to compare = n. - So total Time Complexity is O(n^3 * log(n)) and Space Complexity is O(n^2). Implements IBuilder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.BWMatrix.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.BWMatrix.html",
    "title": "Class BWMatrix",
    "keywords": "Class BWMatrix The Burrows-Wheeler Matrix (BWM) of a TextWithTerminator is the square matrix all cyclic rotations of the provided TextWithTerminator , with rows sorted in ascending order and taking into account that Terminator is to be considered smaller than any other char in the text. Inheritance System.Object BWMatrix Implements System.IEquatable < BWMatrix > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.BurrowsWheelerTransform Assembly : MoreStructures.dll Syntax public class BWMatrix : IEquatable<BWMatrix> Remarks This langword_csharp_record is a typed wrapped of the underlying langword_csharp_IList{string} representing the BWM. It guarantes immutability and strong typing, and also keeps together the Text and its matrix Content , providing BWM-specific functionalities. Constructors | Improve this Doc View Source BWMatrix(TextWithTerminator, IList<String>) The Burrows-Wheeler Matrix (BWM) of a TextWithTerminator is the square matrix all cyclic rotations of the provided TextWithTerminator , with rows sorted in ascending order and taking into account that Terminator is to be considered smaller than any other char in the text. Declaration public BWMatrix(TextWithTerminator Text, IList<string> Content) Parameters Type Name Description TextWithTerminator Text The text, corresponding to the provided BWM. IList < System.String > Content The content of the Burrows-Wheeler Matrix (BWM) of Text . Remarks This langword_csharp_record is a typed wrapped of the underlying langword_csharp_IList{string} representing the BWM. It guarantes immutability and strong typing, and also keeps together the Text and its matrix Content , providing BWM-specific functionalities. Properties | Improve this Doc View Source Content Declaration public IList<string> Content { get; set; } Property Value Type Description IList < System.String > A readonly immutable list of strings, each one containing a row of the matrix, i.e. a string containing a cyclic rotation of Text . Examples Code: new BWTMatrix(new(\"ab\"), new string[] { \"$ab\", \"ab$\", \"b$a\" }).Content Result: { \"$ab\", \"ab$\", \"b$a\", } | Improve this Doc View Source FirstColumn Returns the first column of this BWMatrix . Corresponds to the sorted Text and also to the sorted Transform of this BWMatrix . Declaration public string FirstColumn { get; } Property Value Type Description System.String Remarks Unlike LastColumn and Transform , FirstColumn wouldn't require computation of the Content of this BWMatrix , since the FirstColumn can easily be calculated by sorting the input Text . Examples Code: new BWTMatrix(new(\"mississippi\")).FirstColumn Result: \"$iiiimppssss\" | Improve this Doc View Source LastColumn Returns the last column of this BWMatrix . Corresponds to the Content of the Transform of this BWMatrix . Declaration public string LastColumn { get; } Property Value Type Description System.String Remarks Requires Content calculation. Examples Code: new BWTMatrix(new(\"mississippi\")).LastColumn Result: \"ipssm$pissii\" | Improve this Doc View Source Text Declaration public TextWithTerminator Text { get; set; } Property Value Type Description TextWithTerminator | Improve this Doc View Source Transform Builds the Burrows-Wheeler Transform from this BWMatrix , which corresponds to the last column of the matrix, stored in Content . Declaration public BWTransform Transform { get; } Property Value Type Description BWTransform A BWTransform object wrapping the string containing the Burrows-Wheeler transform. Remarks Requires Content calculation. Examples Code: new BWTMatrix(new(\"mississippi\")).Transform; Result: \"ipssm$pissii\" Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.BWTransform.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.BWTransform.html",
    "title": "Class BWTransform",
    "keywords": "Class BWTransform The Burrows-Wheeler Transform (BWT) of a TextWithTerminator Text is a permutation of the chars of Text which corresponds to the LastColumn of the BWMatrix of Text . Inheritance System.Object BWTransform Implements System.IEquatable < BWTransform > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.BurrowsWheelerTransform Assembly : MoreStructures.dll Syntax public class BWTransform : IEquatable<BWTransform> Remarks This langword_csharp_record is a typed wrapped of the underlying langword_csharp_string representing the BWT. It guarantes immutability and strong typing, and also keeps together the Text and its transform Content . Constructors | Improve this Doc View Source BWTransform(TextWithTerminator, RotatedTextWithTerminator) The Burrows-Wheeler Transform (BWT) of a TextWithTerminator Text is a permutation of the chars of Text which corresponds to the LastColumn of the BWMatrix of Text . Declaration public BWTransform(TextWithTerminator Text, RotatedTextWithTerminator Content) Parameters Type Name Description TextWithTerminator Text The text to calculate the BWT of. RotatedTextWithTerminator Content The string which corresponds to the transform of the text. Remarks This langword_csharp_record is a typed wrapped of the underlying langword_csharp_string representing the BWT. It guarantes immutability and strong typing, and also keeps together the Text and its transform Content . Fields | Improve this Doc View Source QuickSort A strategy to sort a RotatedTextWithTerminator using , which in turn uses a QuickSort with Time Complexity = O(n * log(n)) in average and O(n^2) in the worst (unlikely) case. Declaration public static readonly BWTransform.SortStrategy QuickSort Field Value Type Description BWTransform.SortStrategy Remarks Tipically used to sort the Burrows-Wheeler Transform. Properties | Improve this Doc View Source Content Declaration public RotatedTextWithTerminator Content { get; set; } Property Value Type Description RotatedTextWithTerminator | Improve this Doc View Source Length The length of this transform, which corresponds to the length of Content . Declaration public int Length { get; } Property Value Type Description System.Int32 | Improve this Doc View Source Text Declaration public TextWithTerminator Text { get; set; } Property Value Type Description TextWithTerminator Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.BWTransform.SortStrategy.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.BWTransform.SortStrategy.html",
    "title": "Delegate BWTransform.SortStrategy",
    "keywords": "Delegate BWTransform.SortStrategy Any strategy to sort the System.Char of a RotatedTextWithTerminator , for example to turn a BWT into its sorted version. Namespace : MoreStructures.BurrowsWheelerTransform Assembly : MoreStructures.dll Syntax public delegate (RotatedTextWithTerminator sortedText, IEnumerable<int> indexesMapping) SortStrategy(RotatedTextWithTerminator text, IComparer<char>? comparer = null); Parameters Type Name Description RotatedTextWithTerminator text The text to be sorted. System.Nullable < IComparer < System.Char >> comparer The of System.Char to be used for comparison. If not specified, a CharOrTerminatorComparer using the Terminator of text is used instead. Returns Type Description System.ValueTuple < RotatedTextWithTerminator , IEnumerable < System.Int32 >> A new RotatedTextWithTerminator , sorted according to the provided comparer , together with a of System.Int32 , defining the mapping of the index of each char of the input text into the index of that char in the sorted version of the text. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.html",
    "title": "Namespace MoreStructures.BurrowsWheelerTransform",
    "keywords": "Namespace MoreStructures.BurrowsWheelerTransform Classes BWMatrix The Burrows-Wheeler Matrix (BWM) of a TextWithTerminator is the square matrix all cyclic rotations of the provided TextWithTerminator , with rows sorted in ascending order and taking into account that Terminator is to be considered smaller than any other char in the text. BWTransform The Burrows-Wheeler Transform (BWT) of a TextWithTerminator Text is a permutation of the chars of Text which corresponds to the LastColumn of the BWMatrix of Text . Delegates BWTransform.SortStrategy Any strategy to sort the System.Char of a RotatedTextWithTerminator , for example to turn a BWT into its sorted version."
  },
  "api/MoreStructures.BurrowsWheelerTransform.Matching.Comparers.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Matching.Comparers.html",
    "title": "Namespace MoreStructures.BurrowsWheelerTransform.Matching.Comparers",
    "keywords": "Namespace MoreStructures.BurrowsWheelerTransform.Matching.Comparers Classes IndexModKPartialSuffixArrayAgainstPatternComparer A SuffixAgainstPatternComparer which uses the provided MoreStructures.SuffixArrays.IndexModKPartialSuffixArray to find the suffix of the provided Text , to compare against the provided Pattern . SuffixAgainstPatternComparer An of System.Int32 , which compares a suffix System.String of Text against the provided System.String pattern, and ignores the second System.Int32 value. SuffixArrayAgainstPatternComparer A SuffixAgainstPatternComparer which compares the suffix System.String corresponding to the i-th element (first System.Int32 value) of the provided MoreStructures.SuffixArrays.SuffixArray , against the provided System.String pattern, and ignores the second System.Int32 value."
  },
  "api/MoreStructures.BurrowsWheelerTransform.Matching.Comparers.IndexModKPartialSuffixArrayAgainstPatternComparer.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Matching.Comparers.IndexModKPartialSuffixArrayAgainstPatternComparer.html",
    "title": "Class IndexModKPartialSuffixArrayAgainstPatternComparer",
    "keywords": "Class IndexModKPartialSuffixArrayAgainstPatternComparer A SuffixAgainstPatternComparer which uses the provided MoreStructures.SuffixArrays.IndexModKPartialSuffixArray to find the suffix of the provided Text , to compare against the provided Pattern . Inheritance System.Object SuffixAgainstPatternComparer IndexModKPartialSuffixArrayAgainstPatternComparer Inherited Members SuffixAgainstPatternComparer.Text SuffixAgainstPatternComparer.Pattern SuffixAgainstPatternComparer.CharComparer SuffixAgainstPatternComparer.LongestMatchFirstValue SuffixAgainstPatternComparer.LongestMatch SuffixAgainstPatternComparer.CompareSuffixAgainstPattern(Int32, Int32) Namespace : MoreStructures.BurrowsWheelerTransform.Matching.Comparers Assembly : MoreStructures.dll Syntax public class IndexModKPartialSuffixArrayAgainstPatternComparer : SuffixAgainstPatternComparer Remarks - This is a generalization of SuffixArrayAgainstPatternComparer , which also supports Partial Suffix Arrays, i.e. Suffix Arrays with incomplete information, and in particular Partial Suffix Arrays of type MoreStructures.SuffixArrays.IndexModKPartialSuffixArray . - When K = 1, an instance of MoreStructures.SuffixArrays.IndexModKPartialSuffixArray contains the index of all suffixes, and is equivalent to a MoreStructures.SuffixArrays.SuffixArray . ALGORITHM - Start from the index I(0) = first term of comparison passed to Compare(Int32, Int32) . - Perform Last-First mapping from I(i) to I(i+1) from BWT to Sorted BWT, until the index I(i) is present in the Partial Suffix Array. While mapping, accumulate all indexes I(0), I(1), ... into a list I. - Once such index I(n) is found, iterate over I in reverse order, updating the Partial Suffix Array, from I(n) all the way back to I(0). - Finally, invoke CompareSuffixAgainstPattern(Int32, Int32) on the value of the Partial Suffix Array at index I(0). COMPLEXITY - There are at most K iterations, where K is the modulo of the Partial Suffix Array: at each iteration, the Last-First mapping finds the index I(i+1), in the Sorted BWT, of a suffix which augments the previous suffix by 1 (prepending a single char). - So there are at most K iterations to update the Partial Suffix Array with I(n), I(n-1), ... I(0). The Partial Suffix Array ends up having at most n elements (1 per suffix of the text). - Finally, there is CompareSuffixAgainstPattern(Int32, Int32) . - Therefore, Time Complexity is O(n * K) and Space Complexity is O(n). Constructors | Improve this Doc View Source IndexModKPartialSuffixArrayAgainstPatternComparer(TextWithTerminator, IndexModKPartialSuffixArray, IEnumerable<Char>, RotatedTextWithTerminator, RotatedTextWithTerminator) Declaration public IndexModKPartialSuffixArrayAgainstPatternComparer(TextWithTerminator text, IndexModKPartialSuffixArray partialSuffixArray, IEnumerable<char> pattern, RotatedTextWithTerminator bwt, RotatedTextWithTerminator sbwt) Parameters Type Name Description TextWithTerminator text The text, to extract suffixes from via partialSuffixArray . MoreStructures.SuffixArrays.IndexModKPartialSuffixArray partialSuffixArray The Partial Suffix Array of text , to map (when the Partial Suffix Array contains such item) the first term of comparison to the starting index in text of the corresponding suffix. IEnumerable < System.Char > pattern The pattern, to compare against each suffix of text . RotatedTextWithTerminator bwt The Burrows-Wheeler Transform of text . Required to instantiate a ILastFirstFinder , to fill-in the gaps of the partialSuffixArray . RotatedTextWithTerminator sbwt The sorted version of bwt . Required to instantiate a ILastFirstFinder , to fill-in the gaps of the partialSuffixArray . Methods | Improve this Doc View Source Compare(Int32, Int32) Compares the suffix of text identified by the x -th element of the Suffix Array, against the pattern. Covers the gap in the provided MoreStructures.SuffixArrays.IndexModKPartialSuffixArray by iteratively using the Last-First Property between BWT and its Sorted version. Declaration public override int Compare(int x, int y) Parameters Type Name Description System.Int32 x System.Int32 y Returns Type Description System.Int32 Overrides SuffixAgainstPatternComparer.Compare(Int32, Int32) Remarks Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.Matching.Comparers.SuffixAgainstPatternComparer.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Matching.Comparers.SuffixAgainstPatternComparer.html",
    "title": "Class SuffixAgainstPatternComparer",
    "keywords": "Class SuffixAgainstPatternComparer An of System.Int32 , which compares a suffix System.String of Text against the provided System.String pattern, and ignores the second System.Int32 value. Inheritance System.Object SuffixAgainstPatternComparer IndexModKPartialSuffixArrayAgainstPatternComparer SuffixArrayAgainstPatternComparer Namespace : MoreStructures.BurrowsWheelerTransform.Matching.Comparers Assembly : MoreStructures.dll Syntax public abstract class SuffixAgainstPatternComparer : IComparer<int> Constructors | Improve this Doc View Source SuffixAgainstPatternComparer(TextWithTerminator, IEnumerable<Char>) Declaration protected SuffixAgainstPatternComparer(TextWithTerminator text, IEnumerable<char> pattern) Parameters Type Name Description TextWithTerminator text IEnumerable < System.Char > pattern Properties | Improve this Doc View Source CharComparer The of System.Char , to be used to compare single chars of the strings to compare (suffixes and pattern). Declaration public IComparer<char> CharComparer { get; } Property Value Type Description IComparer < System.Char > | Improve this Doc View Source LongestMatch The maximum amount of chars of the pattern matched, since the instantiation of this comparer. Declaration public int LongestMatch { get; protected set; } Property Value Type Description System.Int32 Remarks It is never reset. To start over, a new instance of this comparer has to be created. | Improve this Doc View Source LongestMatchFirstValue The value of the first term of comparison, which resulted in LongestMatch chars matched, when comparing the suffix starting at LongestMatchFirstValue against the pattern. Declaration public int LongestMatchFirstValue { get; protected set; } Property Value Type Description System.Int32 Remarks If multiple values of the first term resulted in the same amount of chars matched, the first value encountered is kept. | Improve this Doc View Source Pattern The pattern, to compare against each suffix of Text . Declaration public IEnumerable<char> Pattern { get; } Property Value Type Description IEnumerable < System.Char > | Improve this Doc View Source Text The text, to extract suffixes from. Declaration public TextWithTerminator Text { get; } Property Value Type Description TextWithTerminator Methods | Improve this Doc View Source Compare(Int32, Int32) Compares the suffix of text identified by x against the pattern. Declaration public abstract int Compare(int x, int y) Parameters Type Name Description System.Int32 x The index, in the complete Suffix Array, of the suffix which is first term of comparison. System.Int32 y Ignored. Returns Type Description System.Int32 A positive value if there is mismatch and the suffix is bigger than the pattern lexicographically. A negative value if there is mismatch and the suffix is smaller than the pattern lexicographically. The value 0 if there is full match and pattern and text are of the same length or pattern is shorter. The value -1 if there is full match but the pattern is longer than the suffix. | Improve this Doc View Source CompareSuffixAgainstPattern(Int32, Int32) Compares the suffix of Text starting at index suffixStartIndex against Pattern , returning the result of the comparison as a positive, null or negative System.Int32 . Declaration protected virtual int CompareSuffixAgainstPattern(int bwtIndex, int suffixStartIndex) Parameters Type Name Description System.Int32 bwtIndex The index, in the Burrows-Wheeler Transform, of the first char of the suffix starting at suffixStartIndex . System.Int32 suffixStartIndex The index of Text where suffixStartIndex starts. Returns Type Description System.Int32 A positive System.Int32 , if the suffix is lexicographically bigger than Pattern . A negative System.Int32 , if the suffix is lexicographically smaller than Pattern . Zero, when there is a match, and the suffix is either of longer or of the same length as Pattern . Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.Matching.Comparers.SuffixArrayAgainstPatternComparer.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Matching.Comparers.SuffixArrayAgainstPatternComparer.html",
    "title": "Class SuffixArrayAgainstPatternComparer",
    "keywords": "Class SuffixArrayAgainstPatternComparer A SuffixAgainstPatternComparer which compares the suffix System.String corresponding to the i-th element (first System.Int32 value) of the provided MoreStructures.SuffixArrays.SuffixArray , against the provided System.String pattern, and ignores the second System.Int32 value. Inheritance System.Object SuffixAgainstPatternComparer SuffixArrayAgainstPatternComparer Inherited Members SuffixAgainstPatternComparer.Text SuffixAgainstPatternComparer.Pattern SuffixAgainstPatternComparer.CharComparer SuffixAgainstPatternComparer.LongestMatchFirstValue SuffixAgainstPatternComparer.LongestMatch SuffixAgainstPatternComparer.CompareSuffixAgainstPattern(Int32, Int32) Namespace : MoreStructures.BurrowsWheelerTransform.Matching.Comparers Assembly : MoreStructures.dll Syntax public class SuffixArrayAgainstPatternComparer : SuffixAgainstPatternComparer Remarks COMPLEXITY - When the provided MoreStructures.SuffixArrays.SuffixArray instance has a sequence which doesn't implement , the enumerable has to be enumerated, resulting into a list of exactly n elements. - Because a complete Suffix Array with direct memory access is provided to Compare(Int32, Int32) , getting the starting index of the suffix corresponding to the i-th element is a constant-time operation. - Compare a suffix against the pattern requires comparing at most n chars, where n is the length of Text . - So Time and Space Complexity are both O(n) in the worst case. Space Complexity is O(1) when implements . Constructors | Improve this Doc View Source SuffixArrayAgainstPatternComparer(TextWithTerminator, SuffixArray, IEnumerable<Char>) Declaration public SuffixArrayAgainstPatternComparer(TextWithTerminator text, SuffixArray suffixArray, IEnumerable<char> pattern) Parameters Type Name Description TextWithTerminator text The text, to extract suffixes from via suffixArray . MoreStructures.SuffixArrays.SuffixArray suffixArray The MoreStructures.SuffixArrays.SuffixArray of text , to map the first term of comparison to the starting index in text of the corresponding suffix. IEnumerable < System.Char > pattern The pattern, to compare against each suffix of text . Methods | Improve this Doc View Source Compare(Int32, Int32) Compares the suffix of text identified by the x -th element of the MoreStructures.SuffixArrays.SuffixArray against the pattern. Declaration public override int Compare(int x, int y) Parameters Type Name Description System.Int32 x System.Int32 y Returns Type Description System.Int32 Overrides SuffixAgainstPatternComparer.Compare(Int32, Int32) Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.Matching.CountBasedNarrowingIntervalMatcher.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Matching.CountBasedNarrowingIntervalMatcher.html",
    "title": "Class CountBasedNarrowingIntervalMatcher",
    "keywords": "Class CountBasedNarrowingIntervalMatcher A NarrowingIntervalMatcher refinement which precalculate the count of occurrences of each item at index i in BWT[0..(i - 1)], and the index of first occurrence of each char in SortedBWT, and later uses them to perform in constant time interval narrowing operations within the top-level loop of chars to match. Inheritance System.Object NarrowingIntervalMatcher CountBasedNarrowingIntervalMatcher Implements IMatcher Inherited Members NarrowingIntervalMatcher.OrderedAscListSearch NarrowingIntervalMatcher.BWT NarrowingIntervalMatcher.SortedBWT NarrowingIntervalMatcher.CharComparer NarrowingIntervalMatcher.Match(IEnumerable<Char>) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.BurrowsWheelerTransform.Matching Assembly : MoreStructures.dll Syntax public class CountBasedNarrowingIntervalMatcher : NarrowingIntervalMatcher, IMatcher Remarks Precalculating counts requires iterating over all the chars of the BWT and populating a table of n rows and sigma columns. Precalculating first occurrences also requires iterating over the BWT, and storing a dictionary of n items. Therefore the cost paid upfront is O(n) in time and O(n * sigma) in space. Constructors | Improve this Doc View Source CountBasedNarrowingIntervalMatcher(RotatedTextWithTerminator, RotatedTextWithTerminator) Declaration public CountBasedNarrowingIntervalMatcher(RotatedTextWithTerminator bwt, RotatedTextWithTerminator sbwt) Parameters Type Name Description RotatedTextWithTerminator bwt RotatedTextWithTerminator sbwt Remarks This specific implementation also precalculates two dictionaries: the counts of BWT and the first occurrence of each of the chars of SortedBWT . These two data structures makes single char matching a linear operation. Properties | Improve this Doc View Source LinearSearch The ISearch implementation to be used when looking for the 1st occurrence of each of the items of an enumerable. Declaration protected static ISearch LinearSearch { get; } Property Value Type Description ISearch | Improve this Doc View Source OccurrencesCounter The IOccurrencesCounter implementation to be used when counting the number of occurrences of each of the items of an enumerable. Declaration protected static IOccurrencesCounter OccurrencesCounter { get; } Property Value Type Description IOccurrencesCounter Methods | Improve this Doc View Source BuildLastFirstFinder() Declaration protected override ILastFirstFinder BuildLastFirstFinder() Returns Type Description ILastFirstFinder Overrides NarrowingIntervalMatcher.BuildLastFirstFinder() Remarks Unlike NarrowingIntervalMatcher , this implementation of IMatcher doesn't make explicit calls to LastToFirst(Int32) . Instead it solely uses its precomputed structures and uses the last-first property implicitely when narrowing the current interval via such strucutes in NarrowInterval(Char, ILastFirstFinder, Int32, Int32) . Because of that, it doesn't need an optimized ILastFirstFinder , and in particular one which does precomputation (such as the PrecomputedFinder used by NarrowingIntervalMatcher ), and can just instantiate a NaiveFinder instead. | Improve this Doc View Source NarrowInterval(Char, ILastFirstFinder, Int32, Int32) Declaration protected override (bool success, int narrowedStartIndex, int narrowedEndIndex) NarrowInterval(char currentChar, ILastFirstFinder finder, int startIndex, int endIndex) Parameters Type Name Description System.Char currentChar ILastFirstFinder finder System.Int32 startIndex System.Int32 endIndex Returns Type Description System.ValueTuple < System.Boolean , System.Int32 , System.Int32 > Overrides NarrowingIntervalMatcher.NarrowInterval(Char, ILastFirstFinder, Int32, Int32) Remarks ALGORITHM Narrowing is performed in three sub-steps (compared to the five in NarrowingIntervalMatcher ): 1. The new start index is calculated as the 1st occurrence in SortedBWT of the current char + the count of such char in BWT up to the current start index excluded (i.e. the number of occurrences of the char up to the index before the current start index). 2. The new end index is calculated as the 1st occurrence in SortedBWT of the current char + the count of such char in BWT up to the current end index included, short of one (i.e. the number of occurrences of the char up to the current end index - 1). 3. The narrowed interval in Sorted BWT is returned. COMPLEXITY Total amortized cost is O(1), both in time and space. Implements IMatcher Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.Matching.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Matching.html",
    "title": "Namespace MoreStructures.BurrowsWheelerTransform.Matching",
    "keywords": "Namespace MoreStructures.BurrowsWheelerTransform.Matching Classes CountBasedNarrowingIntervalMatcher A NarrowingIntervalMatcher refinement which precalculate the count of occurrences of each item at index i in BWT[0..(i - 1)], and the index of first occurrence of each char in SortedBWT, and later uses them to perform in constant time interval narrowing operations within the top-level loop of chars to match. Match The result of a pattern matching done by a . NarrowingIntervalMatcher SuffixArrayBasedMatcher A IMatcher implementation which uses a MoreStructures.SuffixArrays.SuffixArray to perform text pattern matching. Interfaces IMatcher An implementation of matching of a pattern against RotatedTextWithTerminator instances, containing the BWT (Burrows-Wheeler Transform) of a text and its sorted version SortedBWT ."
  },
  "api/MoreStructures.BurrowsWheelerTransform.Matching.IMatcher.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Matching.IMatcher.html",
    "title": "Interface IMatcher",
    "keywords": "Interface IMatcher An implementation of matching of a pattern against RotatedTextWithTerminator instances, containing the BWT (Burrows-Wheeler Transform) of a text and its sorted version SortedBWT . Namespace : MoreStructures.BurrowsWheelerTransform.Matching Assembly : MoreStructures.dll Syntax public interface IMatcher Properties | Improve this Doc View Source BWT The Burrows-Wheeler Transform. Also, the last column of the Burrows-Wheeler Matrix. Declaration RotatedTextWithTerminator BWT { get; } Property Value Type Description RotatedTextWithTerminator Examples The Burrows-Wheeler Transform of \"mississippi$\" is \"ipssm$pissii\". | Improve this Doc View Source SortedBWT The sorted version of the Burrows-Wheeler Transform. Also, the first column of the Burrows-Wheeler Matrix. Declaration RotatedTextWithTerminator SortedBWT { get; } Property Value Type Description RotatedTextWithTerminator Examples The Sorted Burrows-Wheeler Transform of \"mississippi$\" is \"$iiiimppssss\". Methods | Improve this Doc View Source Match(IEnumerable<Char>) Tries to match the provided pattern against the text, via the BWT and its sorted version SortedBWT . Declaration Match Match(IEnumerable<char> pattern) Parameters Type Name Description IEnumerable < System.Char > pattern The patter to be matched against the text. Returns Type Description Match The result of the pattern matching, successful or not. Examples var matcher = ... { BWT = \"ipssm$pissii\", SortedBWT = \"$iiiimppssss\" }; var match = matcher.Match(\"issi\"); // match: Success == true, MatchedChars = 4, StartIndex = 3, EndIndex = 4 // 0: $ // 1: i$ // 2: ippi$ // 3: issippi$ <- StartIndex // 4: ississippi$ <- EndIndex // 5: mississippi$ // ... Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.Matching.Match.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Matching.Match.html",
    "title": "Class Match",
    "keywords": "Class Match The result of a pattern matching done by a . Inheritance System.Object Match Implements System.IEquatable < Match > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.BurrowsWheelerTransform.Matching Assembly : MoreStructures.dll Syntax public class Match : IEquatable<Match> Constructors | Improve this Doc View Source Match(Boolean, Int32, Int32, Int32) The result of a pattern matching done by a . Declaration public Match(bool Success, int MatchedChars, int StartIndex, int EndIndex) Parameters Type Name Description System.Boolean Success Whether the pattern matching was successful or not. System.Int32 MatchedChars The number of chars matched from the pattern. If is false , the value will be strictly smaller than the length of the pattern. Otherwise, it will be equal to the length of the pattern. System.Int32 StartIndex The 0-based index, in the Sorted Burrows-Wheeler Transform, of the first char matching. Negative if no matching has happened. System.Int32 EndIndex The 0-based index, in the Sorted Burrows-Wheeler Transform, of the last char matching. Negative if no matching has happened. Properties | Improve this Doc View Source EndIndex Declaration public int EndIndex { get; set; } Property Value Type Description System.Int32 | Improve this Doc View Source MatchedChars Declaration public int MatchedChars { get; set; } Property Value Type Description System.Int32 | Improve this Doc View Source StartIndex Declaration public int StartIndex { get; set; } Property Value Type Description System.Int32 | Improve this Doc View Source Success Declaration public bool Success { get; set; } Property Value Type Description System.Boolean Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.Matching.NarrowingIntervalMatcher.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Matching.NarrowingIntervalMatcher.html",
    "title": "Class NarrowingIntervalMatcher",
    "keywords": "Class NarrowingIntervalMatcher Inheritance System.Object NarrowingIntervalMatcher CountBasedNarrowingIntervalMatcher Implements IMatcher Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.BurrowsWheelerTransform.Matching Assembly : MoreStructures.dll Syntax public class NarrowingIntervalMatcher : IMatcher Remarks ALGORITHM This is a basic implementation, narrowing the matching interval at every iteration with two linear scans of the BWT : - the first from the beginning of the current interval and up to the first char matching the current char; - and the second from the end of the current interval and up to the last char matching the current char. COMPLEXITY - No precomputation cost is paid on instantiation, except for sorting of the BWT to build the SortedBWT , which takes O(n * log(n)) time using QuickSort , but can also run in linear time for a constant size alphabet using the Counting Sort. - Either way, the predominant cost is the main narrowing interval algorithm, which runs for each char in the BWT (i.e. n times) two linear scans of the BWT itself (on the order of n), resulting in quadratic time execution. - Therefore, Time Complexity is O(n^2) and Space Complexity is O(n). Constructors | Improve this Doc View Source NarrowingIntervalMatcher(RotatedTextWithTerminator, RotatedTextWithTerminator) Builds an instance of this finder, for the provided bwt and sbwt . Because both BWT and SortedBWT are provided, no sorting happens. Declaration public NarrowingIntervalMatcher(RotatedTextWithTerminator bwt, RotatedTextWithTerminator sbwt) Parameters Type Name Description RotatedTextWithTerminator bwt The Burrows-Wheeler Transform. Corresponds to the last column of the Burrows-Wheeler Matrix. RotatedTextWithTerminator sbwt The sorted version of the Burrows-Wheeler Transform. Properties | Improve this Doc View Source BWT The Burrows-Wheeler Transform. Also, the last column of the Burrows-Wheeler Matrix. Declaration public RotatedTextWithTerminator BWT { get; } Property Value Type Description RotatedTextWithTerminator | Improve this Doc View Source CharComparer The implementation of of System.Char to be used to comparer chars of BWT or SortedBWT . Declaration protected IComparer<char> CharComparer { get; } Property Value Type Description IComparer < System.Char > | Improve this Doc View Source OrderedAscListSearch The ISearch implementation to be used when searching for items in lists sorted in ascending order. Declaration protected static ISearch OrderedAscListSearch { get; } Property Value Type Description ISearch | Improve this Doc View Source SortedBWT The sorted version of the Burrows-Wheeler Transform. Also, the first column of the Burrows-Wheeler Matrix. Declaration public RotatedTextWithTerminator SortedBWT { get; } Property Value Type Description RotatedTextWithTerminator Methods | Improve this Doc View Source BuildLastFirstFinder() Builds the ILastFirstFinder instance which is then (potentially) used by all iterations of the matching algorithm over the pattern to match against BWT and SortedBWT . Declaration protected virtual ILastFirstFinder BuildLastFirstFinder() Returns Type Description ILastFirstFinder An instance of ILastFirstFinder . Remarks The ILastFirstFinder implementation used is PrecomputedFinder . | Improve this Doc View Source Match(IEnumerable<Char>) Declaration public virtual Match Match(IEnumerable<char> pattern) Parameters Type Name Description IEnumerable < System.Char > pattern Returns Type Description Match Remarks The pattern matching is done via successive narrowing of a interval, defined by a start and an end index. At the beginning the interval is as big as the provided BWTransform (and its text). The algorithm proceeds in reverse: from the last char of the pattern P, P[^1] to the first, P[0]. Search in Sorted BWT for the range of indexes (first1, last1) having value P[^1] via a ISearch implementation (because the input is sorted, binary search is possible). The char in BWT at indexes first1 and last1 represent the predecessor of all instances of P[^1] in P. The interval (first1, last1) can then be narrowed down to (first2, last2), taking into account only the chars in BWT which match the predecessor of P[^1], P[^2]. By last-first property, new indexes (first3, last3) of the chars in Sorted BWT corresponding to first2 and last2 in BWT, can be found. Those are the first and last of the new narrowed range, ready for step 4. When all chars of P, up to P[0], have been consumed, all matches have been identified as an interval in Sorted BWT. | Improve this Doc View Source NarrowInterval(Char, ILastFirstFinder, Int32, Int32) Narrows the provided ( startIndex , endIndex ) interval, (possibly) using the provided ILastFirstFinder finder for last-first matching. Declaration protected virtual (bool success, int narrowedStartIndex, int narrowedEndIndex) NarrowInterval(char currentChar, ILastFirstFinder finder, int startIndex, int endIndex) Parameters Type Name Description System.Char currentChar The char currently being processed. ILastFirstFinder finder The finder used to perform last-first matching, if needed. When pattern matching a single instance is shared across all iterations over the pattern. System.Int32 startIndex The lower extreme of the interval to be narrowed. System.Int32 endIndex The higher extreme of the interval to be narrowed. Returns Type Description System.ValueTuple < System.Boolean , System.Int32 , System.Int32 > An interval narrower than the one provided as input, or (-1, -1), if narrowing resulted into an empty set (i.e. overall matching has failed). Remarks Narrowing is performed in five sub-steps: a linear scan in BWT from startIndex downwards is done, to identify the narrowed start; a linear scan in BWT from endIndex upwards is done, to identify the narrowed end; a last-first of the narrowed start is done, to find the corresponding narrowed start in the Sorted BWT; a last-first of the narrowed end is done, to find the corresponding narrowed end in the Sorted BWT; the narrowed interval in Sorted BWT is returned. Implements IMatcher Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.BurrowsWheelerTransform.Matching.SuffixArrayBasedMatcher.html": {
    "href": "api/MoreStructures.BurrowsWheelerTransform.Matching.SuffixArrayBasedMatcher.html",
    "title": "Class SuffixArrayBasedMatcher",
    "keywords": "Class SuffixArrayBasedMatcher A IMatcher implementation which uses a MoreStructures.SuffixArrays.SuffixArray to perform text pattern matching. Inheritance System.Object SuffixArrayBasedMatcher Implements IMatcher Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.BurrowsWheelerTransform.Matching Assembly : MoreStructures.dll Syntax public class SuffixArrayBasedMatcher : IMatcher Remarks Text and its MoreStructures.SuffixArrays.SuffixArray has to be provided as an additional input. If not already available, it can be built via a SuffixStructureBasedSuffixArrayBuilder<TEdge, TNode> , if a Suffix Structure of the provided text is already available (such as a Suffix Tree or Trie), and via NaiveSuffixArrayBuilder otherwise. The algorithm performs two binary searches over the SortedBWT in sequence. - The first binary search looks for the first index i of the SortedBWT such that the provided pattern matches the i-th element of the MoreStructures.SuffixArrays.SuffixArray (meaning that the pattern is fully contained in the i-th suffix of Text in SuffixArray ). - If i is not found, a failing Match is returned. Otherwise, a second binary search is performed. - The second binary search looks for the last index j of the SortedBWT respecting the same condition as the first binary search. This search starts from the index found in the first search (included). - The second search is guaranteed to succeed (as in the worst case the last occurrence corresponds to the first one, found in the first search. - The array of indexes is as long as the length n of SortedBWT , which is also the length of the text and the MoreStructures.SuffixArrays.SuffixArray . - Each binary search does a number of comparisons which is logarithmic over n. - Each comparison is of at most n chars. - So Time Complexity is O(n * log(n)) and Space Complexity is O(n). Constructors | Improve this Doc View Source SuffixArrayBasedMatcher(RotatedTextWithTerminator, TextWithTerminator, SuffixArray) Declaration public SuffixArrayBasedMatcher(RotatedTextWithTerminator sbwt, TextWithTerminator text, SuffixArray suffixArray) Parameters Type Name Description RotatedTextWithTerminator sbwt TextWithTerminator text MoreStructures.SuffixArrays.SuffixArray suffixArray Remarks Properties | Improve this Doc View Source BWT Declaration public RotatedTextWithTerminator BWT { get; } Property Value Type Description RotatedTextWithTerminator Remarks Unlike SortedBWT , BWT is not required to perform Pattern Matching against Text , and is not supported. | Improve this Doc View Source OrderedAscListSearch The ISearch implementation to be used when searching for items in lists sorted in ascending order. Declaration protected static ISearch OrderedAscListSearch { get; } Property Value Type Description ISearch | Improve this Doc View Source SortedBWT The sorted version of the Burrows-Wheeler Transform. Also, the first column of the Burrows-Wheeler Matrix. Declaration public RotatedTextWithTerminator SortedBWT { get; } Property Value Type Description RotatedTextWithTerminator | Improve this Doc View Source SuffixArray The MoreStructures.SuffixArrays.SuffixArray of Text . Declaration public SuffixArray SuffixArray { get; } Property Value Type Description MoreStructures.SuffixArrays.SuffixArray | Improve this Doc View Source Text The TextWithTerminator , to do pattern matching against. Declaration public TextWithTerminator Text { get; } Property Value Type Description TextWithTerminator Remarks Requires to get the actual suffix from the i-th element of SuffixArray , to be compared against the pattern. Methods | Improve this Doc View Source BuildComparer(IEnumerable<Char>) Builds a SuffixArrayAgainstPatternComparer instance, or a derivation of it, to be used in Match(IEnumerable<Char>) , to find the start and end indexes in SortedBWT , corresponding to first and last matches of the pattern in Text . Declaration protected virtual SuffixArrayAgainstPatternComparer BuildComparer(IEnumerable<char> pattern) Parameters Type Name Description IEnumerable < System.Char > pattern Returns Type Description SuffixArrayAgainstPatternComparer An instance of SuffixArrayAgainstPatternComparer instance, or a derivation of it. | Improve this Doc View Source Match(IEnumerable<Char>) Tries to match the provided pattern against Text , via the SortedBWT and the SuffixArray of Text . Declaration public Match Match(IEnumerable<char> pattern) Parameters Type Name Description IEnumerable < System.Char > pattern Returns Type Description Match Remarks Implements IMatcher Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.CountTrees.CountTreeEdge-2.html": {
    "href": "api/MoreStructures.CountTrees.CountTreeEdge-2.html",
    "title": "Class CountTreeEdge<TEdge, TNode>",
    "keywords": "Class CountTreeEdge<TEdge, TNode> An implementation of , wrapping another implementation of , and linking two instances of wrapper nodes . Inheritance System.Object CountTreeEdge<TEdge, TNode> Implements IRecImmDictIndexedTreeEdge < CountTreeEdge <TEdge, TNode>, CountTreeNode <TEdge, TNode>> System.IEquatable < CountTreeEdge <TEdge, TNode>> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.CountTrees Assembly : MoreStructures.dll Syntax public sealed class CountTreeEdge<TEdge, TNode> : IRecImmDictIndexedTreeEdge<CountTreeEdge<TEdge, TNode>, CountTreeNode<TEdge, TNode>>, IEquatable<CountTreeEdge<TEdge, TNode>> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge TNode Remarks Due to records semantics, two instances wrapping the same underlying edge, or two equivalent edges, will be equal. Examples Edge edge = ... CountTreeEdge<Edge, Node> countEdge = new(edge); Constructors | Improve this Doc View Source CountTreeEdge(TEdge) An implementation of , wrapping another implementation of , and linking two instances of wrapper nodes . Declaration public CountTreeEdge(TEdge WrappedEdge) Parameters Type Name Description TEdge WrappedEdge The edge being wrapped, pointing to descendants which are going to be counted. Remarks Due to records semantics, two instances wrapping the same underlying edge, or two equivalent edges, will be equal. Examples Edge edge = ... CountTreeEdge<Edge, Node> countEdge = new(edge); Properties | Improve this Doc View Source WrappedEdge Declaration public TEdge WrappedEdge { get; set; } Property Value Type Description TEdge Implements IRecImmDictIndexedTreeEdge<TEdge, TNode> System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.CountTrees.CountTreeNode-2.html": {
    "href": "api/MoreStructures.CountTrees.CountTreeNode-2.html",
    "title": "Class CountTreeNode<TEdge, TNode>",
    "keywords": "Class CountTreeNode<TEdge, TNode> An implementation of IRecImmDictIndexedTreeNode<TEdge, TNode> , wrapping another implementation of IRecImmDictIndexedTreeNode<TEdge, TNode> , and counting the total number of descendands the wrapped node has below (node itself excluded). Inheritance System.Object CountTreeNode<TEdge, TNode> Implements IRecImmDictIndexedTreeNode < CountTreeEdge <TEdge, TNode>, CountTreeNode <TEdge, TNode>> System.IEquatable < CountTreeNode <TEdge, TNode>> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.CountTrees Assembly : MoreStructures.dll Syntax public sealed class CountTreeNode<TEdge, TNode> : IRecImmDictIndexedTreeNode<CountTreeEdge<TEdge, TNode>, CountTreeNode<TEdge, TNode>>, IEquatable<CountTreeNode<TEdge, TNode>> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge TNode Remarks RECORDS SEMANTICS Due to records semantics, and the use of value readonly dictionaries, two CountTreeNode<TEdge, TNode> instances wrapping the same underlying node, or two equivalent nodes, will be equal. ITERATIVITY CountTreeNode<TEdge, TNode> structure construction and properties calculation are done lazily. CACHING Once Children and DescendantsCount properties are calculated, they are cached to avoid multiple calculation. This is also one of the reasons why immutability of the wrapped tree is a requirement to use CountTreeNode<TEdge, TNode> . COMPLEXITY Time Complexity = O(n) and Space Complexity = O(n) where n = number of nodes in WrappedNode structure. Leafs are visited only once, intermediate nodes are visited (at most) twice. Examples var wrapped = new Node(1) { Children = new Dictionary<Edge, Node> { [new(1)] = new(2), [new(2)] = new(3) { ... }, [new(5)] = new(6), } }; var wrapping = new CountTreeNode<Edge, Node>(wrapped); Assert.AreEqual(3, wrapping.Children.Count); Constructors | Improve this Doc View Source CountTreeNode(TNode) An implementation of IRecImmDictIndexedTreeNode<TEdge, TNode> , wrapping another implementation of IRecImmDictIndexedTreeNode<TEdge, TNode> , and counting the total number of descendands the wrapped node has below (node itself excluded). Declaration public CountTreeNode(TNode WrappedNode) Parameters Type Name Description TNode WrappedNode The node being wrapped, and whose descendants are going to be counted. Remarks RECORDS SEMANTICS Due to records semantics, and the use of value readonly dictionaries, two CountTreeNode<TEdge, TNode> instances wrapping the same underlying node, or two equivalent nodes, will be equal. ITERATIVITY CountTreeNode<TEdge, TNode> structure construction and properties calculation are done lazily. CACHING Once Children and DescendantsCount properties are calculated, they are cached to avoid multiple calculation. This is also one of the reasons why immutability of the wrapped tree is a requirement to use CountTreeNode<TEdge, TNode> . COMPLEXITY Time Complexity = O(n) and Space Complexity = O(n) where n = number of nodes in WrappedNode structure. Leafs are visited only once, intermediate nodes are visited (at most) twice. Examples var wrapped = new Node(1) { Children = new Dictionary<Edge, Node> { [new(1)] = new(2), [new(2)] = new(3) { ... }, [new(5)] = new(6), } }; var wrapping = new CountTreeNode<Edge, Node>(wrapped); Assert.AreEqual(3, wrapping.Children.Count); Properties | Improve this Doc View Source Children Declaration public IDictionary<CountTreeEdge<TEdge, TNode>, CountTreeNode<TEdge, TNode>> Children { get; } Property Value Type Description IDictionary < CountTreeEdge <TEdge, TNode>, CountTreeNode <TEdge, TNode>> Remarks | Improve this Doc View Source DescendantsCount The number of descendands below this node (node itself excluded). Declaration public int DescendantsCount { get; } Property Value Type Description System.Int32 Remarks | Improve this Doc View Source WrappedNode Declaration public TNode WrappedNode { get; set; } Property Value Type Description TNode Implements IRecImmDictIndexedTreeNode<TEdge, TNode> System.IEquatable<T> Extension Methods RecImmDictIndexedTreeNodeExtensions.IsLeaf<TEdge, TNode>(IRecImmDictIndexedTreeNode<TEdge, TNode>) SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.CountTrees.html": {
    "href": "api/MoreStructures.CountTrees.html",
    "title": "Namespace MoreStructures.CountTrees",
    "keywords": "Namespace MoreStructures.CountTrees Classes CountTreeEdge<TEdge, TNode> An implementation of , wrapping another implementation of , and linking two instances of wrapper nodes . CountTreeNode<TEdge, TNode> An implementation of IRecImmDictIndexedTreeNode<TEdge, TNode> , wrapping another implementation of IRecImmDictIndexedTreeNode<TEdge, TNode> , and counting the total number of descendands the wrapped node has below (node itself excluded)."
  },
  "api/MoreStructures.DisjointSets.html": {
    "href": "api/MoreStructures.DisjointSets.html",
    "title": "Namespace MoreStructures.DisjointSets",
    "keywords": "Namespace MoreStructures.DisjointSets Classes PathCompressionWeightedQuickUnionDisjointSet A WeightedQuickUnionDisjointSet refinement which improves the performance of the data structure by performing a technique known as path compression . QuickFindDisjointSet An IDisjointSet implementation based on a simple to store set ids of each of the values stored in the Disjoint Set. QuickUnionDisjointSet An IDisjointSet implementation based on a simple conceptually storing a forest of trees, by defining the index of the parent node, for each value stored in the data structure. WeightedQuickUnionDisjointSet A QuickUnionDisjointSet refinement which improves the performance of Find by minimizing the height of trees in the forest when merging them in Union(Int32, Int32) . Interfaces IDisjointSet A data structure modelling a collection of sets of non-negative consecutive integer values 0..k-1, where set can be easily merged together and values can be easily checked for membership to the same set."
  },
  "api/MoreStructures.DisjointSets.IDisjointSet.html": {
    "href": "api/MoreStructures.DisjointSets.IDisjointSet.html",
    "title": "Interface IDisjointSet",
    "keywords": "Interface IDisjointSet A data structure modelling a collection of sets of non-negative consecutive integer values 0..k-1, where set can be easily merged together and values can be easily checked for membership to the same set. Namespace : MoreStructures.DisjointSets Assembly : MoreStructures.dll Syntax public interface IDisjointSet Remarks Disjoint sets are effective when dealing with equivalence relationships, i.e. relationships which are reflexive, symmetric and transitive. It's not directly usable when relationships have direction (e.g. if A points to B, B doesn't necessarily points to A). Properties | Improve this Doc View Source SetsCount The number of distinct sets, the data structure is made of. Declaration int SetsCount { get; } Property Value Type Description System.Int32 A non-negative System.Int32 , non-bigger than ValuesCount . | Improve this Doc View Source ValuesCount The number of integer values in the data structure. Declaration int ValuesCount { get; } Property Value Type Description System.Int32 A non-negative System.Int32 . Methods | Improve this Doc View Source AreConnected(Int32, Int32) Whether the two provided integer values belong to the same set, or two disjoint sets. Declaration bool AreConnected(int first, int second) Parameters Type Name Description System.Int32 first The value of the first integer. Must be non-negative and smaller than ValuesCount . System.Int32 second The value of the second integer. Must be non-negative and smaller than ValuesCount . Returns Type Description System.Boolean true if the values belong to the same set, false otherwise. | Improve this Doc View Source Find(Int32) Returns the set identifier of the provided value . Declaration int Find(int value) Parameters Type Name Description System.Int32 value The value of the integer, to find the set of. Must be non-negative and smaller than ValuesCount . Returns Type Description System.Int32 An System.Int32 identifing the set, value is member of. | Improve this Doc View Source Union(Int32, Int32) Establishes a \"union\" relashionship between the integer values first and second , merging the sets of the two values into a single set. Declaration void Union(int first, int second) Parameters Type Name Description System.Int32 first The value of the first integer. Must be non-negative and smaller than ValuesCount . System.Int32 second The value of the second integer. Must be non-negative and smaller than ValuesCount . Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.DisjointSets.PathCompressionWeightedQuickUnionDisjointSet.html": {
    "href": "api/MoreStructures.DisjointSets.PathCompressionWeightedQuickUnionDisjointSet.html",
    "title": "Class PathCompressionWeightedQuickUnionDisjointSet",
    "keywords": "Class PathCompressionWeightedQuickUnionDisjointSet A WeightedQuickUnionDisjointSet refinement which improves the performance of the data structure by performing a technique known as path compression . Inheritance System.Object QuickUnionDisjointSet WeightedQuickUnionDisjointSet PathCompressionWeightedQuickUnionDisjointSet Implements IDisjointSet Inherited Members WeightedQuickUnionDisjointSet.Ranks WeightedQuickUnionDisjointSet.GetRanks() WeightedQuickUnionDisjointSet.Union(Int32, Int32) QuickUnionDisjointSet.Parents QuickUnionDisjointSet.ValuesCount QuickUnionDisjointSet.SetsCount QuickUnionDisjointSet.GetParents() QuickUnionDisjointSet.AreConnected(Int32, Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.DisjointSets Assembly : MoreStructures.dll Syntax public class PathCompressionWeightedQuickUnionDisjointSet : WeightedQuickUnionDisjointSet, IDisjointSet Remarks This variant of WeightedQuickUnionDisjointSet introduces a refinement of the Find(Int32) method, inherited by its upper classes. The Find(Int32) algorithm remains unchanged in its core. However, it produces a flatter forest as side-effect, every time is executed on a value. Check the documentation of Find(Int32) for further details. Constructors | Improve this Doc View Source PathCompressionWeightedQuickUnionDisjointSet(Int32) Initializes the ranks of all singleton trees to 0. Declaration public PathCompressionWeightedQuickUnionDisjointSet(int valuesCount) Parameters Type Name Description System.Int32 valuesCount Methods | Improve this Doc View Source Find(Int32) Declaration public override int Find(int value) Parameters Type Name Description System.Int32 value Returns Type Description System.Int32 Overrides QuickUnionDisjointSet.Find(Int32) Remarks ALGORITHM - The algorithm is pretty much like Find(Int32) , with one main difference. - The difference lies in path compression : once the root of the tree is found, a second traversal, from the value up to its root, is performed. - During the second traversal, each node in path is directly attached to the root. - That keeps the disjoint set equivalent to its previous state, by transitivity of the equivalence relationship. - However, it makes the tree much more flat, and the average height of all the nodes in the forest smaller. - That means that future Find(Int32) , but also Union(Int32, Int32) and AreConnected(Int32, Int32) , will be much faster, since it's faster to reach the root of each tree. COMPLEXITY - Find the root takes a time proportional to the height of the tree, the item is in. - Because path compression keeps trees very flat, incrementing the fan out, while the complexity is not constant and there is definitely a dependence over n, it is a sub-logarithmic dependency. - More precisely, Time Complexity is O(log*(n)), which can be considered \"pseudo-constant\" for any \"real world\" value of n. - Space Complexity remains O(1), since only a constant amount of additional space is required to run the algorithm. Implements IDisjointSet Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.DisjointSets.QuickFindDisjointSet.html": {
    "href": "api/MoreStructures.DisjointSets.QuickFindDisjointSet.html",
    "title": "Class QuickFindDisjointSet",
    "keywords": "Class QuickFindDisjointSet An IDisjointSet implementation based on a simple to store set ids of each of the values stored in the Disjoint Set. Inheritance System.Object QuickFindDisjointSet Implements IDisjointSet Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.DisjointSets Assembly : MoreStructures.dll Syntax public class QuickFindDisjointSet : IDisjointSet Remarks This implementation optimizes Find(Int32) and AreConnected(Int32, Int32) runtime, making them constant-time operations, at the cost of Union(Int32, Int32) , which requires a full scan of the underlying list and hence is a O(n) operation. Check QuickUnionDisjointSet for an alternative implementation of IDisjointSet which does the opposite, in terms of optimization. Constructors | Improve this Doc View Source QuickFindDisjointSet(Int32) Builds a Disjoint Set structure containing valuesCount disjoint values, each one into its own singleton set. Declaration public QuickFindDisjointSet(int valuesCount) Parameters Type Name Description System.Int32 valuesCount Remarks Requires initializing all the valuesCount items of the underlying list. Time and Space Complexity are O(n). Properties | Improve this Doc View Source SetsCount Declaration public int SetsCount { get; } Property Value Type Description System.Int32 Remarks Obtained as the number of distinct values in the underlying list, which is scanned linearly. Time Complexity is O(n) and Space Complexity is O(1), where n is ValuesCount . | Improve this Doc View Source ValuesCount Declaration public int ValuesCount { get; } Property Value Type Description System.Int32 Remarks Set at construction time, based on the constructor parameter. Time and Space Complexity are O(1). Methods | Improve this Doc View Source AreConnected(Int32, Int32) Declaration public bool AreConnected(int first, int second) Parameters Type Name Description System.Int32 first System.Int32 second Returns Type Description System.Boolean Remarks Calculated in constant-time by comparing the set id of the first value with the set id of the second value. Time and Space Complexity are O(1). | Improve this Doc View Source Find(Int32) Declaration public int Find(int value) Parameters Type Name Description System.Int32 value Returns Type Description System.Int32 Remarks Calculated in constant-time by retrieving the set id at index value in the underlying list. | Improve this Doc View Source Union(Int32, Int32) Declaration public void Union(int first, int second) Parameters Type Name Description System.Int32 first System.Int32 second Remarks Retrieves the set id A of first and B of second , via Find(Int32) . Then replaces all occurrences of B with A, in the underlying list. Time Complexity is O(n) and Space Complexity is O(1). Implements IDisjointSet Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.DisjointSets.QuickUnionDisjointSet.html": {
    "href": "api/MoreStructures.DisjointSets.QuickUnionDisjointSet.html",
    "title": "Class QuickUnionDisjointSet",
    "keywords": "Class QuickUnionDisjointSet An IDisjointSet implementation based on a simple conceptually storing a forest of trees, by defining the index of the parent node, for each value stored in the data structure. Inheritance System.Object QuickUnionDisjointSet WeightedQuickUnionDisjointSet Implements IDisjointSet Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.DisjointSets Assembly : MoreStructures.dll Syntax public class QuickUnionDisjointSet : IDisjointSet Remarks This implementation optimizes the runtime of Union(Int32, Int32) , which only requires navigating to the each root instead of a full linear scan of the list, at the cost of Find(Int32) and AreConnected(Int32, Int32) , which also require to navigate to the root. Check QuickFindDisjointSet for an alternative implementation of IDisjointSet which does the opposite, in terms of optimization. Constructors | Improve this Doc View Source QuickUnionDisjointSet(Int32) Builds a Disjoint Set structure containing valuesCount disjoint values, each one into its own singleton tree. Declaration public QuickUnionDisjointSet(int valuesCount) Parameters Type Name Description System.Int32 valuesCount Remarks Requires initializing all the valuesCount items of the underlying list, so that each item is conceptually in its own singleton tree. Time and Space Complexity are O(n). Properties | Improve this Doc View Source Parents Maps the i-th item of the Disjoint Set to the parent in the tree structure, they belong to. I-th items which are roots have parent equal to themselves (i.e. i ). Declaration protected int[] Parents { get; } Property Value Type Description System.Int32 [] | Improve this Doc View Source SetsCount Declaration public virtual int SetsCount { get; } Property Value Type Description System.Int32 Remarks ALGORITHM - Obtained as the number of distinct roots in the forest of trees. - All items i from 0 to ValuesCount - 1 are iterated over. - An item i is a root if it's parent of itself: Parents[i] == i . COMPLEXITY - Checking whether an item is parent of itself is a constant-time operation. - Therefore, Time and Space Complexity are O(n), where n is ValuesCount . | Improve this Doc View Source ValuesCount Declaration public virtual int ValuesCount { get; } Property Value Type Description System.Int32 Remarks Set at construction time, based on the constructor parameter. Time and Space Complexity are O(1). Methods | Improve this Doc View Source AreConnected(Int32, Int32) Declaration public virtual bool AreConnected(int first, int second) Parameters Type Name Description System.Int32 first System.Int32 second Returns Type Description System.Boolean Remarks ALGORITHM - Finds the root of first and the root of second and compares them. - Because the root of a tree is unique, if the two roots coincide, first and second belong to the same tree, and are connected. - Otherwise they belong to two separate trees of the forest, and are not connected. COMPLEXITY - Find the two roots takes a time proportional to the height of the two trees. - If no mechanism to keep trees flat is put in place by this data structure, the height of each is O(n) in the worst case. - Therefore, Time Complexity is O(n). Space Complexity is O(1). - If a sub-class of QuickUnionDisjointSet introduces mechanisms to keep trees flat, the complexity may become sub-linear. An example is WeightedQuickUnionDisjointSet . | Improve this Doc View Source Find(Int32) Declaration public virtual int Find(int value) Parameters Type Name Description System.Int32 value Returns Type Description System.Int32 Remarks ALGORITHM - Finds the root of value , by iteratively traversing the tree upwards, until the root of the tree is reached. - Because the root of a tree is unique and can be reached by every node of the tree navigating upwards, it represents a good identifier of the set of all items in the same tree of the forest. COMPLEXITY - Find the root takes a time proportional to the height of the tree, the item is in. - If no mechanism to keep trees flat is put in place by this data structure, the height of the tree is O(n) in the worst case. - Therefore, Time Complexity is O(n). Space Complexity is O(1). - If a sub-class of QuickUnionDisjointSet introduces mechanisms to keep trees flat, the complexity may become sub-linear. An example is WeightedQuickUnionDisjointSet . | Improve this Doc View Source GetParents() Returns a copy of the parents of all the values of the forest representing the Disjoint Set. Declaration public IList<int> GetParents() Returns Type Description IList < System.Int32 > | Improve this Doc View Source Union(Int32, Int32) Declaration public virtual void Union(int first, int second) Parameters Type Name Description System.Int32 first System.Int32 second Remarks ALGORITHM - It first finds the root R1 of first and the root R2 of second , by running Find(Int32) on each item. - Then, it attaches R2 as immediate child of R1, by setting the parent of R2 to R1. - This way the two three now are merged into a single one, which means that all items of the two trees, including first and second are now in the same set. COMPLEXITY - Find the two roots takes a time proportional to the height of the two trees. - If no mechanism to keep trees flat is put in place by this data structure, the height of each tree is O(n) in the worst case. - Attaching one root as child of the other is a constant-time operation, since it only requires setting the parent in the list of parents, which is O(1) work. - Therefore, Time Complexity is O(n). Space Complexity is O(1). - If a sub-class of QuickUnionDisjointSet introduces mechanisms to keep trees flat, the complexity may become sub-linear. An example is WeightedQuickUnionDisjointSet . Implements IDisjointSet Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.DisjointSets.WeightedQuickUnionDisjointSet.html": {
    "href": "api/MoreStructures.DisjointSets.WeightedQuickUnionDisjointSet.html",
    "title": "Class WeightedQuickUnionDisjointSet",
    "keywords": "Class WeightedQuickUnionDisjointSet A QuickUnionDisjointSet refinement which improves the performance of Find by minimizing the height of trees in the forest when merging them in Union(Int32, Int32) . Inheritance System.Object QuickUnionDisjointSet WeightedQuickUnionDisjointSet PathCompressionWeightedQuickUnionDisjointSet Implements IDisjointSet Inherited Members QuickUnionDisjointSet.Parents QuickUnionDisjointSet.ValuesCount QuickUnionDisjointSet.SetsCount QuickUnionDisjointSet.GetParents() QuickUnionDisjointSet.AreConnected(Int32, Int32) QuickUnionDisjointSet.Find(Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.DisjointSets Assembly : MoreStructures.dll Syntax public class WeightedQuickUnionDisjointSet : QuickUnionDisjointSet, IDisjointSet Remarks By merging by rank, the increment of rank of the trees in the forest when merging is minimized, and the forest is kept as flat as possible after the Union(Int32, Int32) operation. Keeping trees flat is the way to ensure sub-linear, Time Complexity in AreConnected(Int32, Int32) and Find(Int32) , which in the specific case become logarithmic in time. Constructors | Improve this Doc View Source WeightedQuickUnionDisjointSet(Int32) Initializes the ranks of all singleton trees to 0. Declaration public WeightedQuickUnionDisjointSet(int valuesCount) Parameters Type Name Description System.Int32 valuesCount Properties | Improve this Doc View Source Ranks Maps the i-th item of the Disjoint Set to its rank in the tree structure, they belong to. I-th items which are leaves have rank equal to 0. Declaration protected int[] Ranks { get; } Property Value Type Description System.Int32 [] Remarks The rank of a node in the tree is an upper bound for its height. Ranks are used, instead of heights, because keeping ranks correct is easier than keeping heights correct. Methods | Improve this Doc View Source GetRanks() Returns a copy of the ranks of the trees of the forest representing the Disjoint Set. Declaration public IList<int> GetRanks() Returns Type Description IList < System.Int32 > | Improve this Doc View Source Union(Int32, Int32) Declaration public override void Union(int first, int second) Parameters Type Name Description System.Int32 first System.Int32 second Overrides QuickUnionDisjointSet.Union(Int32, Int32) Remarks ALGORITHM - It first finds the root R1 of first and the root R2 of second , by running Find(Int32) on each item. - Then, it checks the rank of R1, H1 and R2, H2 and uses them to decide whether to attach R1 to R2 or viceversa. - If H1 >= H2 , it attaches R2 as immediate child of R1, by setting the parent of R2 to R1. - Otherwise, it attaches R1 as immediate child of R2, by setting the parent of R1 to R2. - This way the two three now are merged into a single one, which means that all items of the two trees, including first and second are now in the same set. - Moreover, by merging based on ranks H1 and H2, the rank of the resulting tree is minimized. - Finally the rank of the new root (R1 or R2), is updated, to reflect the merge. COMPLEXITY - Find the two roots takes a time proportional to the rank of the two trees. - Thanks to the \"merging by rank\", unlike in QuickUnionDisjointSet , the rank of each tree in the forest is not O(n) in the worst case, but O(log(n)). - Attaching one root as child of the other is a constant-time operation, since it only requires setting the parent in the list of parents, which is O(1) work. - Updating the rank of the root of the merged tree is also a constant-time operation. - Therefore, Time Complexity is O(log(n)). Space Complexity is O(1). Implements IDisjointSet Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.AdjacencyListGraph.html": {
    "href": "api/MoreStructures.Graphs.AdjacencyListGraph.html",
    "title": "Class AdjacencyListGraph",
    "keywords": "Class AdjacencyListGraph A graph data structure, represented as an ordered list of neighborhoods: the i-th item of the list is the set of ids of the vertices which are neighbors of the vertex with id i. Inheritance System.Object AdjacencyListGraph Implements IGraph System.IEquatable < AdjacencyListGraph > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs Assembly : MoreStructures.dll Syntax public class AdjacencyListGraph : IGraph, IEquatable<AdjacencyListGraph> Remarks This representation doesn't support multigraphs , i.e. graphs which can have multiple parallel edges between the same two vertices. If the graph can be considered undirected if all edges come in couples with both directions: i.e. when the neighborhoods list L is such that if v2 belongs to L[v1], then v1 belongs to L[v2] . The size of this data structure is proportional to the number of edges of the graph, since a vertex has as many neighbors as edges connecting to other vertices (possibly including itself). So, this graph representation is particularly useful when the number is edges is smaller or proportional to the number of vertices in the graph, i.e. when the graph is sparse (i.e. when e is O(v)). It becomes an expensive representation when the graph is dense (i.e. when e is O(v^2)). While having size proportional to the number of edges, AdjacencyListGraph is more convenient than EdgeListGraph to run neighborhood-based algorithms, such as discovery, because it makes easier and faster to get neighbors of a vertex. Examples The followin graph: 0 --> 1 <==> 3 | ^ ^ / | | / / | | / / v |/ / 2 <----- is represented as AdjacencyListGraph(new { new { 1, 2 }, new { 3 }, new { 0, 1 }, new { 1, 2 } }) . Constructors | Improve this Doc View Source AdjacencyListGraph(IList<ISet<Int32>>) A graph data structure, represented as an ordered list of neighborhoods: the i-th item of the list is the set of ids of the vertices which are neighbors of the vertex with id i. Declaration public AdjacencyListGraph(IList<ISet<int>> Neighborhoods) Parameters Type Name Description IList < ISet < System.Int32 >> Neighborhoods A list of sets of integers, each set representing the neighborhood of the corresponding vertex. Remarks This representation doesn't support multigraphs , i.e. graphs which can have multiple parallel edges between the same two vertices. If the graph can be considered undirected if all edges come in couples with both directions: i.e. when the neighborhoods list L is such that if v2 belongs to L[v1], then v1 belongs to L[v2] . The size of this data structure is proportional to the number of edges of the graph, since a vertex has as many neighbors as edges connecting to other vertices (possibly including itself). So, this graph representation is particularly useful when the number is edges is smaller or proportional to the number of vertices in the graph, i.e. when the graph is sparse (i.e. when e is O(v)). It becomes an expensive representation when the graph is dense (i.e. when e is O(v^2)). While having size proportional to the number of edges, AdjacencyListGraph is more convenient than EdgeListGraph to run neighborhood-based algorithms, such as discovery, because it makes easier and faster to get neighbors of a vertex. Examples The followin graph: 0 --> 1 <==> 3 | ^ ^ / | | / / | | / / v |/ / 2 <----- is represented as AdjacencyListGraph(new { new { 1, 2 }, new { 3 }, new { 0, 1 }, new { 1, 2 } }) . Properties | Improve this Doc View Source Neighborhoods Declaration public IList<ISet<int>> Neighborhoods { get; set; } Property Value Type Description IList < ISet < System.Int32 >> Methods | Improve this Doc View Source GetAdjacentVerticesAndEdges(Int32, Boolean) Declaration public IEnumerable<IGraph.Adjacency> GetAdjacentVerticesAndEdges(int start, bool takeIntoAccountEdgeDirection) Parameters Type Name Description System.Int32 start System.Boolean takeIntoAccountEdgeDirection Returns Type Description IEnumerable < IGraph.Adjacency > Remarks ALGORITHM - Because the neighborhoods list is indexed by the vertex id, the algorithm has just to perform a direct access to the start -th item: that is the set of neighbors of the vertex with id start . - When the value of takeIntoAccountEdgeDirection is false , a lookup of all neighborhoods is required. - In such case it would be better to have neighborhoods list already including bi-directional edges, and using takeIntoAccountEdgeDirection = true . If not, the advantages of having O(1) neighborhood lookup would be lost. - If bi-directional edges are not included in the graph, and many calls to this method need to be called with takeIntoAccountEdgeDirection = true , consider reversing the graph using Reverse() , and keep one structure for direct lookup and the other for reversed lookup. COMPLEXITY - Direct access to the neighborhoods list is a constant time operation. - Therefore, when takeIntoAccountEdgeDirection = true , Time and Space Complexity (when enumerated) are O(avg_e), where avg_e is the average number of edges coming out of the start vertex. - However, when takeIntoAccountEdgeDirection = false , Time Complexity becomes O(avg_e + v), where v is the number of vertices of the graph (i.e. the number of total neighborhoods defined). | Improve this Doc View Source GetAllEdges() Declaration public IEnumerable<(int edgeStart, int edgeEnd)> GetAllEdges() Returns Type Description IEnumerable < System.ValueTuple < System.Int32 , System.Int32 >> Remarks ALGORITHM - Iterates over all the neighborhoods. - For each neighbor v of the vertex u, returns the edge (u, v). COMPLEXITY - There are v neighbors in total (as many as the number of vertices in the graph). - The total number of neighbors across all neighborhoods is e (as many as the number of edges in the graph). - Therefore Time Complexity is O(v + e). Space Complexity is O(1), since the iteration uses a constant amount of space. | Improve this Doc View Source GetNumberOfVertices() Declaration public int GetNumberOfVertices() Returns Type Description System.Int32 Remarks In the AdjacencyListGraph representation, corresponds to number of neighborhoods. Time and Space Complexity are O(1). | Improve this Doc View Source Reverse() Declaration public IGraph Reverse() Returns Type Description IGraph Remarks ALGORITHM - Because AdjacencyListGraph has O(avg_e + v) Time Complexity when edges have to be traversed in reverse, rather than O(avg_e), which is much smaller on large graphs, a proxy to the original data structure is not used. - Instead, reversed neighborhoods RV are calculated, by iterating over all neighbors u of the neighborhood N[v] of each vertex v of this graph: if u belongs to N[v] then v is added to RV[u], initially set to an empty . - Finally a new AdjacencyListGraph is built out of RV and returned as result. COMPLEXITY - Unlike in Reverse() , a brand new structure is built, and proxies are not used at all. - There are as many neighborhoods and reversed neighbors as vertices in the graph. - The cost of going through all the neighbors in all the neighborhoods is proportional to the number of edges in the graph. - Therefore Time and Space Complexity are O(v + e), where v is the number of vertices and e the number of edges. Implements IGraph System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.AdjacencyMatrixGraph.html": {
    "href": "api/MoreStructures.Graphs.AdjacencyMatrixGraph.html",
    "title": "Class AdjacencyMatrixGraph",
    "keywords": "Class AdjacencyMatrixGraph A graph data structure, represented as a matrix: the (i, j) element of the matrix is true if the vertex with id i is neighbor of the vertex with id j, and false otherwise. Inheritance System.Object AdjacencyMatrixGraph Implements IGraph System.IEquatable < AdjacencyMatrixGraph > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs Assembly : MoreStructures.dll Syntax public class AdjacencyMatrixGraph : IGraph, IEquatable<AdjacencyMatrixGraph> Remarks This representation doesn't support multigraphs , i.e. graphs which can have multiple parallel edges between the same two vertices. If the graph can be considered undirected if all edges come in couples with both directions: i.e. the matrix is simmetrix, i.e. M[i, j] == M[j, i] for all (i, j) . The size of this data structure is proportional to the square of the number of vertices of the graph. So, this graph representation is particularly useful when the number is edges is proportional to the square of the number of vertices v in the graph, and O(v) retrieval of the incoming and outgoing edges is required. Performance is O(v), whether takeIntoAccountEdgeDirection is true or not. Notice that O(v) is worse than O(avg_e), where avg_e is the average number of edges coming out of a vertex, for sparse graphs, and comparable for dense graphs. This representation is particularly convenient when used as a directed graph and traversal has often to be done in reversed direction, since Reverse() is an O(1) operation (it just builds a proxy to the original graph) and GetAdjacentVerticesAndEdges(Int32, Boolean) has comparable O(v) complexities when traversing edges according to their direction or in any direction. Notice that AdjacencyListGraph has better runtime (O(avg_e)) when edges are traversed according to their direction, and worse runtime (O(avg_e + v)) when edges are traversed in any direction. EdgeListGraph has consistent runtime in both traversal (O(e)), but e is O(v^2) in dense graphs, leading to sensibly worse performance in such scenarios. Examples The followin graph: 0 --> 1 <==> 3 | ^ ^ / | | / / | | / / v |/ / 2 <----- is represented as AdjacencyMatrixGraph(new {{ F, T, T, F }, { F, F, F, T }, { T, T, F, F }, {F, T, T, F }}) . Constructors | Improve this Doc View Source AdjacencyMatrixGraph(Boolean[,]) A graph data structure, represented as a matrix: the (i, j) element of the matrix is true if the vertex with id i is neighbor of the vertex with id j, and false otherwise. Declaration public AdjacencyMatrixGraph(bool[, ] AdjacencyMatrix) Parameters Type Name Description System.Boolean [,] AdjacencyMatrix A square matrix of boolean, each value representing whether a vertex is neighborhood of another one. Remarks This representation doesn't support multigraphs , i.e. graphs which can have multiple parallel edges between the same two vertices. If the graph can be considered undirected if all edges come in couples with both directions: i.e. the matrix is simmetrix, i.e. M[i, j] == M[j, i] for all (i, j) . The size of this data structure is proportional to the square of the number of vertices of the graph. So, this graph representation is particularly useful when the number is edges is proportional to the square of the number of vertices v in the graph, and O(v) retrieval of the incoming and outgoing edges is required. Performance is O(v), whether takeIntoAccountEdgeDirection is true or not. Notice that O(v) is worse than O(avg_e), where avg_e is the average number of edges coming out of a vertex, for sparse graphs, and comparable for dense graphs. This representation is particularly convenient when used as a directed graph and traversal has often to be done in reversed direction, since Reverse() is an O(1) operation (it just builds a proxy to the original graph) and GetAdjacentVerticesAndEdges(Int32, Boolean) has comparable O(v) complexities when traversing edges according to their direction or in any direction. Notice that AdjacencyListGraph has better runtime (O(avg_e)) when edges are traversed according to their direction, and worse runtime (O(avg_e + v)) when edges are traversed in any direction. EdgeListGraph has consistent runtime in both traversal (O(e)), but e is O(v^2) in dense graphs, leading to sensibly worse performance in such scenarios. Examples The followin graph: 0 --> 1 <==> 3 | ^ ^ / | | / / | | / / v |/ / 2 <----- is represented as AdjacencyMatrixGraph(new {{ F, T, T, F }, { F, F, F, T }, { T, T, F, F }, {F, T, T, F }}) . Properties | Improve this Doc View Source AdjacencyMatrix Declaration public bool[, ] AdjacencyMatrix { get; set; } Property Value Type Description System.Boolean [,] Methods | Improve this Doc View Source GetAdjacentVerticesAndEdges(Int32, Boolean) Declaration public IEnumerable<IGraph.Adjacency> GetAdjacentVerticesAndEdges(int start, bool takeIntoAccountEdgeDirection) Parameters Type Name Description System.Int32 start System.Boolean takeIntoAccountEdgeDirection Returns Type Description IEnumerable < IGraph.Adjacency > Remarks ALGORITHM - Unlike the adjacency list representation, the matrix representation allows to access neighborhoods based on both outgoing and incoming edges of a given vertex (the first is a row, the second is a column). - Therefore, unlike the adjacency list representation, when the value of takeIntoAccountEdgeDirection is false , a lookup of all neighborhoods defined in the matrix (i.e. a full matrix lookup) is not required. - Instead, a single additional lookup of the neighborhood of incoming edges, is required, in addition to the lookup of the of the neighborhood of outgoing edges. - Notice that, while in the adjacency list representation the neighborhood precisely contains the number of neighboring vertices, avg_e, in the adjacency matrix representation the neighborhood is in the form of a boolean array of v items, where v is the number of vertices of the graph. COMPLEXITY - Direct accesses to the two neighborhoods of interest are constant time operations, since it is about retrieving a row and a column given their index, respectively. - The matrix is a square matrix of v rows and columns, so each of the neighborhoods to check has v elements. - Each neighborhood has to be linearly scanned, looking for true values. - Therefore, Time and Space Complexity (when enumerated) are O(v). | Improve this Doc View Source GetAllEdges() Declaration public IEnumerable<(int edgeStart, int edgeEnd)> GetAllEdges() Returns Type Description IEnumerable < System.ValueTuple < System.Int32 , System.Int32 >> Remarks ALGORITHM - Iterates over all the cells of the adjacency matrix M. - For each adjacency M[u, v] set in M, the edge (u, v) is returned. COMPLEXITY - The adjacency matrix has v rows and v columns, where v is the number of vertices in the graph. - Therefore Time Complexity is O(v^2). Space Complexity is O(1), since the iteration uses a constant amount of space. | Improve this Doc View Source GetNumberOfVertices() Declaration public int GetNumberOfVertices() Returns Type Description System.Int32 Remarks In the AdjacencyMatrixGraph representation, corresponds to the edge of the square matrix. Time and Space Complexity are O(1). | Improve this Doc View Source Reverse() Declaration public IGraph Reverse() Returns Type Description IGraph Remarks ALGORITHM - An IGraph proxy is created, wrapping this instance of IGraph . - GetNumberOfVertices() is dispatched to the proxied graph. - GetAdjacentVerticesAndEdges(Int32, Boolean) is directly implemented, accessing AdjacencyMatrix directly. - The implementation is very similar to the one of AdjacencyMatrixGraph : the only difference is that columns and rows are inverted. COMPLEXITY - Since this method just creates a proxy, Time and Space Complexity are O(1). - All operations on the proxy have the same Time and Space Complexity as the corresponding methods in AdjacencyMatrixGraph . Implements IGraph System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.DictionaryAdapterGraphDistances.html": {
    "href": "api/MoreStructures.Graphs.DictionaryAdapterGraphDistances.html",
    "title": "Class DictionaryAdapterGraphDistances",
    "keywords": "Class DictionaryAdapterGraphDistances A IGraphDistances retrieving distances from a , mapping couples of System.Int32 values (ids of endpoints of each edge of the graph) to System.Int32 values (edge distances). Inheritance System.Object DictionaryAdapterGraphDistances Implements IGraphDistances Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs Assembly : MoreStructures.dll Syntax public class DictionaryAdapterGraphDistances : IGraphDistances Constructors | Improve this Doc View Source DictionaryAdapterGraphDistances(IDictionary<(Int32, Int32), Int32>) Declaration public DictionaryAdapterGraphDistances(IDictionary<(int, int), int> dictionary) Parameters Type Name Description IDictionary < System.ValueTuple < System.Int32 , System.Int32 >, System.Int32 > dictionary The mapping between edges and distances. Properties | Improve this Doc View Source Item[(Int32 edgeStart, Int32 edgeEnd)] Declaration public int this[(int edgeStart, int edgeEnd) edge] { get; } Parameters Type Name Description System.ValueTuple < System.Int32 , System.Int32 > edge Property Value Type Description System.Int32 Remarks Retrieves the value from the underlying dictionary. Implements IGraphDistances Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.EdgeListGraph.html": {
    "href": "api/MoreStructures.Graphs.EdgeListGraph.html",
    "title": "Class EdgeListGraph",
    "keywords": "Class EdgeListGraph A graph data structure, represented as an unsorted list of unlabelled edges, connecting unlabelled vertices. Inheritance System.Object EdgeListGraph Implements IGraph System.IEquatable < EdgeListGraph > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs Assembly : MoreStructures.dll Syntax public class EdgeListGraph : IGraph, IEquatable<EdgeListGraph> Remarks This representation does support multigraphs , i.e. graphs which can have multiple parallel edges between the same two vertices. If the edges are considered directional, i.e. (s, e) is considered as a different edge from (e, s), the resulting graph is directed. Otherwise, the resulting graph is undirected. The size of this data structure is proportional to the number of edges of the graph. So, this graph representation is particularly useful when the number is edges is smaller or proportional to the number of vertices in the graph, i.e. when the graph is sparse (i.e. when e is O(v)). It becomes an expensive representation when the graph is dense (i.e. when e is O(v^2)). While having size proportional to the number of edges, EdgeListGraph is less convenient than AdjacencyListGraph to run neighborhood-based algorithms, such as discovery, because it makes more complex and slower to get neighbors of a vertex. Examples The followin graph: 0 --> 1 <==> 3 | ^ ^ / | | / / | | / / v |/ / 2 <----- is represented as EdgeListGraph(4, new { (0, 1), (0, 2), (1, 3), (2, 0), (2, 1), (3, 1), (3, 2) }) . Constructors | Improve this Doc View Source EdgeListGraph(Int32, IList<(Int32 start, Int32 end)>) A graph data structure, represented as an unsorted list of unlabelled edges, connecting unlabelled vertices. Declaration public EdgeListGraph(int NumberOfVertices, IList<(int start, int end)> Edges) Parameters Type Name Description System.Int32 NumberOfVertices The total number n of vertices in the graph, identified with ids from 0 to n - 1. IList < System.ValueTuple < System.Int32 , System.Int32 >> Edges The list of edges of the graph, each one represented as a couple of ids of the vertices which constitute the extremes of the edge. Edges can be considered as directional or not, depending on the scenario. Remarks This representation does support multigraphs , i.e. graphs which can have multiple parallel edges between the same two vertices. If the edges are considered directional, i.e. (s, e) is considered as a different edge from (e, s), the resulting graph is directed. Otherwise, the resulting graph is undirected. The size of this data structure is proportional to the number of edges of the graph. So, this graph representation is particularly useful when the number is edges is smaller or proportional to the number of vertices in the graph, i.e. when the graph is sparse (i.e. when e is O(v)). It becomes an expensive representation when the graph is dense (i.e. when e is O(v^2)). While having size proportional to the number of edges, EdgeListGraph is less convenient than AdjacencyListGraph to run neighborhood-based algorithms, such as discovery, because it makes more complex and slower to get neighbors of a vertex. Examples The followin graph: 0 --> 1 <==> 3 | ^ ^ / | | / / | | / / v |/ / 2 <----- is represented as EdgeListGraph(4, new { (0, 1), (0, 2), (1, 3), (2, 0), (2, 1), (3, 1), (3, 2) }) . Properties | Improve this Doc View Source Edges Declaration public IList<(int start, int end)> Edges { get; set; } Property Value Type Description IList < System.ValueTuple < System.Int32 , System.Int32 >> | Improve this Doc View Source NumberOfVertices Declaration public int NumberOfVertices { get; set; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source GetAdjacentVerticesAndEdges(Int32, Boolean) Declaration public IEnumerable<IGraph.Adjacency> GetAdjacentVerticesAndEdges(int start, bool takeIntoAccountEdgeDirection) Parameters Type Name Description System.Int32 start System.Boolean takeIntoAccountEdgeDirection Returns Type Description IEnumerable < IGraph.Adjacency > Remarks ALGORITHM - Because the edge list is unsorted, and there is no \"index\" or additional data structure which can help retrieving neighbors quickly, the algorithm has to linearly scan the entire edge list, looking for neighbors. COMPLEXITY - Checking whether each edge is a neighbor or not only requires comparing the edge start, when taking into account edge directions, or both start and end, when considering edges as undirected. - Both are constant time operations. - Therefore Time Complexity is O(e), where e is the number of edges, and Space Complexity is O(1). | Improve this Doc View Source GetAllEdges() Declaration public IEnumerable<(int edgeStart, int edgeEnd)> GetAllEdges() Returns Type Description IEnumerable < System.ValueTuple < System.Int32 , System.Int32 >> Remarks ALGORITHM - Just returns the underlying list of edges, as is. COMPLEXITY - Time and Space Complexity are O(1). | Improve this Doc View Source GetNumberOfVertices() Declaration public int GetNumberOfVertices() Returns Type Description System.Int32 Remarks In the EdgeListGraph representation, it's explicitely set in NumberOfVertices . Time and Space Complexity are O(1). | Improve this Doc View Source Reverse() Declaration public IGraph Reverse() Returns Type Description IGraph Remarks ALGORITHM - An IGraph proxy is created, wrapping this instance of IGraph . - GetNumberOfVertices() is dispatched to the proxied graph. - GetAdjacentVerticesAndEdges(Int32, Boolean) is directly implemented, accessing Edges directly. - The implementation is very similar to the one of EdgeListGraph : the only difference is that start and end vertices of each edge are inverted. COMPLEXITY - Since this method just creates a proxy, Time and Space Complexity are O(1). - All operations on the proxy have the same Time and Space Complexity as the corresponding methods in EdgeListGraph . Implements IGraph System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.html": {
    "href": "api/MoreStructures.Graphs.html",
    "title": "Namespace MoreStructures.Graphs",
    "keywords": "Namespace MoreStructures.Graphs Classes AdjacencyListGraph A graph data structure, represented as an ordered list of neighborhoods: the i-th item of the list is the set of ids of the vertices which are neighbors of the vertex with id i. AdjacencyMatrixGraph A graph data structure, represented as a matrix: the (i, j) element of the matrix is true if the vertex with id i is neighbor of the vertex with id j, and false otherwise. DictionaryAdapterGraphDistances A IGraphDistances retrieving distances from a , mapping couples of System.Int32 values (ids of endpoints of each edge of the graph) to System.Int32 values (edge distances). EdgeListGraph A graph data structure, represented as an unsorted list of unlabelled edges, connecting unlabelled vertices. IGraph. An adjacency in a IGraph structure to a vertex, consisting of a neighboring Vertex , connected to the first vertex via edge, identified by EdgeStart and EdgeEnd . Structs IGraph.Adjacency Interfaces IGraph A graph data structure, directed or undirected. IGraphDistances Represents a mapping between edges of a IGraph and distances, in a spatial context, or weights, in a more general setting."
  },
  "api/MoreStructures.Graphs.IGraph..html": {
    "href": "api/MoreStructures.Graphs.IGraph..html",
    "title": "Class IGraph.",
    "keywords": "Class IGraph. An adjacency in a IGraph structure to a vertex, consisting of a neighboring Vertex , connected to the first vertex via edge, identified by EdgeStart and EdgeEnd . Inheritance System.Object IGraph. Implements System.IEquatable < IGraph. > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs Assembly : MoreStructures.dll Syntax public class : IEquatable<IGraph.> Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.IGraph.Adjacency.html": {
    "href": "api/MoreStructures.Graphs.IGraph.Adjacency.html",
    "title": "Struct IGraph.Adjacency",
    "keywords": "Struct IGraph.Adjacency Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.Graphs Assembly : MoreStructures.dll Syntax public struct Adjacency Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.IGraph.html": {
    "href": "api/MoreStructures.Graphs.IGraph.html",
    "title": "Interface IGraph",
    "keywords": "Interface IGraph A graph data structure, directed or undirected. Namespace : MoreStructures.Graphs Assembly : MoreStructures.dll Syntax public interface IGraph Remarks DEFINITION A graph is a data structure composed of two types of objects: vertices and edges . Both vertices and edges can carry labels, weights, costs, or any other piece of information, specific to the scenario in which they are used. More precisely, a graph is conceptually defined as a couple of two collections: - a collection of vertices, - and a collection of edges, connecting such vertices, directionally or undirectionally. The actual underlying representation of a graph instance depends on the specific IGraph used. Methods | Improve this Doc View Source GetAdjacentVerticesAndEdges(Int32, Boolean) Returns the vertices of the graph which are neighbor of the start vertex, each vertex together with its incoming or outgoing edge, linking the vertex to the start vertex. Declaration IEnumerable<IGraph.Adjacency> GetAdjacentVerticesAndEdges(int start, bool takeIntoAccountEdgeDirection) Parameters Type Name Description System.Int32 start The id of the vertex, to look for neighbors of. System.Boolean takeIntoAccountEdgeDirection Whether to consider the direction of edges, when looking for neighbors. Returns Type Description IEnumerable < IGraph.Adjacency > A sequence of IGraph.Adjacency instances, containing the id of the neighboring vertex V found, and the edge which connects the start vertex to V, or viceversa. The order is undefined , and depends on the implementation. | Improve this Doc View Source GetAllEdges() Returns all the edges of this graph. Declaration IEnumerable<(int edgeStart, int edgeEnd)> GetAllEdges() Returns Type Description IEnumerable < System.ValueTuple < System.Int32 , System.Int32 >> A sequence of couples (sourceVertex, targetVertex), each identifying an edge of the graph. | Improve this Doc View Source GetNumberOfVertices() Returns the total number of vertices of the graph. Declaration int GetNumberOfVertices() Returns Type Description System.Int32 A non-negative integer. | Improve this Doc View Source Reverse() Builds the reverse graph, i.e. a graph with the same set of vertices and reversed edges: for each edge (u, v) of the graph G, there is one edge (v, u) in the reverse graph G^-1. Declaration IGraph Reverse() Returns Type Description IGraph A new instance of IGraph , representing the reverse graph. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.IGraphDistances.html": {
    "href": "api/MoreStructures.Graphs.IGraphDistances.html",
    "title": "Interface IGraphDistances",
    "keywords": "Interface IGraphDistances Represents a mapping between edges of a IGraph and distances, in a spatial context, or weights, in a more general setting. Namespace : MoreStructures.Graphs Assembly : MoreStructures.dll Syntax public interface IGraphDistances Properties | Improve this Doc View Source Item[(Int32 edgeStart, Int32 edgeEnd)] Returns the distance, or weight, of the provided edge . Declaration int this[(int edgeStart, int edgeEnd) edge] { get; } Parameters Type Name Description System.ValueTuple < System.Int32 , System.Int32 > edge The edge, to provide the distance of. Property Value Type Description System.Int32 Any positive or negative number. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.MinimumSpanningTree.html": {
    "href": "api/MoreStructures.Graphs.MinimumSpanningTree.html",
    "title": "Namespace MoreStructures.Graphs.MinimumSpanningTree",
    "keywords": "Namespace MoreStructures.Graphs.MinimumSpanningTree Classes KruskalMstFinder A IMstFinder based on the Kruskal's algorithm. PrimMstFinder A IMstFinder implementing Prim's algorithm. Interfaces IMstFinder An algorithm to find the Minimum Spanning Tree (MST) of an undirected, connected, weighted IGraph ."
  },
  "api/MoreStructures.Graphs.MinimumSpanningTree.IMstFinder.html": {
    "href": "api/MoreStructures.Graphs.MinimumSpanningTree.IMstFinder.html",
    "title": "Interface IMstFinder",
    "keywords": "Interface IMstFinder An algorithm to find the Minimum Spanning Tree (MST) of an undirected, connected, weighted IGraph . Namespace : MoreStructures.Graphs.MinimumSpanningTree Assembly : MoreStructures.dll Syntax public interface IMstFinder Remarks DEFINITION The Minimum Spanning Tree of an undirected, connected, weighted graph G = (V, E) with distances defined by the mapping d, shortened in MST, is a subgraph T of G which is: - spanning, i.e. it is composed of v vertices - all the vertices in G; - a tree, i.e. it is connected (single connected component) and composed of v - 1 edges; - of minimum total weight, i.e. the sum of d(e) for all e belonging to T is minimized, across all possible T. The MST of a graph G can be considered as a \"backbone\" of G which minimizes cost of connection: T reaches all vertices of G and it does so by being fully connected (every vertex is still reachable from every other vertex) and of minimum cost (defined as minimum of the sum of the edges of the tree. The definition, as it is formulated, only applies to undirected graphs , since for directed graph the notion of connected components has to be extended to become meaningful (e.g. into \"strongly connected components\"). The definition only applies to connected graphs , since a graph with multiple connected components cannot have a single connected tree spanning the entire graph: the tree would need to have an edge connecting vertices of different connected components, but if that edge existed, the two connected components would be a single one. When a graph G has m connected components, those components can be discovered by running DFS on G and labelling each connected component with ids from 0 to m-1. Each group of vertices G[0], ..., G[m-1] with related edges would represent a connected sub-graph of G, having a MST T[i], where two T[i] and T[j] would be completely separated. The definition only applies to weighted graphs , since an unweighted graph would not allow to give a meaningful metric definition for the \"weight\" to a spanning tree. \"Number of edges\" cannot be used as a metric, because all spanning tree of a graph of v vertices has exactly v nodes and v - 1 edges, so all spanning tree would end up having the same weight. Methods | Improve this Doc View Source Find(IGraph, IGraphDistances) Finds the Minimum Spanning Tree (MST) of the provided graph . Declaration ISet<(int, int)> Find(IGraph graph, IGraphDistances distances) Parameters Type Name Description IGraph graph The IGraph , to find the MST of. IGraphDistances distances The mapping of each edge of graph to its weight, which represents the \"distance\" from the start vertex of the edge to the end vertex. Returns Type Description ISet < System.ValueTuple < System.Int32 , System.Int32 >> The set of edges, in the form (source, target), identifying the MST. Remarks Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.MinimumSpanningTree.KruskalMstFinder.html": {
    "href": "api/MoreStructures.Graphs.MinimumSpanningTree.KruskalMstFinder.html",
    "title": "Class KruskalMstFinder",
    "keywords": "Class KruskalMstFinder A IMstFinder based on the Kruskal's algorithm. Inheritance System.Object KruskalMstFinder Implements IMstFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.MinimumSpanningTree Assembly : MoreStructures.dll Syntax public class KruskalMstFinder : IMstFinder Remarks ALGORITHM - First, all edges of the graph are sorted in ascending order, using the Sorter provided in the constructor. - Then, set of edges MST, which will contain the result, is initialized to an empty set (i.e. no edges included in the spanning tree, before the main loop). - A IDisjointSet DS is also initialized to contain the v values from 0 to v - 1, each value representing a vertex of the graph and at the beginning disjoint from all others. - The disjoint set DS will be used as a cycle detector , i.e. as a data structure able to determine nearly in O(1) (more precisely in O(log*(n)) whether adding an edge to MST would result in a cycle. - Then, the main loop of the algorithm is executed, until MST contains exactly v - 1 edges in it (any spanning tree has to have exactly v vertices and v - 1 edges, otherwise it would not be spanning, or it would not be a tree). - At each iteration, the next minimum edge e is added to MST, if it doesn't introduce a cycle. Otherwise, it is discarded, - To verify whether e = (u, v) introduces a cycle in MST or not, it checks whether v and u are already connected in DS (via AreConnected(Int32, Int32) ), i.e. whether they belong to the same set. - If so, it means that there is already a path (sequence of edges) in MST connecting u and v. Therefore the introduction of the edge e = (u, v) would give a second path from u to v, hence a cycle. - Otherwise, e can safely be added to MST with no introduction of a cycle. The vertices u and v are also united in DS, to reflect the addition of e into MST, in DS as well. - When MST contains v - 1 edges, the number of disjoint sets in DS is checked: if it is 1, it means that all vertices in the graph have been connected by MST, and MST is indeed a Minimum Spanning Tree. - If it is not the case, and there is more than a single disjoint set, an is thrown, since the graph is not connected, and a single tree spanning the entire graph cannot be constructed. COMPLEXITY - The algorithm makes use of an IInPlaceSorting algorithm, to sort all the edges of the graph in ascending order by their distance. - Since sorting edges is required by the algorithm, the overall complexity is lower bounded by O(e * log(e)) = O(e * log(v)). - Such complexity can only be reduced when specific assumptions can be made, on the distance values of the edges (e.g. if integer and within a small range, a non-comparison based, linear search, such as Counting Sort, may be used). - The algorithm also makes use of a IDisjointSet data structure, to detect loops after the potential introduction of each single edge of the graph. - For that reason, for the algorithm to be efficient, when building the Minimum Spanning Tree, the disjoint set should be able to verify connection (via AreConnected(Int32, Int32) ) and to merge vertices (via Union(Int32, Int32) ) in (nearly) constant time. - While this is actually possible, by using a PathCompressionWeightedQuickUnionDisjointSet , the overall complexity is dominated by the edge sorting, which is in general linearithmic over the edges. - For these reasons, Time Complexity is O(e * log(v)). Space Complexity is O(v + e), since large-enough data structures are required to store sorted edges and disjoint sets of vertices. Constructors | Improve this Doc View Source KruskalMstFinder(IInPlaceSorting, Func<Int32, IDisjointSet>) Declaration public KruskalMstFinder(IInPlaceSorting sorter, Func<int, IDisjointSet> disjointSetBuilder) Parameters Type Name Description IInPlaceSorting sorter Func < System.Int32 , IDisjointSet > disjointSetBuilder Properties | Improve this Doc View Source DisjointSetBuilder A build of IDisjointSet instances, used by the algorithm to detect potential cycles in the MST. Declaration public Func<int, IDisjointSet> DisjointSetBuilder { get; } Property Value Type Description Func < System.Int32 , IDisjointSet > | Improve this Doc View Source Sorter The IInPlaceSorting algorithm to be used to sort the edges of the graph. Declaration public IInPlaceSorting Sorter { get; } Property Value Type Description IInPlaceSorting Methods | Improve this Doc View Source Find(IGraph, IGraphDistances) Finds the Minimum Spanning Tree (MST) of the provided graph using the Kruskal's algorithm. Declaration public ISet<(int, int)> Find(IGraph graph, IGraphDistances distances) Parameters Type Name Description IGraph graph IGraphDistances distances Returns Type Description ISet < System.ValueTuple < System.Int32 , System.Int32 >> Remarks Implements IMstFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.MinimumSpanningTree.PrimMstFinder.html": {
    "href": "api/MoreStructures.Graphs.MinimumSpanningTree.PrimMstFinder.html",
    "title": "Class PrimMstFinder",
    "keywords": "Class PrimMstFinder A IMstFinder implementing Prim's algorithm. Inheritance System.Object PrimMstFinder Implements IMstFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.MinimumSpanningTree Assembly : MoreStructures.dll Syntax public class PrimMstFinder : IMstFinder Remarks ALGORITHM - The algorithm closely resembles Dijkstra's algorithm for shortest distance finding. It is a gready algorithm selecting a vertex and the corresponding edge at each iteration, and doing that efficiently thanks to the use of a priority queue and a dictionary of mappings from vertices to edges of shortest distance. - The core idea is to split the vertices of the graph into two sets: the set A of vertices already added to the Minimum Spanning Tree MST, and the set NA of vertices which haven't been added yet to the MST. - At the beginning an arbitrary vertex (id = 0), is included in A and set as last added vertex LA, to bootstrap the process. The set of edges representing the Minimum Spanning Tree, MST, is set to an empty set. The dictionary mapping vertices to shortest distance edges BP is set to an empty dictionary. A min priority queue of vertices, PQ, is also instantiated. - After that the main loop of the algorithm is executed, adding a single vertex LA to A and a single edge to MST at each iteration, and stopping only when A contains v vertices (i.e. when MST is spanning the entire graph). - At each iteration, all edges e, outgoing from and incoming into LA, and connecting LA to a vertex V not yet in A are checked. - If the distance of e, d(e), is strictly smaller than the smallest known edge for V, BP[V], BP is updated and pushed or updated in PQ. - After all edges of LA are checked, the vertex V' connected to A via an edge E' of shortest distance is extracted from PQ, assigned to LA and added to A. E' is added to MST. - After v - 1 iterations, MST is returned as result. COMPLEXITY - All data structures initialization (A, NA, PQ, BP, MST) takes constant amount of time. - During the v - 1 iterations, all edges are visited at most twice: once from the source side and once from the target side. - While checking and updating BP and A take a constant amount of time, pushing or updating the priority in PQ has a runtime which depends on the specific implementation of IUpdatablePriorityQueue<T> used. - The analysis of the impact of the priority queue on the overall performance of the algorithm is similar to the one done in DijkstraShortestDistanceFinder . Check that analysis for further details. - In conclusion, Time Complexity is O(e + v * log(v)) with the best available implementation of an IUpdatablePriorityQueue<T> and O((v + e) * e) with a naive implementation. - Space Complexity is O(v), since all data structures contains O(v) items, all of constant size. Constructors | Improve this Doc View Source PrimMstFinder(Func<IUpdatablePriorityQueue<Int32>>) Declaration public PrimMstFinder(Func<IUpdatablePriorityQueue<int>> priorityQueueBuilder) Parameters Type Name Description Func < IUpdatablePriorityQueue < System.Int32 >> priorityQueueBuilder A builder of a IUpdatablePriorityQueue<T> of System.Int32 values, used by the algorithm to store edges with priority from the closest to any of the vertices of the MST, to the farthest. Methods | Improve this Doc View Source Find(IGraph, IGraphDistances) Finds the Minimum Spanning Tree (MST) of the provided graph using the Prim's algorithm. Declaration public ISet<(int, int)> Find(IGraph graph, IGraphDistances distances) Parameters Type Name Description IGraph graph IGraphDistances distances Returns Type Description ISet < System.ValueTuple < System.Int32 , System.Int32 >> Remarks Implements IMstFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestDistance..html": {
    "href": "api/MoreStructures.Graphs.ShortestDistance..html",
    "title": "Class",
    "keywords": "Class Represents the best estimate of the shortest distance of a vertex in a graph, from a given start vertex. Includes the id of the previous vertex, to reconstruct a path of such shortest distance. Inheritance System.Object Implements System.IEquatable < MoreStructures.Graphs.ShortestDistance. > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.ShortestDistance Assembly : MoreStructures.dll Syntax public class : IEquatable<> Remarks Given: a starting vertex s and another vertex v, both from the set of vertices V of a graph G, and a mapping from V to the corresponding MoreStructures.Graphs.ShortestDistance.BestPrevious estimate of shortest path from s, the full path is enough to reconstruct the entire path from v to s. That is thanks to the following properties of optimal paths: given a correct mapping from vertices to optimal paths for a shortest path, BP; given an optimal path Pv from s to v, where u = BP[v].PreviousVertex is the immediate predecessor of v in Pv; given an optimal path Pu from s to u, where w = BP[u].PreviousVertex is the immediate predecessor of u in Pu; given the path Pu' = Pv - (u, v) , with Pu is different Pu'; Then: the path Pu', although different than Pu, is also an optimal path from s to u; the path Pv' = Pu union (u, v) , although different than Pv, is also an optimal path from s to v. That is, sub-paths of optimal paths are also optimal, and replacing a sub-path in an optimal path by a different optimal sub-path yiels a path different than the initial one, yet optimal. Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestDistance.AStarShortestDistanceFinder.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistance.AStarShortestDistanceFinder.html",
    "title": "Class AStarShortestDistanceFinder",
    "keywords": "Class AStarShortestDistanceFinder A IShortestDistanceFinder implementation based on the A* algorithm, which is a refinement of the Dijkstra's algorithm, introducing a goal-oriented heuristic, driving the search in the direction of the end vertex. Inheritance System.Object PotentialBasedShortestDistanceFinder AStarShortestDistanceFinder Implements IPotentialBasedShortestDistanceFinder IShortestDistanceFinder Inherited Members PotentialBasedShortestDistanceFinder.Finder PotentialBasedShortestDistanceFinder.Find(IGraph, IGraphDistances, Int32, Int32) PotentialBasedShortestDistanceFinder.Find(IGraph, IGraphDistances, Func<Int32, Int32>, Int32, Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.ShortestDistance Assembly : MoreStructures.dll Syntax public class AStarShortestDistanceFinder : PotentialBasedShortestDistanceFinder, IPotentialBasedShortestDistanceFinder, IShortestDistanceFinder Remarks ALGORITHM - The algorithm is described in DijkstraShortestDistanceFinder , with the only difference that edge distances are modified, based on a heuristic defined as a potential function. - New edge distance is defined as follow: given the potential function P, for each edge (u, v) in the graph, d'(u, v) = d(u, v) + P(v) - P(u) . - If P is defined correctly, P(u) and P(v) are good approximations of the distance of u and v from the end vertex e. - If so, P(v) - P(u) will be negative if moving from u to v gets us closer to e and positive if it gets us farther from it. - For this reason, given two vertices v' and v'' connected from u via e' = (u, v') and e'' = (u, v'') , and such that d(e') = d(e'') , if P(v') < P(v'') then d'(e') < d''(e') , so the algorithm will prefer e' over e'' during the exploration, as it seems to be closer to e. - Because the algorithm stops when e is processed, if the algorithm visits e earlier than later, the algorithm will find the shortest path from s to e ealier than later. COMPLEXITY - The complexity heavily depends on the accuracy of the potential function. - A good model of the average performance of the algorithm is very complicated to derive, since the heuristic can drive the exploration much quicker or slower towards the end vertex, depending on how the function is defined. - In general, potential functions which are closer to the actual shortest distance to the end vertex yield better results. The farther they move from the ideal, the less optimized the exploration of the graph becomes. - Worst case remains as in DijkstraShortestDistanceFinder , where all vertices of the graph have to be explored, for a path from the start to the end to be found (or prove there is no path, since start and end lie in two different connected components). - Best case is when P is the shortest distance to e, in which case only the vertices of a shortest path from s to e are visited (which is tipically a small fraction of the vertices of the graph, especially if the graph is large). That is the bare minimum to find the shortest path from s to e. - Average case can even be worse than normal Dijkstra, if P is misleading, i.e. if it drives the exploration away from e, rather than reducing the cost of edges which drives the exploration closer to e. - However, with a well defined P, close enough to the actual shortest distance, Time Complexity is between O(e + v * log(v)) and O(h), where h is the highest number of edges of a shortest path from s to e. - Space Complexity is also between O(h) and O(v). Constructors | Improve this Doc View Source AStarShortestDistanceFinder(Func<IUpdatablePriorityQueue<Int32>>) Declaration public AStarShortestDistanceFinder(Func<IUpdatablePriorityQueue<int>> priorityQueueBuilder) Parameters Type Name Description Func < IUpdatablePriorityQueue < System.Int32 >> priorityQueueBuilder A builder of a IUpdatablePriorityQueue<T> of System.Int32 values, used by the algorithm to store edges with priority from the closest to the start, to the farthest. Implements IPotentialBasedShortestDistanceFinder IShortestDistanceFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestDistance.BellmanFordShortestDistanceFinder.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistance.BellmanFordShortestDistanceFinder.html",
    "title": "Class BellmanFordShortestDistanceFinder",
    "keywords": "Class BellmanFordShortestDistanceFinder An IShortestDistanceFinder implementation based on the Bellman-Ford algorithm. Inheritance System.Object BellmanFordShortestDistanceFinder Implements IShortestDistanceFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.ShortestDistance Assembly : MoreStructures.dll Syntax public class BellmanFordShortestDistanceFinder : IShortestDistanceFinder Remarks ADVANTAGES AND DISADVANTAGES - Unlike DijkstraShortestDistanceFinder , this implementation doesn't require distances to be non-negative and it also works in presence of negative cycles. - Unlike DijkstraShortestDistanceFinder , this algorithm doesn't require any external data structure (such as a IPriorityQueue<T> implementation: its runtime performance solely depends on the algorithm itself. - However, due to the generality of conditions in which it operates, it can't leverage the same performance as the Dijkstra algorithm. So, if the graph doesn't have negative distances, or it can be reduce not to have them, consider using DijkstraShortestDistanceFinder instead, for better performance. - In particolar it has a quadratic performance, instead of the linearithmic Time Complexity of Dijkstra on graphs with non-negative distances or the linear complexity of \"edge relaxation in topological order\" on DAGs. ALGORITHM - As in the Dijkstra Algorithm, a dictionary BP, mapping each vertex to its currently known shortest distance from the start and the previous vertex in a path with such a distance is instantiated. - Then BP is initialized to only contains the start vertex s, which is a distance 0 from itself via an empty path. - After that, the main loop of algorithm is executed v times, where v is the number of edges in the graph. - At each iteration, all the edges in the graph are visited and relaxed . - Edge (u, v) relation is done in the following way: if the distance of u from s in BP is not defined, it is to be considered as +Infinity. Therefore, there is no viable path from s to v via u, and no relation is possible via the edge (u, v). - If the distance BP[u].d of u from s in BP is defined instead, but the distance of v from s in BP is not, the path going from s to v via u becomes the shortest knows, and is set into BP[v]. - If both distances BP[u].d and BP[v].d of u and v from s in BP are defined, there are two possible cases. - Either BP[v].d is non-bigger than BP[u].d + the distance of (u, v), in which case the edge (u, v) won't decrease the current estimate of the shortest path from s to v and won't be relaxed. - Or BP[v].d is strictly bigger, in which case the edge (u, v) does decrease the currently known shortest path from s to v, and will be relaxed, updating BP[v]. - After v - 1 iterations, all edges are fully relaxed if there are no negative cycles. - To check whether that's the case, a last, v-th iteration, is performed. If no edge is relaxed, there are no negative cycles. Otherwise, there are. The set VR, of target vertices of edges relaxed at the v-th iteration, is stored. - If there are negative cycles, each vertex v in VR, and each vertex reachable from v, has -Infinite distance from the start. So a DFS is executed on the graph for each v in VR, and BP is updating, setting BP[v].d to -Infinity and BP[v].previousVertex to null (since there is no actual finite shortest path). - If the end vertex is at a finite distance from the start, BP[e] contains such shortest distance, and the shortest path can be found by backtracking on previous pointers via BP, from e all the way back to s. - Otherwise -Infinity or +Infinity is returned, with an empty path, because either no path exists from the start to the end, or a path exists, but the shortest is infinitely long. COMPLEXITY - BP initialization is done in constant time. - The main loop of the algorithm is performed v times. - Each iteration checks and possibly relaxes all e edges of the graph. A single graph relation requires checking values in BP and edge distances, which are all constant-time operations. - Retrieving all e edges has a complexity which is specific to the IGraph implementation: in a EdgeListGraph it is a O(1) operation, since edges are stored as a flat list. - In a AdjacencyListGraph it is a O(v) operation, since edges are stored in neighborhoods of the v vertices. - In a AdjacencyMatrixGraph it is a O(v^2) operation, as it requires going through the matrix. - In case the presence of negative cycles is detected, up to r DFS explorations are performed, where r is the number of vertices in VR (i.e. target of edges relaxed during the v-th iteration of the main loop). - In the worst case that means work proportional to v * (v + e), when r = v and assuming linear cost for DFS. - In case there are no negative cycles, up to v more iterations are performed to find the shortest path from s to e. - In conclusion Time Complexity is O(v * (v * Tn + e)), where Tn is the time to retrieve the neighborhood of a single vertex. Space Complexity is O(v + Sn), since BP contain at most v items, of constant size. Constructors | Improve this Doc View Source BellmanFordShortestDistanceFinder(Func<IVisitStrategy>) Declaration public BellmanFordShortestDistanceFinder(Func<IVisitStrategy> visitStrategyBuilder) Parameters Type Name Description Func < IVisitStrategy > visitStrategyBuilder Remarks Properties | Improve this Doc View Source VisitStrategyBuilder A building function able to instantiate the IVisitStrategy to be used to find all reachable vertices of vertices relaxed in the last iteration of the main loop of the Bellman-Ford algorithm, by running a Depth First Searches from the start vertex via DepthFirstSearchFromVertex(IGraph, Int32) . Declaration public Func<IVisitStrategy> VisitStrategyBuilder { get; } Property Value Type Description Func < IVisitStrategy > Methods | Improve this Doc View Source Find(IGraph, IGraphDistances, Int32, Int32) Declaration public (int, IList<int>) Find(IGraph graph, IGraphDistances distances, int start, int end) Parameters Type Name Description IGraph graph IGraphDistances distances System.Int32 start System.Int32 end Returns Type Description System.ValueTuple < System.Int32 , IList < System.Int32 >> Remarks Implements IShortestDistanceFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestDistance.BestPreviouses.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistance.BestPreviouses.html",
    "title": "Class BestPreviouses",
    "keywords": "Class BestPreviouses A collection of estimation, indexed by vertex id. Inheritance System.Object BestPreviouses Implements System.IEquatable < BestPreviouses > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.ShortestDistance Assembly : MoreStructures.dll Syntax public class BestPreviouses : IEquatable<BestPreviouses> Remarks Constructors | Improve this Doc View Source BestPreviouses(Dictionary<Int32, BestPrevious>) A collection of estimation, indexed by vertex id. Declaration public BestPreviouses(Dictionary<int, BestPrevious> Values) Parameters Type Name Description Dictionary < System.Int32 , MoreStructures.Graphs.ShortestDistance.BestPrevious > Values The mapping between vertices id and best previous estimations. Remarks Properties | Improve this Doc View Source Values Declaration public Dictionary<int, BestPrevious> Values { get; set; } Property Value Type Description Dictionary < System.Int32 , MoreStructures.Graphs.ShortestDistance.BestPrevious > Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestDistance.BfsBasedShortestDistanceFinder.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistance.BfsBasedShortestDistanceFinder.html",
    "title": "Class BfsBasedShortestDistanceFinder",
    "keywords": "Class BfsBasedShortestDistanceFinder An IShortestDistanceFinder which runs a BFS on the provided graph from the start vertex, to find the shortest distance and a shortest path to the end vertex. Inheritance System.Object BfsBasedShortestDistanceFinder Implements IShortestDistanceFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.ShortestDistance Assembly : MoreStructures.dll Syntax public class BfsBasedShortestDistanceFinder : IShortestDistanceFinder Remarks ALGORITHM - First, a IVisitStrategy is instantiated via the VisitStrategyBuilder provided in the constructor. - The IVisitStrategy instance will be used to run BreadthFirstSearchFromVertex(IGraph, Int32) from the start vertex. - Unlike the Dijkstra algorithm, the BFS visit will traverse all vertices reachable from the start vertex by breadth. Morever it never stops the BFS traversal, even when the current path can't possibly be shortest. - The visitor is instrumented with an event handler H, attached to both VisitingVertex and AlreadyVisitedVertex . - H updates a dictionary SPs mapping each vertex v to its currently known shortest path SP from the start vertex to v and the previous vertex of v in SP. - H also keeps a dictionary DSs mapping each vertex v to the of its currently visited downstream vertices, i.e. all vertices u visited from v during the BFS. - Every time H encounters a vertex v which is not yet in SPs (i.e. it doesn't have a registered shortest path yet), it just adds it to SPs. - Every time H encounters a vertex v which is already is SPs (i.e. it has already a registered shortest path), it adds it to SPs and then updates recursively the entries of SPs of all downstream vertices, using DSs. - After the BFS visit is concluded, there are two possible scenarios: either the end vertex has been discovered by the visit or not. - If the end vertex has not been discovered, it means that there is no path at all from the start to the end vertex. In that case, System.Int32.MaxValue and an emtpy are returned as result. - If the end vertex has been discovered, SPs[end] gives the shortest distance. SPs can be navigated backwards, until the start vertex, to find the path with the shortest distance. COMPLEXITY - While building the IVisitStrategy instance has a complexity that depends on the user-provided VisitStrategyBuilder , it doesn't generally depends on the size of the graph to be visited, and can be considered O(1) work. - Instrumenting the IVisitStrategy instance is also a constant-time operation. - Running the handler for every visited and already visited vertex, however, requires updating vertices downstream, every time an entry SPs is updated, i.e. when a smaller distance from the start is found. That affects the performance of the BFS execution, increasing its Time Complexity. - Because the BFS doesn't stop when the end vertex is found (as there may be longer paths with shorter distance from the start vertex), the downstream vertices to be recursively updated can cover then entire graph (i.e. O(v) vertices). - The complexity of the BFS visit depends on the actual IVisitStrategy implementation used. - Rebuilding and reversing the path takes time and space proportional to the length of the path, which in the worst case can be O(v) where v is the number of vertices of the graph. - Therefore, Time Complexity is O(Tbfs * v + v) and Space Complexity is O(Sbfs + v^2). - If FullyIterativeHashSetBasedGraphVisit or FullyRecursiveHashSetBasedGraphVisit visits are used, with an IGraph retrieving neighbors in constant time, Time Complexity becomes O((v + e) * v) and O(v^2 + e). - On dense graphs, Time Complexity is O(v^3) and Space Complexity is O(v^2). Constructors | Improve this Doc View Source BfsBasedShortestDistanceFinder(Func<IVisitStrategy>) Declaration public BfsBasedShortestDistanceFinder(Func<IVisitStrategy> visitStrategyBuilder) Parameters Type Name Description Func < IVisitStrategy > visitStrategyBuilder Remarks Properties | Improve this Doc View Source VisitStrategyBuilder A building function able to instantiate the IVisitStrategy to be used to find the shortest distance, by running a Breadth First Searches from the start vertex via BreadthFirstSearchFromVertex(IGraph, Int32) . Declaration public Func<IVisitStrategy> VisitStrategyBuilder { get; } Property Value Type Description Func < IVisitStrategy > Methods | Improve this Doc View Source Find(IGraph, IGraphDistances, Int32, Int32) Declaration public (int, IList<int>) Find(IGraph graph, IGraphDistances distances, int start, int end) Parameters Type Name Description IGraph graph IGraphDistances distances System.Int32 start System.Int32 end Returns Type Description System.ValueTuple < System.Int32 , IList < System.Int32 >> Remarks Implements IShortestDistanceFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestDistance.BidirectionalAStarShortestDistanceFinder.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistance.BidirectionalAStarShortestDistanceFinder.html",
    "title": "Class BidirectionalAStarShortestDistanceFinder",
    "keywords": "Class BidirectionalAStarShortestDistanceFinder A IPotentialBasedShortestDistanceFinder implementation based on the bidirectional A* algorithm, which combines the goal-oriented heuristic of the A* algorithm and the double search approach of the bidirectional Dijkstra's algorithm. Inheritance System.Object PotentialBasedShortestDistanceFinder BidirectionalAStarShortestDistanceFinder Implements IPotentialBasedShortestDistanceFinder IShortestDistanceFinder Inherited Members PotentialBasedShortestDistanceFinder.Finder PotentialBasedShortestDistanceFinder.Find(IGraph, IGraphDistances, Int32, Int32) PotentialBasedShortestDistanceFinder.Find(IGraph, IGraphDistances, Func<Int32, Int32>, Int32, Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.ShortestDistance Assembly : MoreStructures.dll Syntax public class BidirectionalAStarShortestDistanceFinder : PotentialBasedShortestDistanceFinder, IPotentialBasedShortestDistanceFinder, IShortestDistanceFinder Remarks ALGORITHM - Same as AStarShortestDistanceFinder , but with the use of the \"bidirectional search approach\" used in BidirectionalDijkstraShortestDistanceFinder to run Dijkstra's algorithm. COMPLEXITY - The bidirectional search cuts in half, in average, the exploration time of AStarShortestDistanceFinder . - That improves average runtime, but doesn't change worst case scenarios and best case scenarios, since in those scenarios the number of vertices to visit is fixed and equal to v and h, respectively, and irrespective of whether the exploration is done unidirectionally or bidirectionally. - Therefore, Time Complexity is O(e + v * log(v)) in the worst case, O(h) in the best case and somewhere in between, still lower than AStarShortestDistanceFinder , in all other cases. - Space Complexity is between O(h) and O(v). Constructors | Improve this Doc View Source BidirectionalAStarShortestDistanceFinder(Func<IUpdatablePriorityQueue<Int32>>) Declaration public BidirectionalAStarShortestDistanceFinder(Func<IUpdatablePriorityQueue<int>> priorityQueueBuilder) Parameters Type Name Description Func < IUpdatablePriorityQueue < System.Int32 >> priorityQueueBuilder A builder of a IUpdatablePriorityQueue<T> of System.Int32 values, used by the algorithm to store edges with priority from the closest to the start, to the farthest. Implements IPotentialBasedShortestDistanceFinder IShortestDistanceFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestDistance.BidirectionalDijkstraShortestDistanceFinder.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistance.BidirectionalDijkstraShortestDistanceFinder.html",
    "title": "Class BidirectionalDijkstraShortestDistanceFinder",
    "keywords": "Class BidirectionalDijkstraShortestDistanceFinder A IShortestDistanceFinder implementation based on a refinement of the Dijkstra algorithm, running search in two parallel inversed flows: from the start vertext to the end vertex and viceversa. Inheritance System.Object BidirectionalDijkstraShortestDistanceFinder Implements IShortestDistanceFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.ShortestDistance Assembly : MoreStructures.dll Syntax public class BidirectionalDijkstraShortestDistanceFinder : IShortestDistanceFinder Remarks REQUIREMENTS - Same as DijkstraShortestDistanceFinder . ALGORITHM - The algorithm runs in parallel two searches: one from the start vertex s and the other one from the end vertex e. - The search from s is called forward search and is run on the provided directed graph, with the provided distance function, as it is done in a normal Dijkstra's algorithm execution. - The search from e is called backward search and is run on the reversed graph, with a reversed distance function: reversedDistance(edgeStart, edgeEnd) = distance(edgeEnd, edgeStart) . - Each search has its own dictionary BP, set A, priority queue PQ and last added vertex LA, which are described in detail in DijkstraShortestDistanceFinder . Data structures for the forward search are called here BPf, Af, PQf and LAf. Data structures for the backward search are called here BPb, Ab, PQb, LAb. - After standard initialization of the two searches (which is different since they have different starting vertex, hence different A and BP initial content etc), the two searches are executed. - The \"parallelism\" is done by running a single step of one of the two searches at each iteration, and alternating between the two searches: first a step forward, then a step backward, then a step forward, etc. - The iterations continue until either a meeting point vertex v has been processed and added to both Af and Ab, or both searches are done (i.e. no more edges to explore). - If the meeting point vertex v hasn't been found before the two searches would run out of edges to explore, it means that e is not reachable from s, and System.Int32.MaxValue and an empty path are returned as result. - Otherwise, a path from s to e exists. However, such a path doesn't necessarily goes through v. - Therefore, the vertex u, of a shortest path from s to e and such that u is known to both BPf and BPb, with the correct shortest path estimates in both directions, has to be found. - It can be proven that such a vertex u exists, which also belongs to Af or Ab or to both. - Therefore, all vertices in both BPf and BPf are scanned, and the one minimizing the sum of estimates, from s and e respectively, is taken. - The full shortest path from s to e is then reconstructed by joining the two subpaths, going from s to u and from u to e respectively. - The shortest path distance is simply the sum of shortest distances for u in BPf and BPb. COMPLEXITY - The worst case analysis is the same as for DijkstraShortestDistanceFinder : in the worst scenario, all vertices have to be explored, before finding the meeting point or concluding that there is no path from s to e. - Rebuilding the final path doesn't change the overall complexity, since calculating the intersection between Af and Ab and finding the vertex minimizing the sum of estimates in BP are both linear time operations. - Therefore, Time Complexity is O((v + e) * v), O((v + e) * log(v)) or O(e + v * log(v)), depending on the IUpdatablePriorityQueue<T> implementation chosen, as described in the documentation of DijkstraShortestDistanceFinder . Space Complexity remains O(v). - While it is true that running the search both from the start and from the end doesn't help asymptotic complexity in the worst case, it does help in the average case, i.e. on the expected number of iterations before the algorithm stops adding vertices. - Intuitively, while a single run of Dijkstra's algorithm from s to e, at distance d = 2 * r from each other, has to explore an area of the graph proportional to Pi * d^2 = 4 * Pi * r^2, a bidirectional Dijkstra's execution explores in average an area proportional to 2 * Pi * r^2. So, half of the area. Constructors | Improve this Doc View Source BidirectionalDijkstraShortestDistanceFinder(Func<IUpdatablePriorityQueue<Int32>>) Declaration public BidirectionalDijkstraShortestDistanceFinder(Func<IUpdatablePriorityQueue<int>> priorityQueueBuilder) Parameters Type Name Description Func < IUpdatablePriorityQueue < System.Int32 >> priorityQueueBuilder A builder of a IUpdatablePriorityQueue<T> of System.Int32 values, used by the algorithm to store edges with priority from the closest to the start, to the farthest. Methods | Improve this Doc View Source Find(IGraph, IGraphDistances, Int32, Int32) Declaration public (int, IList<int>) Find(IGraph graph, IGraphDistances distances, int start, int end) Parameters Type Name Description IGraph graph IGraphDistances distances System.Int32 start System.Int32 end Returns Type Description System.ValueTuple < System.Int32 , IList < System.Int32 >> Remarks Implements IShortestDistanceFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestDistance.DijkstraShortestDistanceFinder.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistance.DijkstraShortestDistanceFinder.html",
    "title": "Class DijkstraShortestDistanceFinder",
    "keywords": "Class DijkstraShortestDistanceFinder A IShortestDistanceFinder implementation based on the Dijkstra algorithm. Inheritance System.Object DijkstraShortestDistanceFinder Implements IShortestDistanceFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.ShortestDistance Assembly : MoreStructures.dll Syntax public class DijkstraShortestDistanceFinder : IShortestDistanceFinder Remarks REQUIREMENTS - Dijkstra algorithm relies on the constraint that edge distances are non-negative . Therefore, there can't be negative loops and adding edges will always result in longer distances. If the graph has negative edges, consider using BellmanFordShortestDistanceFinder instead. - Moreover, given that the path P between two vertices u and v is optimal (i.e. the sum of distances over the edges of the path is minimal), if w is a vertex in P, both the sub-path of P, P1, from u and w, and the sub-path P2, from w to v are optimal. - The algorithm takes advantage of that, by starting from the start vertex s and finding the shortest distance for a single vertex v per iteration: the one minimizing the total distance from the start vertex, via any of the vertices for which the shortest distance has already been calculated. - The vertex processed at each iteration v may not be in the optimal path from s to e. However, the optimal path from s to v is surely optimal. - If e is reachable from s, it will be reached at some point in the traversal. Otherwise, the visit will stop and a System.Int32.MaxValue distance will be returned instead. ALGORITHM - A dictionary BP, mapping each vertex to its currently known shortest distance from the start and the previous vertex in a path with such a distance is instantiated and initialized to only contains the start vertex s, which is a distance 0 from itself via an empty path. - A set A of already added vertices is also instantiated and initialized to only contain s. - A priority queue PQ, storing ids of not yet added vertices by their known shortest total distance from s, is also instantiated empty. - Then, the main loop of the algorithm is executed, until e is not in A. - Neighbors of the last vertex added to A, named hereafter lav, which are not yet in A, are discovered via GetAdjacentVerticesAndEdges(Int32, Boolean) and iterated over. - If the distance d1, of a neighbor v from s via lav, is strictly smaller than the shortest distance from s to a known by BP, d2, both BP and PQ are updated with the new distance (PQ is updated via PushOrUpdate<T>(IUpdatablePriorityQueue<T>, T, Int32) ). - After all the neighbors of lav have been processed, the closest vertex to s non-in A is extracted via a Pop() on PQ, if such a vertex exists. - If it does exist, such vertex is added to A and becomes the new lav. Otherwise, the loop is stopped. - After the loop terminates, if e is in BP, it means that a path, which is also shortest, from a to e has been found, and can be reconstructed backwards by jumping links in BP. - Otherwise no path from s to e exists in the graph, and System.Int32.MaxValue and an empty path are returned as a result. COMPLEXITY - Initializations of the three data structures BP, A and PQ take a constant amount of work. - Each iteration in the main loop adds a new vertex to A, and only vertices not yet in A are processed. - Therefore, the number of iterations in the main loop is at most the number v of vertices in the graph. - At each iteration all edges outgoing from v are checked. - Because in the worst case all vertices of the graph need to be explored, to find the shortest distance to e, the number of edges explored in total can be as high as the total number of edges e in the graph. - For each edge for which a shortest distance is found (in the worst case all e edges of the graph), both BP and PQ have to be updated with the new shortest distance. - Updating BP is done in O(1). Updating PQ, however, has a complexity which depends on the specific IUpdatablePriorityQueue<T> implementation used. - As an example, if a BinaryHeapPriorityQueue<T> is used, updating PQ has logarithmic complexity over the number of items in PQ, which is at most v. So the processing of all edges, across all iterations, takes time proportional to e * log(v). - Moreover, after all neighbors of each vertex are processed, a Pop() is done on PQ, to find the next vertex to add to A. This operation too is logarithmic with the number of items in PQ. So the total cost of all pop operations, across all iterations, takes time proportional to v * log(v). - Therefore, when using a BinaryHeapPriorityQueue<T> , Time Complexity is O((v + e) * log(v)) and Space Complexity is O(v), since all structures contain at most v items, of constant size. - The Time Complexity may change when a different IUpdatablePriorityQueue<T> is used. For instance, if a FibonacciHeapPriorityQueue<T> is used, because push and update operations are done in constant amortized time, the complexity is reduced to O(e + v * log(v)), whereas when a ArrayListPriorityQueue<T> is used, the complexity increases to O((v + e) * v). Constructors | Improve this Doc View Source DijkstraShortestDistanceFinder(Func<IUpdatablePriorityQueue<Int32>>) Declaration public DijkstraShortestDistanceFinder(Func<IUpdatablePriorityQueue<int>> priorityQueueBuilder) Parameters Type Name Description Func < IUpdatablePriorityQueue < System.Int32 >> priorityQueueBuilder A builder of a IUpdatablePriorityQueue<T> of System.Int32 values, used by the algorithm to store edges with priority from the closest to the start, to the farthest. Methods | Improve this Doc View Source Find(IGraph, IGraphDistances, Int32, Int32) Declaration public (int, IList<int>) Find(IGraph graph, IGraphDistances distances, int start, int end) Parameters Type Name Description IGraph graph IGraphDistances distances System.Int32 start System.Int32 end Returns Type Description System.ValueTuple < System.Int32 , IList < System.Int32 >> Remarks Implements IShortestDistanceFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestDistance.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistance.html",
    "title": "Namespace MoreStructures.Graphs.ShortestDistance",
    "keywords": "Namespace MoreStructures.Graphs.ShortestDistance Classes MoreStructures.Graphs.ShortestDistance. Represents the best estimate of the shortest distance of a vertex in a graph, from a given start vertex. Includes the id of the previous vertex, to reconstruct a path of such shortest distance. AStarShortestDistanceFinder A IShortestDistanceFinder implementation based on the A* algorithm, which is a refinement of the Dijkstra's algorithm, introducing a goal-oriented heuristic, driving the search in the direction of the end vertex. BellmanFordShortestDistanceFinder An IShortestDistanceFinder implementation based on the Bellman-Ford algorithm. BestPreviouses A collection of estimation, indexed by vertex id. BfsBasedShortestDistanceFinder An IShortestDistanceFinder which runs a BFS on the provided graph from the start vertex, to find the shortest distance and a shortest path to the end vertex. BidirectionalAStarShortestDistanceFinder A IPotentialBasedShortestDistanceFinder implementation based on the bidirectional A* algorithm, which combines the goal-oriented heuristic of the A* algorithm and the double search approach of the bidirectional Dijkstra's algorithm. BidirectionalDijkstraShortestDistanceFinder A IShortestDistanceFinder implementation based on a refinement of the Dijkstra algorithm, running search in two parallel inversed flows: from the start vertext to the end vertex and viceversa. DijkstraShortestDistanceFinder A IShortestDistanceFinder implementation based on the Dijkstra algorithm. PotentialBasedShortestDistanceFinder An IPotentialBasedShortestDistanceFinder implementation, wrapping a IShortestDistanceFinder algorithm and using a potential function as a heuristic to enhance graph exploration. Interfaces IPotentialBasedShortestDistanceFinder A IShortestDistanceFinder conceptual extension which introduces a potential function heuristic, to better drive the exploration of vertices of the graph, when searching for the end vertex. IShortestDistanceFinder An algorithm that, given starting and ending vertices on a weighted directed graph, finds the shortest distance from the start to the end vertex, and a path on the graph having such a total distance."
  },
  "api/MoreStructures.Graphs.ShortestDistance.IPotentialBasedShortestDistanceFinder.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistance.IPotentialBasedShortestDistanceFinder.html",
    "title": "Interface IPotentialBasedShortestDistanceFinder",
    "keywords": "Interface IPotentialBasedShortestDistanceFinder A IShortestDistanceFinder conceptual extension which introduces a potential function heuristic, to better drive the exploration of vertices of the graph, when searching for the end vertex. Inherited Members IShortestDistanceFinder.Find(IGraph, IGraphDistances, Int32, Int32) Namespace : MoreStructures.Graphs.ShortestDistance Assembly : MoreStructures.dll Syntax public interface IPotentialBasedShortestDistanceFinder : IShortestDistanceFinder Remarks DEFINITION In order for the potential function to be correct and possibly improve (and not decrease) algorithm performance, the function P should have a few properties. Some are mandatory, some are recommended. listed below. - It must be deterministic , i.e. an actual matematical function, yielding the same output for a given input, every time it is called. - It must be feasible , i.e. it should not make distances negative when applied to edge distances on the graph, if Dijkstra is used as shortest path finder . If distances become negative, Dijkstra cannot be applied, as its main requirement would be broken. Notice how it is not enough for the potential function to be non-negative, since the distance d(u, v) of an edge (u, v) of the graph is shifted by the potential difference, i.e. by P(v) - P(u), which can be negative and can make the overall edge cost, d(u, v) + P(v) - P(u), negative. - It should be quick to calculate the potential, not to have an impact on the overall runtime of the algorithm. Tipically O(1). - It should be minimal at the end vertex , so that Dijkstra would be incentivized to go towards that direction, while exploring the graph. - It should become higher as the distance from the end vertex increases , so that Dijkstra would be disincentivized from getting farther from the end vertex. - It tipically is defined as a lower bound for the shortest distance : e.g. the euclidean distance on the map in a road network. Methods | Improve this Doc View Source Find(IGraph, IGraphDistances, Func<Int32, Int32>, Int32, Int32) Finds the shortest distance and path in the provided graph from the start vertex to the end vertex, i.e. a path such that the sum of distances of all the edges on the path is non-bigger than the one of any other path from the provided start and end vertices Declaration (int, IList<int>) Find(IGraph graph, IGraphDistances distances, Func<int, int> potentials, int start, int end) Parameters Type Name Description IGraph graph IGraphDistances distances Func < System.Int32 , System.Int32 > potentials A function mapping each vertex of the provided graph to a System.Int32 , providing an heuristic for \"how far\" the vertex is from the end vertex, to drive the IPotentialBasedShortestDistanceFinder towards an earlier, rather than late, discovery of the end vertex. Check the general documentation of IPotentialBasedShortestDistanceFinder for further information about how to define a correct and good potential function. System.Int32 start System.Int32 end Returns Type Description System.ValueTuple < System.Int32 , IList < System.Int32 >> A couple. The first item of the couple is the shortest distance, as the sum of the distance of each edge of the shortest path between start and end . The second item of the couple is the sequence of vertices of the graph , identifying the shortest path. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestDistance.IShortestDistanceFinder.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistance.IShortestDistanceFinder.html",
    "title": "Interface IShortestDistanceFinder",
    "keywords": "Interface IShortestDistanceFinder An algorithm that, given starting and ending vertices on a weighted directed graph, finds the shortest distance from the start to the end vertex, and a path on the graph having such a total distance. Namespace : MoreStructures.Graphs.ShortestDistance Assembly : MoreStructures.dll Syntax public interface IShortestDistanceFinder Remarks It differs from IShortestPathFinder and its implementation because this class of algorithms takes into account weight of edges (i.e. distances between vertices). By contrast, the class of algorithm implementing IShortestPathFinder only takes into account presence or absence of an edge: i.e. each edge is weighted \"1\", and vertex v is at distance 1 from vertex u if there is a direct edge from v to u, and at distance infinity, if there is no path from v to u. Methods | Improve this Doc View Source Find(IGraph, IGraphDistances, Int32, Int32) Finds the shortest distance and path in the provided graph from the start vertex to the end vertex, i.e. a path such that the sum of distances of all the edges on the path is non-bigger than the one of any other path from the provided start and end vertices Declaration (int, IList<int>) Find(IGraph graph, IGraphDistances distances, int start, int end) Parameters Type Name Description IGraph graph The graph to traverse. IGraphDistances distances A map between each edge of graph and its distance. System.Int32 start The id of the vertex, to start traversal from. System.Int32 end The id of the vertex, to end traversal at. Returns Type Description System.ValueTuple < System.Int32 , IList < System.Int32 >> A couple. The first item of the couple is the shortest distance, as the sum of the distance of each edge of the shortest path between start and end . The second item of the couple is the sequence of vertices of the graph , identifying the shortest path. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestDistance.PotentialBasedShortestDistanceFinder.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistance.PotentialBasedShortestDistanceFinder.html",
    "title": "Class PotentialBasedShortestDistanceFinder",
    "keywords": "Class PotentialBasedShortestDistanceFinder An IPotentialBasedShortestDistanceFinder implementation, wrapping a IShortestDistanceFinder algorithm and using a potential function as a heuristic to enhance graph exploration. Inheritance System.Object PotentialBasedShortestDistanceFinder AStarShortestDistanceFinder BidirectionalAStarShortestDistanceFinder Implements IPotentialBasedShortestDistanceFinder IShortestDistanceFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.ShortestDistance Assembly : MoreStructures.dll Syntax public abstract class PotentialBasedShortestDistanceFinder : IPotentialBasedShortestDistanceFinder, IShortestDistanceFinder Remarks Common ground for all A* variants, such as AStarShortestDistanceFinder and BidirectionalAStarShortestDistanceFinder . Check IPotentialBasedShortestDistanceFinder general documentation for the requirements and desired properties for the heuristic. Constructors | Improve this Doc View Source PotentialBasedShortestDistanceFinder(IShortestDistanceFinder) Declaration protected PotentialBasedShortestDistanceFinder(IShortestDistanceFinder finder) Parameters Type Name Description IShortestDistanceFinder finder Properties | Improve this Doc View Source Finder A IShortestDistanceFinder instance, used to run the shortest distance algorithm on the provided graph. Declaration protected IShortestDistanceFinder Finder { get; } Property Value Type Description IShortestDistanceFinder Methods | Improve this Doc View Source Find(IGraph, IGraphDistances, Func<Int32, Int32>, Int32, Int32) Finds the shortest distance and path in the provided graph from the start vertex to the end vertex, i.e. a path such that the sum of distances of all the edges on the path is non-bigger than the one of any other path from the provided start and end vertices Declaration public (int, IList<int>) Find(IGraph graph, IGraphDistances distances, Func<int, int> potentials, int start, int end) Parameters Type Name Description IGraph graph IGraphDistances distances Func < System.Int32 , System.Int32 > potentials A function mapping each vertex of the provided graph to a System.Int32 , providing an heuristic for \"how far\" the vertex is from the end vertex, to drive the IPotentialBasedShortestDistanceFinder towards an earlier, rather than late, discovery of the end vertex. Check the general documentation of IPotentialBasedShortestDistanceFinder for further information about how to define a correct and good potential function. System.Int32 start System.Int32 end Returns Type Description System.ValueTuple < System.Int32 , IList < System.Int32 >> A couple. The first item of the couple is the shortest distance, as the sum of the distance of each edge of the shortest path between start and end . The second item of the couple is the sequence of vertices of the graph , identifying the shortest path. | Improve this Doc View Source Find(IGraph, IGraphDistances, Int32, Int32) Finds the shortest distance and path in the provided graph from the start vertex to the end vertex, i.e. a path such that the sum of distances of all the edges on the path is non-bigger than the one of any other path from the provided start and end vertices Declaration public (int, IList<int>) Find(IGraph graph, IGraphDistances distances, int start, int end) Parameters Type Name Description IGraph graph The graph to traverse. IGraphDistances distances A map between each edge of graph and its distance. System.Int32 start The id of the vertex, to start traversal from. System.Int32 end The id of the vertex, to end traversal at. Returns Type Description System.ValueTuple < System.Int32 , IList < System.Int32 >> A couple. The first item of the couple is the shortest distance, as the sum of the distance of each edge of the shortest path between start and end . The second item of the couple is the sequence of vertices of the graph , identifying the shortest path. Implements IPotentialBasedShortestDistanceFinder IShortestDistanceFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestDistanceTree.BellmanFordShortestDistanceTreeFinder.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistanceTree.BellmanFordShortestDistanceTreeFinder.html",
    "title": "Class BellmanFordShortestDistanceTreeFinder",
    "keywords": "Class BellmanFordShortestDistanceTreeFinder A IShortestDistanceFinder implementation based on the Bellman-Ford algorithm. Inheritance System.Object BellmanFordShortestDistanceTreeFinder Implements IShortestDistanceTreeFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.ShortestDistanceTree Assembly : MoreStructures.dll Syntax public class BellmanFordShortestDistanceTreeFinder : IShortestDistanceTreeFinder Remarks REQUIREMENTS - Same as BellmanFordShortestDistanceFinder . ALGORITHM - The algorithm closely resembles the one used in BellmanFordShortestDistanceFinder , with the only main difference that paths from the start vertex are reconstructed, since that would need to be done for each of the vertices of the graph, resulting in a worst case O(v^2) Space Complexity. - Unlike DijkstraShortestDistanceTreeFinder , which can improve w.r.t. DijkstraShortestDistanceFinder on the average runtime, while the worst case is still bound to the total number of vertices in the graph, BellmanFordShortestDistanceTreeFinder cannot provide the same average running time improvement over BellmanFordShortestDistanceFinder , since the Bellman-Ford algorithm still requires v - 1 iterations to find optimal distances from the start vertex, and one iteration more, to be able to identify negative cycles and set shortest distance to minus infinity, for all vertices reachable from a negative cycle. COMPLEXITY - Same analysis as in BellmanFordShortestDistanceFinder . - The fact that the algorithm doesn't reconstruct shortest paths doesn't reduce the overall complexity, which is bound to the v iterations of the main loop of the algorithm, each one relaxing at most e edges. - Therefore, as in single path Bellman-Ford's algorithm variant, Time Complexity is O(v * (v * Tn + e)) and Space Complexity is O(v + Sn), where Tn and Sn are the time and space to retrieve the neighborhood of a single vertex. Constructors | Improve this Doc View Source BellmanFordShortestDistanceTreeFinder(Func<IVisitStrategy>) Declaration public BellmanFordShortestDistanceTreeFinder(Func<IVisitStrategy> visitStrategyBuilder) Parameters Type Name Description Func < IVisitStrategy > visitStrategyBuilder Remarks Properties | Improve this Doc View Source VisitStrategyBuilder A building function able to instantiate the IVisitStrategy to be used to find all reachable vertices of vertices relaxed in the last iteration of the main loop of the Bellman-Ford algorithm, by running a Depth First Searches from the start vertex via DepthFirstSearchFromVertex(IGraph, Int32) . Declaration public Func<IVisitStrategy> VisitStrategyBuilder { get; } Property Value Type Description Func < IVisitStrategy > Methods | Improve this Doc View Source FindTree(IGraph, IGraphDistances, Int32) Declaration public BestPreviouses FindTree(IGraph graph, IGraphDistances distances, int start) Parameters Type Name Description IGraph graph IGraphDistances distances System.Int32 start Returns Type Description BestPreviouses Remarks Implements IShortestDistanceTreeFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestDistanceTree.DijkstraShortestDistanceTreeFinder.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistanceTree.DijkstraShortestDistanceTreeFinder.html",
    "title": "Class DijkstraShortestDistanceTreeFinder",
    "keywords": "Class DijkstraShortestDistanceTreeFinder A IShortestDistanceTreeFinder implementation based on the Dijkstra algorithm. Inheritance System.Object DijkstraShortestDistanceTreeFinder Implements IShortestDistanceTreeFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.ShortestDistanceTree Assembly : MoreStructures.dll Syntax public class DijkstraShortestDistanceTreeFinder : IShortestDistanceTreeFinder Remarks REQUIREMENTS - Same as DijkstraShortestDistanceFinder . ALGORITHM - The algorithm closely resembles the one used in DijkstraShortestDistanceFinder , with the following differences. Check that algorithm for further information. - The main loop is only stopped when all vertices have been processed, instead of being stopped as soon as the end vertex is found, and its shortest distance and path calculated. - The path from the start vertex is not reconstructed, since that would need to be done for each of the vertices of the graph, resulting in a worst case O(v^2) Space Complexity. COMPLEXITY - Same analysis as in DijkstraShortestDistanceFinder . - The fact that the algorithm doesn't stop when a specific vertex is found, but goes through all vertices, has an impact on the average performance, but doesn't affect the worst case scenario, since in the worst case the end vertex is the last vertex processed of the graph. - Therefore, as in single path Dijkstra's algorithm variant, Time Complexity is O(e + v * log(v)) with the best available IUpdatablePriorityQueue<T> implementation ( UpdatableFibonacciHeapPriorityQueue<T> ), O((e + v) * log(v)) when using a UpdatableBinaryHeapPriorityQueue<T> and O((e + v) * v) when using the naive implementation of ArrayListPriorityQueue<T> . - Space Complexity is O(v), since all auxiliary structures contain a number of items proportional to v. Constructors | Improve this Doc View Source DijkstraShortestDistanceTreeFinder(Func<IUpdatablePriorityQueue<Int32>>) Declaration public DijkstraShortestDistanceTreeFinder(Func<IUpdatablePriorityQueue<int>> priorityQueueBuilder) Parameters Type Name Description Func < IUpdatablePriorityQueue < System.Int32 >> priorityQueueBuilder A builder of a IUpdatablePriorityQueue<T> of System.Int32 values, used by the algorithm to store edges with priority from the closest to the start, to the farthest. Methods | Improve this Doc View Source FindTree(IGraph, IGraphDistances, Int32) Declaration public BestPreviouses FindTree(IGraph graph, IGraphDistances distances, int start) Parameters Type Name Description IGraph graph IGraphDistances distances System.Int32 start Returns Type Description BestPreviouses Remarks Implements IShortestDistanceTreeFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestDistanceTree.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistanceTree.html",
    "title": "Namespace MoreStructures.Graphs.ShortestDistanceTree",
    "keywords": "Namespace MoreStructures.Graphs.ShortestDistanceTree Classes BellmanFordShortestDistanceTreeFinder A IShortestDistanceFinder implementation based on the Bellman-Ford algorithm. DijkstraShortestDistanceTreeFinder A IShortestDistanceTreeFinder implementation based on the Dijkstra algorithm. Interfaces IShortestDistanceTreeFinder An algorithm that, given a start vertex on a weighted directed graph, finds the shortest distance from the start to any other vertex in the graph, and a path for each vertex of the graph having such a total distance."
  },
  "api/MoreStructures.Graphs.ShortestDistanceTree.IShortestDistanceTreeFinder.html": {
    "href": "api/MoreStructures.Graphs.ShortestDistanceTree.IShortestDistanceTreeFinder.html",
    "title": "Interface IShortestDistanceTreeFinder",
    "keywords": "Interface IShortestDistanceTreeFinder An algorithm that, given a start vertex on a weighted directed graph, finds the shortest distance from the start to any other vertex in the graph, and a path for each vertex of the graph having such a total distance. Namespace : MoreStructures.Graphs.ShortestDistanceTree Assembly : MoreStructures.dll Syntax public interface IShortestDistanceTreeFinder Remarks It differs from IShortestDistanceFinder and its implementation in this class of algorithms finds the shortest distance from all vertices of the graph, whereas IShortestDistanceFinder algorithms find the distance between the provided couple of vertices only. IShortestDistanceFinder implementations can provide the best performance when the shortest distance search is between two fixed points. If shortest distance has to be found from (or to) a given vertex to any other vertex, the class of algorithms implementing IShortestDistanceTreeFinder can provide better performance, since all distances are computed in a single execution of the algorithm. Methods | Improve this Doc View Source FindTree(IGraph, IGraphDistances, Int32) Finds the shortest distance and path in the provided graph from the start vertex to each vertex of the graph , i.e. a path such that the sum of distances of all the edges on the path is non-bigger than the one of any other path from the provided start to the vertex. Declaration BestPreviouses FindTree(IGraph graph, IGraphDistances distances, int start) Parameters Type Name Description IGraph graph The graph to traverse. IGraphDistances distances A map between each edge of graph and its distance. System.Int32 start The id of the vertex, to start traversal from. Returns Type Description BestPreviouses A BestPreviouses instance, wrapping a dictionary, mapping: the id of each vertex v of the graph to the shortest distance S from start , and to the id of the vertex preceeding v on a path from start to v having total distance S. This represents a tree T of v' vertices and v' - 1 edges, where v' is at most v, if graph is connected, and strictly lower, if graph has multiple connected components. The tree T is rooted in start and its edges are weighted by the distance of the edges minimizing the total distance from the root. The distance over a path from the root start to any node of the tree v is the shortest distance from start to v, over a directed path of the graph . Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestPath.BfsBasedShortestPathFinder.html": {
    "href": "api/MoreStructures.Graphs.ShortestPath.BfsBasedShortestPathFinder.html",
    "title": "Class BfsBasedShortestPathFinder",
    "keywords": "Class BfsBasedShortestPathFinder An implementation of IShortestPathFinder which performs a BFS traversal, starting from the start vertex, to find the shortest path to the end vertex. Inheritance System.Object BfsBasedShortestPathFinder Implements IShortestPathFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.ShortestPath Assembly : MoreStructures.dll Syntax public class BfsBasedShortestPathFinder : IShortestPathFinder Remarks ALGORITHM - A IVisitStrategy is instantiated via the VisitStrategyBuilder provided in the constructor. - The IVisitStrategy instance is instrumented, by adding an event handler H to the VisitingVertex . - The event handler H maps each visited vertex to its previous vertex (i.e. the vertex whose visit has trigger the visit of this vertex), as stored in PreviousVertex passed by the VisitingVertex event, into a D. - A Breadth First Search from the start vertex is executed, running BreadthFirstSearchFromVertex(IGraph, Int32) . The result of the visit is consumed (i.e. the visit is done) until either the end vertex is encountered, or when there are no more vertices reachable from the start vertex, which haven't been visited yet. - If the end vertex hasn't been discovered during the visit, it is not reachable. Therefore, a length of path equal to System.Int32.MaxValue and an empty path are returned. - If the end vertex has been reached, the end vertex has been visited and it is contained in D. - D is traversed backwards, from the end to the start vertex, rebuilding the (reversed) path. - Finally, the path is reversed and returned as result. - Its length minus 1 represents the length of the path between start and end vertex. COMPLEXITY - While building the IVisitStrategy instance has a complexity that depends on the user-provided VisitStrategyBuilder , it doesn't generally depends on the size of the graph to be visited, and can be considered O(1) work. - Instrumenting the IVisitStrategy instance and running the handler for every visited vertex are also constant-time operations. - The complexity of the BFS visit depends on the actual IVisitStrategy implementation used. - Rebuilding and reversing the path takes time and space proportional to the length of the path, which in the worst case can be O(v) where v is the number of vertices of the graph. - Therefore, Time Complexity is O(Tbfs + v) and Space Complexity is O(Sbfs + v). - If FullyIterativeHashSetBasedGraphVisit or FullyRecursiveHashSetBasedGraphVisit visits are used, with an IGraph retrieving neighbors in constant time, Time and Space Complexity become O(v + e). Constructors | Improve this Doc View Source BfsBasedShortestPathFinder(Func<IVisitStrategy>) Declaration public BfsBasedShortestPathFinder(Func<IVisitStrategy> visitStrategyBuilder) Parameters Type Name Description Func < IVisitStrategy > visitStrategyBuilder Remarks Properties | Improve this Doc View Source VisitStrategyBuilder A building function able to instantiate the IVisitStrategy to be used to find the shortest path, by running a Breadth First Searches from the start vertex via BreadthFirstSearchFromVertex(IGraph, Int32) . Declaration public Func<IVisitStrategy> VisitStrategyBuilder { get; } Property Value Type Description Func < IVisitStrategy > Methods | Improve this Doc View Source Find(IGraph, Int32, Int32) Declaration public (int, IList<int>) Find(IGraph graph, int start, int end) Parameters Type Name Description IGraph graph System.Int32 start System.Int32 end Returns Type Description System.ValueTuple < System.Int32 , IList < System.Int32 >> Remarks Implements IShortestPathFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.ShortestPath.html": {
    "href": "api/MoreStructures.Graphs.ShortestPath.html",
    "title": "Namespace MoreStructures.Graphs.ShortestPath",
    "keywords": "Namespace MoreStructures.Graphs.ShortestPath Classes BfsBasedShortestPathFinder An implementation of IShortestPathFinder which performs a BFS traversal, starting from the start vertex, to find the shortest path to the end vertex. Interfaces IShortestPathFinder An algorithm to find the shortest path (calculated as the number of edges forming the path) from a start vertex to an end vertex in a directed graph."
  },
  "api/MoreStructures.Graphs.ShortestPath.IShortestPathFinder.html": {
    "href": "api/MoreStructures.Graphs.ShortestPath.IShortestPathFinder.html",
    "title": "Interface IShortestPathFinder",
    "keywords": "Interface IShortestPathFinder An algorithm to find the shortest path (calculated as the number of edges forming the path) from a start vertex to an end vertex in a directed graph. Namespace : MoreStructures.Graphs.ShortestPath Assembly : MoreStructures.dll Syntax public interface IShortestPathFinder Methods | Improve this Doc View Source Find(IGraph, Int32, Int32) Finds the shortest path in the provided graph from the start vertex to the end vertex. Declaration (int, IList<int>) Find(IGraph graph, int start, int end) Parameters Type Name Description IGraph graph The graph to traverse. System.Int32 start The id of the vertex, to start traversal from. System.Int32 end The id of the vertex, to end traversal at. Returns Type Description System.ValueTuple < System.Int32 , IList < System.Int32 >> A couple. The first item of the couple is the shortest distance, as number of edges of the shortest path between start and end . The second item of the couple is the sequence of vertices of the graph , identifying the shortest path. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.Sorting.AnyPathToSinkBasedTopologicalSort.html": {
    "href": "api/MoreStructures.Graphs.Sorting.AnyPathToSinkBasedTopologicalSort.html",
    "title": "Class AnyPathToSinkBasedTopologicalSort",
    "keywords": "Class AnyPathToSinkBasedTopologicalSort An ITopologicalSort implementation which assigns topological order to vertices by identifing a sink vertex at each iteration in a non-deterministic way , picking some start vertex and following some path to a sink. Inheritance System.Object AnyPathToSinkBasedTopologicalSort Implements ITopologicalSort Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.Sorting Assembly : MoreStructures.dll Syntax public class AnyPathToSinkBasedTopologicalSort : ITopologicalSort Remarks ADVANTAGES AND DISADVANTAGES - Compared to DfsOnEachVertexSinkBasedTopologicalSort , it has better runtime (quadratic, rather than cubic, over the number of vertices on the graph). - However, the algorithm picks a vertex and follows a path at random (using the LINQ method on a , which is not sorted and doesn't provide any guarantee about ordering). - Therefore, unlike DfsOnEachVertexSinkBasedTopologicalSort , the topological order produced when multiple results are possible, is not defined. ALGORITHM - The number of vertices v in the DAG is computed via GetNumberOfVertices() . - Then, a set of the integers from 0 to v-1 is instantiated, keeping the remaining vertices not sorted yet, together with an array TS of v integers, to accomodate the topological sort value for each of the vertices. - Then, the main loop of the algorithm is executed, while there are still unsorted vertices. - Any of the sorted vertices v is taken, and a directed path v is followed until a sink vertex s is found. - If, while following a path, a loop is detected (i.e. a vertex is visited again), an exception is thrown. - Otherwise, the found sink can be assigned the highest unassigned sort value (v-1 down to 0), and the loop repeats. - When all vertices have been sorted, TS can be returned as result. COMPLEXITY - Getting the number of vertices is a constant-time operation in most IGraph implementations. - Instantiating the set of unsorted vertices, instantiating the output array, and getting the first available vertex from the set of unsorted vertices are all O(v) operations, both in time and space. - The main loop of the algorithm is executed v times. - Each iteration can potentially explore the entire graph, so a path of O(v) vertices and O(v) edges. - Therefore, Time Complexity is O(v^2) and Space Complexity is O(v). Methods | Improve this Doc View Source Sort(IGraph) Declaration public IList<int> Sort(IGraph dag) Parameters Type Name Description IGraph dag Returns Type Description IList < System.Int32 > Remarks Implements ITopologicalSort Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.Sorting.DfsOnEachVertexSinkBasedTopologicalSort.html": {
    "href": "api/MoreStructures.Graphs.Sorting.DfsOnEachVertexSinkBasedTopologicalSort.html",
    "title": "Class DfsOnEachVertexSinkBasedTopologicalSort",
    "keywords": "Class DfsOnEachVertexSinkBasedTopologicalSort An ITopologicalSort implementation which assigns topological order to vertices by identifing a sink vertex at each iteration in a deterministic way , running DFS on each vertex and selecting the max sink. Inheritance System.Object DfsOnEachVertexSinkBasedTopologicalSort Implements ITopologicalSort Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.Sorting Assembly : MoreStructures.dll Syntax public class DfsOnEachVertexSinkBasedTopologicalSort : ITopologicalSort Remarks ADVANTAGES AND DISADVANTAGES - This is a very naive implementation of ITopologicalSort . - Using DFS on each vertex and building a \"reachability dictionary\" is conceptually simple, but very unefficient, leading to cubic runtime over the number of vertices (compared to the quadratic runtime of AnyPathToSinkBasedTopologicalSort or the linear runtime of an approach based on a single DFS pass of the graph). - However, because all reachable vertices are retrieved, and the max is selected when looking for a sink, the final topological sort returned is easily predictable: when multiple topological sort orders are possible, the one returned is the one which has higher vertex ids at the end of the output array. - The deterministic property is not satisfied by some implementations with better runtime, such as AnyPathToSinkBasedTopologicalSort , which starts graph exploration from \"some\" vertex and follows \"some\" path, to get to a sink. ALGORITHM - First, all reachable vertices, from each vertex of the graph, are identified, running a DepthFirstSearchFromVertex(IGraph, Int32) via the VisitStrategy provided in the constructor. - Reachable vertices from each vertex are stored into a D, mapping the System.Int32 id of the vertex i to an of vertices reachable from i (including i itself). - Then, an array of v integers, named here TS, where v is the number of vertices in the graph, is instantiated, to store the topological sort of the provided DAG. - An of vertices already processed (and removed from D) is also instantiated to an empty set. - Finally the main loop of the algorithm is repeated, until D remains empty. - At each iteration, the sink vertex with the biggest index is found. - The sink is found by looking for vertices from which no other vertices are reachable, other than the vertex itself and possibly the already processed ones (which are \"virtually\" removed from the graph). - If such a sink is not found, it means that the remaining graph contains a cycle, because there is at least a vertex in the graph (otherwise the main loop condition would have been false) and for each vertex i there is a vertex j such that a directed path from i to j, i ~~> j, exists. So an is thrown as topological sort only makes sense for DAGs. - If such a sink is found instead, it is returned as (v - 1 - i)-th item of TS, where i is the 0-based running index of the main loop of the algorithm, incremented by 1 at each iteration. - Notice that not any sink is taken: instead of stopping at the first sink found, the sink with the highest id is returned . This makes the algorithm fully deterministic and ensures full predictability of the result. - Finally the array TS is returned. COMPLEXITY - Getting the number of vertices via GetNumberOfVertices() is a constant-time operation in any classical implementation of IGraph . - Running DFS for each vertex of the graph via DepthFirstSearchFromVertex(IGraph, Int32) is a generally expensive operation, which has a Time and Space Complexity which depends on the specific IVisitStrategy used. - Instantiating the TS array also requires resetting all its v items. - The main loop of the algorithm, executed v times, requires finding the last sink vertex, which is an operation quadratic in complexity. All other operations require constant time and space. - Therefore Time Complexity is O(v * Tdfs + v^3) and Space Complexity is O(v^2 + Sdfs), where Tdfs and Sdfs are Time and Space Complexity of running a DFS from a vertex. - Using FullyIterativeHashSetBasedGraphVisit as VisitStrategy and assuming GetAdjacentVerticesAndEdges(Int32, Boolean) can be computed in constant time, Tdfs and Sdfs becomes linear in v and e. - In this case, Time Complexity becomes O(v * (v + e) + v^3) which can be simplified as O(v^3), since e can be at most O(v^2) (in graphs where every vertex is connected to every other vertex). Constructors | Improve this Doc View Source DfsOnEachVertexSinkBasedTopologicalSort(IVisitStrategy) Declaration public DfsOnEachVertexSinkBasedTopologicalSort(IVisitStrategy visitStrategy) Parameters Type Name Description IVisitStrategy visitStrategy Remarks Properties | Improve this Doc View Source VisitStrategy The visitor to be used to identify sink vertices, by running Depth First Searches on the graph. Declaration public IVisitStrategy VisitStrategy { get; } Property Value Type Description IVisitStrategy Methods | Improve this Doc View Source Sort(IGraph) Declaration public IList<int> Sort(IGraph dag) Parameters Type Name Description IGraph dag Returns Type Description IList < System.Int32 > Remarks Implements ITopologicalSort Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.Sorting.html": {
    "href": "api/MoreStructures.Graphs.Sorting.html",
    "title": "Namespace MoreStructures.Graphs.Sorting",
    "keywords": "Namespace MoreStructures.Graphs.Sorting Classes AnyPathToSinkBasedTopologicalSort An ITopologicalSort implementation which assigns topological order to vertices by identifing a sink vertex at each iteration in a non-deterministic way , picking some start vertex and following some path to a sink. DfsOnEachVertexSinkBasedTopologicalSort An ITopologicalSort implementation which assigns topological order to vertices by identifing a sink vertex at each iteration in a deterministic way , running DFS on each vertex and selecting the max sink. SingleDfsSinkBasedTopologicalSort An ITopologicalSort implementation which assigns topological order to vertices by identifing a sink vertex at each iteration in a deterministic way , by running DFS once on the entire graph and storing the post order. Interfaces ITopologicalSort An algorithm performing a topological sort on the provided IGraph ."
  },
  "api/MoreStructures.Graphs.Sorting.ITopologicalSort.html": {
    "href": "api/MoreStructures.Graphs.Sorting.ITopologicalSort.html",
    "title": "Interface ITopologicalSort",
    "keywords": "Interface ITopologicalSort An algorithm performing a topological sort on the provided IGraph . Namespace : MoreStructures.Graphs.Sorting Assembly : MoreStructures.dll Syntax public interface ITopologicalSort Remarks DEFINITION Given a DAG G(V, E) , where V is the set of vertices of G and E is the set of directed edges of G, the topological sort of G, indicated here as TS, is a of the first non-negative |V| System.Int32 values, such that for all couples (v1, v2) of V^2, if there is a directed path from v1 to v2, then TS[v1] < TS[v2] . The topological sort defines a linear order of the vertices V of the DAG G. The definition only makes sense when G is a DAG (Direct Acyclic Graph), because: - a generic graph may have cycles, which make impossible to define a topological sort for any vertex on the cycle (since such vertex would be at the same time predecessor and successor of any other vertex of the cycle); - an undirected graph doesn't make distinction between the two different traversal directions of an edge, making each edge a cycle of two edges (1 edge if it is a loop). The topological sort is in general not unique, i.e. multiple orders are possible, which satisfy the definition above. Look at the documentation of the Sort(IGraph) method for some examples. Methods | Improve this Doc View Source Sort(IGraph) Performs the topological sort of the provided dag . Declaration IList<int> Sort(IGraph dag) Parameters Type Name Description IGraph dag The IGraph instance representing a DAG (Direct Acyclic Graph). Returns Type Description IList < System.Int32 > A list TS, of the first n non-negative distinct integers, where n is the number of vertices in dag . TS[i] represents the position of the vertex i in the topological sort. Remarks Examples The followin graph: 0 --> 1 <==> 3 | ^ ^ / | | / / | | / / v |/ / 2 <----- is NOT a DAG and doesn't have any valid topological sort. The followin graph: 0 --> 1 --< 3 | / | / | / v / 2 <---- is a DAG and has a single valid topological sort order: new[] { 0, 1, 3, 2 }) . The followin graph: 0 --> 1 --< 3 | | | v 2 is a DAG and has two valid topological sort orders: new[] { 0, 1, 3, 2 }) ; new[] { 0, 2, 1, 3 }) . Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.Sorting.SingleDfsSinkBasedTopologicalSort.html": {
    "href": "api/MoreStructures.Graphs.Sorting.SingleDfsSinkBasedTopologicalSort.html",
    "title": "Class SingleDfsSinkBasedTopologicalSort",
    "keywords": "Class SingleDfsSinkBasedTopologicalSort An ITopologicalSort implementation which assigns topological order to vertices by identifing a sink vertex at each iteration in a deterministic way , by running DFS once on the entire graph and storing the post order. Inheritance System.Object SingleDfsSinkBasedTopologicalSort Implements ITopologicalSort Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.Sorting Assembly : MoreStructures.dll Syntax public class SingleDfsSinkBasedTopologicalSort : ITopologicalSort Remarks ADVANTAGES AND DISADVANTAGES - This implementation is a conceptual improvement over both AnyPathToSinkBasedTopologicalSort and DfsOnEachVertexSinkBasedTopologicalSort . - The optimization is based on the observation that a lot of the DFS traversal, done by DfsOnEachVertexSinkBasedTopologicalSort to populate its \"reachability dictionary\", is shared between many of the vertices connected together, and doesn't need to be repeated every time. - For example, in a simple graph A1 -> A2 -> ... -> An , the DFS on A1 and the DFS on A2 share the path A2 -> ... -> An , the DFS on A1 and A3 share the path A3 -> ... -> An , etc. - While AnyPathToSinkBasedTopologicalSort doesn't explicitely use a DepthFirstSearchFromVertex(IGraph, Int32) , its strategy can be seen as a DFS traversal if the initial vertex and the path followed at each iteration are taken consistently. - Therefore, this implementation is an improvement of both previously mentioned implementations. - Moreover, if the DFS traversal is deterministic, this algorithm also is. ALGORITHM - A full DFS traversal of the entire DAG is performed via DepthFirstSearchOfGraph(IGraph) on a IVisitStrategy built by the VisitStrategyBuilder provided in the constructor. - Before running the DFS traversal, a post-visit event handler is attached to VisitedVertex , running a post-order counter which is incremented at every visit. - The value of the post-order counter is stored in an array TS of v integers, where v is the number of vertices in the graph, at a position defined by the id of the vertex. - Finally, the array TS is returned. COMPLEXITY - Running DFS for the entire graph via DepthFirstSearchFromVertex(IGraph, Int32) is a generally expensive operation, which has a Time and Space Complexity which depends on the specific IVisitStrategy used. - However, unlike in DfsOnEachVertexSinkBasedTopologicalSort , it is performed once, and not for each vertex. - Instantiating the TS array is a O(v) operation, both in time and space. - Storing, updating and assigning the post-order counter to the right item of TS are all constant-time operations. - Therefore Time Complexity is O(Tdfs + v) and Space Complexity is O(Sdfs + v). - Using FullyIterativeHashSetBasedGraphVisit as IVisitStrategy and assuming GetAdjacentVerticesAndEdges(Int32, Boolean) can be computed in constant time, Tdfs and Sdfs becomes linear in v and e. - In this case, Time Complexity becomes O(v + e) and Space Complexity becomes O(v). Constructors | Improve this Doc View Source SingleDfsSinkBasedTopologicalSort(Func<IVisitStrategy>) Declaration public SingleDfsSinkBasedTopologicalSort(Func<IVisitStrategy> visitStrategyBuilder) Parameters Type Name Description Func < IVisitStrategy > visitStrategyBuilder Remarks Properties | Improve this Doc View Source VisitStrategyBuilder A visitor builder, to be used to build the IVisitStrategy instance needed to identify sink vertices, by running a Depth First Search on the graph. Declaration public Func<IVisitStrategy> VisitStrategyBuilder { get; } Property Value Type Description Func < IVisitStrategy > Methods | Improve this Doc View Source Sort(IGraph) Declaration public IList<int> Sort(IGraph dag) Parameters Type Name Description IGraph dag Returns Type Description IList < System.Int32 > Remarks Implements ITopologicalSort Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.StronglyConnectedComponents.html": {
    "href": "api/MoreStructures.Graphs.StronglyConnectedComponents.html",
    "title": "Namespace MoreStructures.Graphs.StronglyConnectedComponents",
    "keywords": "Namespace MoreStructures.Graphs.StronglyConnectedComponents Classes NaiveSccFinder A simple implementation of ISccFinder , which builds a \"reachability dictionary\", by running a DFS on each vertex of the graph separately. SinkSccBasedSccFinder An efficient implementation of ISccFinder , which runs a single DFS on the inverted graph to calculate post orders, and then uses the post orders to identify sink SCC. Interfaces ISccFinder An algorithm finding the Strongly Connected Components (SCC) of a IGraph ."
  },
  "api/MoreStructures.Graphs.StronglyConnectedComponents.ISccFinder.html": {
    "href": "api/MoreStructures.Graphs.StronglyConnectedComponents.ISccFinder.html",
    "title": "Interface ISccFinder",
    "keywords": "Interface ISccFinder An algorithm finding the Strongly Connected Components (SCC) of a IGraph . Namespace : MoreStructures.Graphs.StronglyConnectedComponents Assembly : MoreStructures.dll Syntax public interface ISccFinder Remarks DEFINITION - A Strongly Connected Component (SCC) of a graph G is a set of vertices of G such that, taken any two vertices v1 and v2 of G, there is a directed path from v1 to v2 and a directed path from v2 to v1. - That is, every vertex in a SCC can reach and can be reached by any other vertex of the same SCC, whereas two vertices of two different SCC can be such that one is reachable from the other, but not viceversa. - A SCC is an extension specific to directed graphs of the concept of Connected Component, which instead only requires a path from v1 to v2 for CC[v1] to be the same of CC[v2]. - While in an undirected graph a path from v1 to v2 implies a path from v2 to v1, that's not the case for directed graphs. So bidirectionality is required. Methods | Improve this Doc View Source Find(IGraph) Finds the Strongly Connected Components (SCC) of the provided graph . Declaration IList<int> Find(IGraph graph) Parameters Type Name Description IGraph graph An IGraph instance of any type, with or without loops. Returns Type Description IList < System.Int32 > A list L of as many System.Int32 as the number of vertices in graph . The i-th element of the L represents the label of the SCC, the vertex i is in. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.StronglyConnectedComponents.NaiveSccFinder.html": {
    "href": "api/MoreStructures.Graphs.StronglyConnectedComponents.NaiveSccFinder.html",
    "title": "Class NaiveSccFinder",
    "keywords": "Class NaiveSccFinder A simple implementation of ISccFinder , which builds a \"reachability dictionary\", by running a DFS on each vertex of the graph separately. Inheritance System.Object NaiveSccFinder Implements ISccFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.StronglyConnectedComponents Assembly : MoreStructures.dll Syntax public class NaiveSccFinder : ISccFinder Remarks ADVANTAGES AND DISADVANTAGES - This is the easiest, most straighforward implementation of ISccFinder . - It has, however, a cubic runtime for dense graphs, which is less than ideal. ALGORITHM - First a dictionary R of reachable vertices is built, mapping each of the vertices of the graph to an of vertices reachable from it (including the vertex itself). - The dictionary is populated by running DepthFirstSearchFromVertex(IGraph, Int32) on each vertex, via the VisitStrategy provided in the constructor. - After that, all vertices of the graph are iterated over. - A SCC array, of as many items as the number of vertices in the graph, is initialized. A current SCC counter is set to 0 and an P of already processed vertices is initialized to an empty set. - For each vertex i, all reachable vertices j, except the ones in P, in R[i] are checked. - Vertices j such that R[j] contains i (including i itself, given that i always belongs to R[i]) are all assigned the same SCC. - When a vertex j is assigned a SCC, it is also added to P, so that it is not checked again in following iterations. - After all vertices reachable from i have been checked, the current SCC counter is incremented and the current iteration finishes. - Once all vertices have been processed, the resulting SCC array is returned as result. COMPLEXITY - This algorithm creates a dictionary of reachable vertices, pretty much like DfsOnEachVertexSinkBasedTopologicalSort . - Similar considerations about the complexity of setting up the dictionary apply to this algorithm. - The main nested loops of the algorithm check each couple of a vertex and a reachable vertex from it. - The number of such couples is O(v^2), in graph where vertices are connected to O(v) other vertices. - Checking whether a vertex has already been processed, or whether it is reachable/reached from another vertex are constant-time operations. - Therefore Time Complexity is O(v * Tdfs + v^2) and Space Complexity is O(v^2 + Sdfs), where Tdfs and Sdfs are Time and Space Complexity of running a DFS from a vertex. - Time Complexity is O(v^3) in graphs where every vertex is connected to every other vertex. Constructors | Improve this Doc View Source NaiveSccFinder(IVisitStrategy) Declaration public NaiveSccFinder(IVisitStrategy visitStrategy) Parameters Type Name Description IVisitStrategy visitStrategy Remarks Properties | Improve this Doc View Source VisitStrategy The visitor to be used to find SCC, by running Depth First Searches on each vertex. Declaration public IVisitStrategy VisitStrategy { get; } Property Value Type Description IVisitStrategy Methods | Improve this Doc View Source Find(IGraph) Declaration public IList<int> Find(IGraph graph) Parameters Type Name Description IGraph graph Returns Type Description IList < System.Int32 > Remarks Implements ISccFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.StronglyConnectedComponents.SinkSccBasedSccFinder.html": {
    "href": "api/MoreStructures.Graphs.StronglyConnectedComponents.SinkSccBasedSccFinder.html",
    "title": "Class SinkSccBasedSccFinder",
    "keywords": "Class SinkSccBasedSccFinder An efficient implementation of ISccFinder , which runs a single DFS on the inverted graph to calculate post orders, and then uses the post orders to identify sink SCC. Inheritance System.Object SinkSccBasedSccFinder Implements ISccFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.StronglyConnectedComponents Assembly : MoreStructures.dll Syntax public class SinkSccBasedSccFinder : ISccFinder Remarks ADVANTANGES AND DISADVANTAGES - Compared to the simple approach of NaiveSccFinder , this implementation requires more complex operations, such as reversing the graph, generating and storing post order values. - However, it has better runtime, approaching optimality, since it runs DFS only once, and not for every vertex of the graph. ALGORITHM - The algorithm is based on the observation that the DFS on any vertex of a sink SCC is the sink SCC itself. - So the goal at each iteration is to efficiently find a vertex which belongs to a sink SCC and run DFS on it. - Such a vertex v can be found by running a single DFS on the reverse graph (graph with the same vertices and reversed orientation of edges) and taking the vertex with the highest post order value. - After having identified v, DFS is run on v to find the sink SCC S, v is in. - All found vertices are assigned the same SCC S: a list of v items SCCs is initialized to store the result and SCCs[i] is set to S to indicate the vertex i is in the SCC with label S. - Then the operation is repeated, identifing the vertex v with the highest post order value, among the vertices of the graph which haven't been assigned a SCC yet. - When there are no vertices left, the SCCs list is returned as result. COMPLEXITY - Reverse() performance depends on the specific implementation of the graph. - Building and instrumenting the required IVisitStrategy instances and storing the post order do not depend on the side of the input. - The output has size equal to the number of vertices in the graph. - DFS, which is at the core of this algorithm, is run in two stages. - In the first stage it is executed just once, on the entire graph, calling DepthFirstSearchOfGraph(IGraph) . - In the second stage it is executed iteratively, on vertices not assigned an SCC yet, this time calling DepthFirstSearchFromVertex(IGraph, Int32) . - Because at each iteration chosen vertex belongs to a sink SCC (due to the fact that the vertex with the highest remaining post order is selected), each vertex of the graph is explored at most once thoughout the entire second stage. - Therefore, Time Complexity is O(Trvs + Tdfs) and Space Complexity is O(Srvs + Sdfs), where Trvs and Srvs are the time and space required to reverse the provided IGraph and Tdfs and Sdfs are the time and space required to run DFS via the IVisitStrategy provided by VisitStrategyBuilder . - In typical implementations of IGraph and IVisitStrategy , Tdfs >= Trvs, and Tdfs is O(v + e), which makes Time Complexity equals to O(v * Ta + e). - Space Complexity is generally at least O(v + e + Sa), if Reverse() just builds a proxy of the provided graph, but can be O(v^2) for example if IGraph builds a separated transposed copy of the adjacency matrix when reversing, and v^2 > v + e (very sparse graph). Constructors | Improve this Doc View Source SinkSccBasedSccFinder(Func<IVisitStrategy>) Declaration public SinkSccBasedSccFinder(Func<IVisitStrategy> visitStrategyBuilder) Parameters Type Name Description Func < IVisitStrategy > visitStrategyBuilder Remarks Properties | Improve this Doc View Source VisitStrategyBuilder A building function able to instantiate the IVisitStrategy to be used to run Depth First Searches of the entire graph and from vertex, via DepthFirstSearchOfGraph(IGraph) and DepthFirstSearchFromVertex(IGraph, Int32) respectively. Declaration public Func<IVisitStrategy> VisitStrategyBuilder { get; } Property Value Type Description Func < IVisitStrategy > Methods | Improve this Doc View Source Find(IGraph) Declaration public IList<int> Find(IGraph graph) Parameters Type Name Description IGraph graph Returns Type Description IList < System.Int32 > Remarks Implements ISccFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.Visitor.DirectionableVisit.html": {
    "href": "api/MoreStructures.Graphs.Visitor.DirectionableVisit.html",
    "title": "Class DirectionableVisit",
    "keywords": "Class DirectionableVisit A IVisitStrategy implementation which can perform the visit taking into account or not the direction of the edges of the graph, based on the DirectedGraph property. Inheritance System.Object DirectionableVisit FullyIterativeHashSetBasedGraphVisit FullyRecursiveHashSetBasedGraphVisit Implements IVisitStrategy Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.Visitor Assembly : MoreStructures.dll Syntax public abstract class DirectionableVisit : IVisitStrategy Constructors | Improve this Doc View Source DirectionableVisit(Boolean) Declaration protected DirectionableVisit(bool directedGraph) Parameters Type Name Description System.Boolean directedGraph Properties | Improve this Doc View Source DirectedGraph Whether the provided IGraph should be considered as directed (i.e. edges should be traversed from start to end) or inderected (i.e. edges should be traversed both from start to end and from end to start). Declaration public bool DirectedGraph { get; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source BreadthFirstSearchFromVertex(IGraph, Int32) Runs a partial Breadth First Search of the provided graph , returning the list of vertices which are reachable from the vertex with id vertex , along the edges of the graph, in the order in which they have been explored. Declaration public abstract IEnumerable<int> BreadthFirstSearchFromVertex(IGraph graph, int vertex) Parameters Type Name Description IGraph graph The IGraph instance to be explored. Can be considered directed or undirected, depending on the actual exploration implementation and visit. System.Int32 vertex The System.Int32 id identifying the vertex, from which the exploration has to be started. Different starting points will result into different sequences (by items and/or order) of vertices. Returns Type Description IEnumerable < System.Int32 > The sequence of vertices, lazily generated. Neighbors of the same vertex are visited by ascending id. | Improve this Doc View Source BreadthFirstSearchFromVertices(IGraph, IEnumerable<Int32>) Runs a partial Breadth First Search of the provided graph , returning the list of vertices which are reachable from the provided vertices , along the edges of the graph, in the order in which they have been explored. Declaration public abstract IEnumerable<int> BreadthFirstSearchFromVertices(IGraph graph, IEnumerable<int> vertices) Parameters Type Name Description IGraph graph The IGraph instance to be explored. Can be considered directed or undirected, depending on the actual exploration implementation and visit. IEnumerable < System.Int32 > vertices The sequence of System.Int32 ids identifying the vertices, from which the exploration has to be started. Different starting points will result into different sequences (by items and/or order) of vertices. Returns Type Description IEnumerable < System.Int32 > The sequence of vertices, lazily generated. Neighbors of the same vertex are visited by ascending id. | Improve this Doc View Source ConnectedComponents(IGraph) Explores the provided graph entirely, via a Depth First Search, returning the mapping between the id of each vertex and the label of its connected component. Declaration public virtual IDictionary<int, int> ConnectedComponents(IGraph graph) Parameters Type Name Description IGraph graph The IGraph instance to be explored. Can be considered directed or undirected, depending on the actual exploration implementation and visit. However, connected components usually make sense for undirected graphs only, since a vertex can reach any other vertex of the same connected component only when edges can be traversed in both directions. Returns Type Description IDictionary < System.Int32 , System.Int32 > A dictionary, mapping the id of each vertex of the graph to the label of its connected component, which is a non-negative integer. | Improve this Doc View Source DepthFirstSearchAndConnectedComponentsOfGraph(IGraph) Runs a Depth First Search and returns vertices and related connected components. Declaration protected abstract IEnumerable<(int, int)> DepthFirstSearchAndConnectedComponentsOfGraph(IGraph graph) Parameters Type Name Description IGraph graph The IGraph instance to be explored. Returns Type Description IEnumerable < System.ValueTuple < System.Int32 , System.Int32 >> A sequence of couples of System.Int32 , the first being the vertex id and the second being the label of the connected component, the vertex belongs to. Remarks Generalizes both DepthFirstSearchOfGraph(IGraph) and ConnectedComponents(IGraph) methods, which have very similar implementations. Check those two methods for further information. | Improve this Doc View Source DepthFirstSearchFromVertex(IGraph, Int32) Runs a partial Depth First Search of the the provided graph , returning the list of vertices which are reachable from the vertex with id vertex , along the edges of the graph, in the order in which they have been explored. Declaration public abstract IEnumerable<int> DepthFirstSearchFromVertex(IGraph graph, int vertex) Parameters Type Name Description IGraph graph The IGraph instance to be explored. Can be considered directed or undirected, depending on the actual exploration implementation and visit. System.Int32 vertex The System.Int32 id identifying the vertex, from which the exploration has to be started. Different starting points will result into different sequences (by items and/or order) of vertices. Returns Type Description IEnumerable < System.Int32 > The sequence of vertices, lazily generated. Neighbors of the same vertex are visited by ascending id. | Improve this Doc View Source DepthFirstSearchOfGraph(IGraph) Explores the provided graph entirely, returning its list of vertices in the order in which they have been explored. Declaration public virtual IEnumerable<int> DepthFirstSearchOfGraph(IGraph graph) Parameters Type Name Description IGraph graph The IGraph instance to be explored. Can be considered directed or undirected, depending on the actual exploration implementation and visit. Returns Type Description IEnumerable < System.Int32 > The sequence of vertices, lazily generated. Neighbors of the same vertex are visited by ascending id. | Improve this Doc View Source RaiseAlreadyVisitedVertex(VisitEventArgs) Invoke the AlreadyVisitedVertex event with the provided args . Declaration protected virtual void RaiseAlreadyVisitedVertex(VisitEventArgs args) Parameters Type Name Description VisitEventArgs args The arguments to be provided, when raising the event. | Improve this Doc View Source RaiseVisitedVertex(VisitEventArgs) Invoke the VisitedVertex event with the provided args . Declaration protected virtual void RaiseVisitedVertex(VisitEventArgs args) Parameters Type Name Description VisitEventArgs args The arguments to be provided, when raising the event. | Improve this Doc View Source RaiseVisitingVertex(VisitEventArgs) Invoke the VisitingVertex event with the provided args . Declaration protected virtual void RaiseVisitingVertex(VisitEventArgs args) Parameters Type Name Description VisitEventArgs args The arguments to be provided, when raising the event. Events | Improve this Doc View Source AlreadyVisitedVertex Invoked when a node would be about to be visited, but it has been already visited before, and won't be visited again. Declaration public event EventHandler<VisitEventArgs> AlreadyVisitedVertex Event Type Type Description EventHandler < VisitEventArgs > Remarks The event may happen multiple times per vertex per graph visit and can signal the presence of one or more cycles (if the connected component across visits is the same). Unlike VisitingVertex and VisitedVertex , the event may also not happen at all, for example in trees. It surely is raised at least once in graphs with cycles. However, cycles are not required for this event to happen: for example, a vertex is encountered multiple times in DAGs. / Check VisitEventArgs for the contextual information carried by the event (such as its connected component and previous vertex). | Improve this Doc View Source VisitedVertex Invoked just after a node has been visited, by DepthFirstSearchOfGraph(IGraph) , ConnectedComponents(IGraph) , DepthFirstSearchFromVertex(IGraph, Int32) or any other method exploring vertices of the graph. Declaration public event EventHandler<VisitEventArgs> VisitedVertex Event Type Type Description EventHandler < VisitEventArgs > Remarks The event happens at most once per vertex per graph visit. / Check VisitEventArgs for the contextual information carried by the event. | Improve this Doc View Source VisitingVertex Invoked when a node is about to be visited, by DepthFirstSearchOfGraph(IGraph) , ConnectedComponents(IGraph) , DepthFirstSearchFromVertex(IGraph, Int32) or any other method exploring vertices of the graph. Declaration public event EventHandler<VisitEventArgs> VisitingVertex Event Type Type Description EventHandler < VisitEventArgs > Remarks The event happens at most once per vertex per graph visit. / Check VisitEventArgs for the contextual information carried by the event. Implements IVisitStrategy Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.Visitor.FullyIterativeHashSetBasedGraphVisit.html": {
    "href": "api/MoreStructures.Graphs.Visitor.FullyIterativeHashSetBasedGraphVisit.html",
    "title": "Class FullyIterativeHashSetBasedGraphVisit",
    "keywords": "Class FullyIterativeHashSetBasedGraphVisit A IVisitStrategy implementation which uses an of System.Int32 to store already visited vertices, while visiting the graph, and performs the visit iteratively, using a XStack<T> . Inheritance System.Object DirectionableVisit FullyIterativeHashSetBasedGraphVisit Implements IVisitStrategy Inherited Members DirectionableVisit.DirectedGraph DirectionableVisit.VisitingVertex DirectionableVisit.RaiseVisitingVertex(VisitEventArgs) DirectionableVisit.VisitedVertex DirectionableVisit.RaiseVisitedVertex(VisitEventArgs) DirectionableVisit.AlreadyVisitedVertex DirectionableVisit.RaiseAlreadyVisitedVertex(VisitEventArgs) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.Visitor Assembly : MoreStructures.dll Syntax public class FullyIterativeHashSetBasedGraphVisit : DirectionableVisit, IVisitStrategy Constructors | Improve this Doc View Source FullyIterativeHashSetBasedGraphVisit(Boolean) Declaration public FullyIterativeHashSetBasedGraphVisit(bool directedGraph) Parameters Type Name Description System.Boolean directedGraph Methods | Improve this Doc View Source BreadthFirstSearchFromVertex(IGraph, Int32) Declaration public override IEnumerable<int> BreadthFirstSearchFromVertex(IGraph graph, int vertex) Parameters Type Name Description IGraph graph System.Int32 vertex Returns Type Description IEnumerable < System.Int32 > Overrides DirectionableVisit.BreadthFirstSearchFromVertex(IGraph, Int32) Remarks ADVANTAGES AND DISADVANTAGES ALGORITHM - The algorithm closely resembles DepthFirstSearchFromVertex(IGraph, Int32) , the only difference being that a XQueue<T> is used, and not a XStack<T> , to visit by breadth, and not by depth. COMPLEXITY - Same consideration about complexity as in DepthFirstSearchFromVertex(IGraph, Int32) apply. What is different is just the order of visit, not edges or vertices visited. - Therefore, Time Complexity is O(v * Ta + e) and Space Complexity is O(v + e + Sa), where v is the number of vertices, e is the number of edges and Ta and Sa are the time and space cost of retrieving the neighborhood of a given vertex. | Improve this Doc View Source BreadthFirstSearchFromVertices(IGraph, IEnumerable<Int32>) Declaration public override IEnumerable<int> BreadthFirstSearchFromVertices(IGraph graph, IEnumerable<int> vertices) Parameters Type Name Description IGraph graph IEnumerable < System.Int32 > vertices Returns Type Description IEnumerable < System.Int32 > Overrides DirectionableVisit.BreadthFirstSearchFromVertices(IGraph, IEnumerable<Int32>) Remarks The algorithm is very similar to BreadthFirstSearchFromVertex(IGraph, Int32) , with the only difference that all vertices in the vertices sequence are pushed to the queue, instead of a single one. Because the vertices may or may not belong to different connected components, this algorithm returns \"-1\" as connected component for all visited vertices. Time Complexity is O(v * Ta + e) and Space Complexity is O(v + e + Sa), exactly as for BreadthFirstSearchFromVertex(IGraph, Int32) , since in the worst case the entire graph has to be explored. | Improve this Doc View Source ConnectedComponents(IGraph) Declaration public override IDictionary<int, int> ConnectedComponents(IGraph graph) Parameters Type Name Description IGraph graph Returns Type Description IDictionary < System.Int32 , System.Int32 > Overrides DirectionableVisit.ConnectedComponents(IGraph) Remarks ADVANTAGES AND DISADVANTAGES ALGORITHM - The algorithm is a simple variation of DepthFirstSearchOfGraph(IGraph) , with the differences explained in ConnectedComponents(IGraph) . COMPLEXITY - The analysis of complexity is done in ConnectedComponents(IGraph) . - Time Complexity is O(v * Ta + e) and Space Complexity is O(v + e + Sa), where v is the number of vertices, e is the number of edges and Ta and Sa are the time and space cost of retrieving the neighborhood of a given vertex. /// | Improve this Doc View Source DepthFirstSearchAndConnectedComponentsOfGraph(IGraph) Runs a Depth First Search and returns vertices and related connected components. Declaration protected override IEnumerable<(int, int)> DepthFirstSearchAndConnectedComponentsOfGraph(IGraph graph) Parameters Type Name Description IGraph graph The IGraph instance to be explored. Returns Type Description IEnumerable < System.ValueTuple < System.Int32 , System.Int32 >> A sequence of couples of System.Int32 , the first being the vertex id and the second being the label of the connected component, the vertex belongs to. Overrides DirectionableVisit.DepthFirstSearchAndConnectedComponentsOfGraph(IGraph) Remarks Generalizes both DepthFirstSearchOfGraph(IGraph) and ConnectedComponents(IGraph) methods, which have very similar implementations. Check those two methods for further information. | Improve this Doc View Source DepthFirstSearchFromVertex(IGraph, Int32) Declaration public override IEnumerable<int> DepthFirstSearchFromVertex(IGraph graph, int vertex) Parameters Type Name Description IGraph graph System.Int32 vertex Returns Type Description IEnumerable < System.Int32 > Overrides DirectionableVisit.DepthFirstSearchFromVertex(IGraph, Int32) Remarks ADVANTAGES AND DISADVANTAGES ALGORITHM - The algorithm closely resembles to DepthFirstSearchFromVertex(IGraph, Int32) , the only difference being that the state of the visit is stored into a XStack<T> , instantiated in the heap, rather than in the call stack. - A XStack<T> is used, and not a XQueue<T> , to preserve the order of visit by depth, and not by breadth. COMPLEXITY - As for DepthFirstSearchFromVertex(IGraph, Int32) , Time Complexity is O(v * Ta + e) and Space Complexity is O(v + e + Sa), where v is the number of vertices, e is the number of edges and Ta and Sa are the time and space cost of retrieving the neighborhood of a given vertex. | Improve this Doc View Source DepthFirstSearchOfGraph(IGraph) Declaration public override IEnumerable<int> DepthFirstSearchOfGraph(IGraph graph) Parameters Type Name Description IGraph graph Returns Type Description IEnumerable < System.Int32 > Overrides DirectionableVisit.DepthFirstSearchOfGraph(IGraph) Remarks ADVANTAGES AND DISADVANTAGES ALGORITHM - The total number of vertices of the graph is found via GetNumberOfVertices() . - If such number is v, vertices are identified by integers from 0 to v - 1. - Iterate over all vertices, visiting all other vertices reachable from the current vertex i, in the same way visit is performed by DepthFirstSearchFromVertex(IGraph, Int32) . - All visits share the same of visited vertices, so that, if a vertex has been visited before, directly or via another vertex, it's not visited again. - Every time a new vertex is visited, such vertex is yielded into the output sequence. COMPLEXITY - The complexity of retrieving the total number of vertices depends on GetNumberOfVertices() . While being specific to the IGraph implementation being used, all implementation provide O(1) runtime for such operation. - The shared across all visits ensures that each vertex is visited at most once. - Because each vertex is visited at most once throughout the entire execution, edges are visited at most once, when edge direction is taken into account during the visit, and twice, when it is not. - Thoughout the entire execution, a single vertex in the stack is processed at a time, while the stack can grow to contain up to e (directed edges) or 2 * e items (undirected edges). - Therefore, Time Complexity is O(v * Ta + e) and Space Complexity is O(v + e + Sa), where v is the number of vertices, e is the number of edges and Ta and Sa are the time and space cost of retrieving the neighborhood of a given vertex. Implements IVisitStrategy Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.Visitor.FullyRecursiveHashSetBasedGraphVisit.html": {
    "href": "api/MoreStructures.Graphs.Visitor.FullyRecursiveHashSetBasedGraphVisit.html",
    "title": "Class FullyRecursiveHashSetBasedGraphVisit",
    "keywords": "Class FullyRecursiveHashSetBasedGraphVisit A IVisitStrategy implementation which uses an of System.Int32 to store already visited vertices, while visiting the graph, and performs the visit recursively. Inheritance System.Object DirectionableVisit FullyRecursiveHashSetBasedGraphVisit Implements IVisitStrategy Inherited Members DirectionableVisit.DirectedGraph DirectionableVisit.VisitingVertex DirectionableVisit.RaiseVisitingVertex(VisitEventArgs) DirectionableVisit.VisitedVertex DirectionableVisit.RaiseVisitedVertex(VisitEventArgs) DirectionableVisit.AlreadyVisitedVertex DirectionableVisit.RaiseAlreadyVisitedVertex(VisitEventArgs) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.Visitor Assembly : MoreStructures.dll Syntax public class FullyRecursiveHashSetBasedGraphVisit : DirectionableVisit, IVisitStrategy Constructors | Improve this Doc View Source FullyRecursiveHashSetBasedGraphVisit(Boolean) Declaration public FullyRecursiveHashSetBasedGraphVisit(bool directedGraph) Parameters Type Name Description System.Boolean directedGraph Methods | Improve this Doc View Source BreadthFirstSearchFromVertex(IGraph, Int32) Declaration public override IEnumerable<int> BreadthFirstSearchFromVertex(IGraph graph, int vertex) Parameters Type Name Description IGraph graph System.Int32 vertex Returns Type Description IEnumerable < System.Int32 > Overrides DirectionableVisit.BreadthFirstSearchFromVertex(IGraph, Int32) Remarks ADVANTAGES AND DISADVANTAGES Implemented fully recursively, so limited by stack depth and usable with graphs of a \"reasonable\" size. ALGORITHM - The algorithm closely resembles DepthFirstSearchFromVertex(IGraph, Int32) with one foundamental difference: the recursive calls to neighbors of each vertex generate which are iterated lazily and in parallel, one element of each at a time , up until all enumerators are done. - Let's take as an example a graph in which neighbors of vertex 0 are 1 and 2, neighbors of vertex 1 are 3 and 4 and neighbors of vertex 2 are 5 and 4. - The visit of vertex 0 will first yield the vertex 0 itself. - It then yields the 1st element of the enumerable of BFS from vertex 1, which is the vertex 1 itself. - After that, it yields the 1st element of the enumerable of BFS from vertex 2, which is the vertex 2 itself. - After that, since there are no other neighbors of 0, moves to the 2nd elements of each of the enumerators. - It yields the 2nd element of the enumerable of BFS from vertex 1, which is the vertex 3. - It then yields the 2nd element of the enumerable of BFS from vertex 2, which is the vertex 5. - Etc, until all enumerators are done (i.e. System.Collections.IEnumerator.MoveNext is false . COMPLEXITY - Same consideration about complexity as in DepthFirstSearchFromVertex(IGraph, Int32) apply. What is different is just the order of visit, not edges or vertices visited. - Therefore, Time Complexity is O(v * Ta + e) and Space Complexity is O(v * Sa + e), where v is the number of vertices, e is the number of edges and Ta and Sa are the time and space cost of retrieving the neighborhood of a given vertex. | Improve this Doc View Source BreadthFirstSearchFromVertices(IGraph, IEnumerable<Int32>) Declaration public override IEnumerable<int> BreadthFirstSearchFromVertices(IGraph graph, IEnumerable<int> vertices) Parameters Type Name Description IGraph graph IEnumerable < System.Int32 > vertices Returns Type Description IEnumerable < System.Int32 > Overrides DirectionableVisit.BreadthFirstSearchFromVertices(IGraph, IEnumerable<Int32>) Remarks The algorithm is very similar to BreadthFirstSearchFromVertex(IGraph, Int32) , with the only difference that all vertices in the vertices sequence are visited, in parallel, instead of a single one. Because the vertices may or may not belong to different connected components, this algorithm returns \"-1\" as connected component for all visited vertices. Time Complexity is O(v * Ta + e) and Space Complexity is O(v + e + Sa), exactly as for BreadthFirstSearchFromVertex(IGraph, Int32) , since in the worst case the entire graph has to be explored. | Improve this Doc View Source ConnectedComponents(IGraph) Declaration public override IDictionary<int, int> ConnectedComponents(IGraph graph) Parameters Type Name Description IGraph graph Returns Type Description IDictionary < System.Int32 , System.Int32 > Overrides DirectionableVisit.ConnectedComponents(IGraph) Remarks ADVANTAGES AND DISADVANTAGES Implemented fully recursively, so limited by stack depth and usable with graphs of a \"reasonable\" size. ALGORITHM - The algorithm is a simple variation of DepthFirstSearchOfGraph(IGraph) . - All vertices from 0 to GetNumberOfVertices() - 1 are explored. - An of already visited vertices is shared across all visits, to ensure that a vertex is not visited twice. - A current value of the connected component is instantiated at 0 and incremented every time a new connected component is explored, i.e. every time the vertex i, of the top-level iteration, has not been visited yet, meaning that none of the connected components explored so far contains it. - The resulting mapping between vertex id and connected component value is returned as result. COMPLEXITY - The algorithm closely resembles DepthFirstSearchOfGraph(IGraph) , with the added complexity of instantiating and populating a of the mapping between vertices and connected component labels. - Because the implementation used is a , which is hash-based, such additional operations are performed in constant time. - Therefore the complexity of this method is the same as DepthFirstSearchOfGraph(IGraph) : Time Complexity is O(v * Ta + e) and Space Complexity is O(v * Sa + e), where v is the number of vertices, e is the number of edges and Ta and Sa are the time and space cost of retrieving the neighborhood of a given vertex. | Improve this Doc View Source DepthFirstSearchAndConnectedComponentsOfGraph(IGraph) Runs a Depth First Search and returns vertices and related connected components. Declaration protected override IEnumerable<(int, int)> DepthFirstSearchAndConnectedComponentsOfGraph(IGraph graph) Parameters Type Name Description IGraph graph The IGraph instance to be explored. Returns Type Description IEnumerable < System.ValueTuple < System.Int32 , System.Int32 >> A sequence of couples of System.Int32 , the first being the vertex id and the second being the label of the connected component, the vertex belongs to. Overrides DirectionableVisit.DepthFirstSearchAndConnectedComponentsOfGraph(IGraph) Remarks Generalizes both DepthFirstSearchOfGraph(IGraph) and ConnectedComponents(IGraph) methods, which have very similar implementations. Check those two methods for further information. | Improve this Doc View Source DepthFirstSearchFromVertex(IGraph, Int32) Declaration public override IEnumerable<int> DepthFirstSearchFromVertex(IGraph graph, int vertex) Parameters Type Name Description IGraph graph System.Int32 vertex Returns Type Description IEnumerable < System.Int32 > Overrides DirectionableVisit.DepthFirstSearchFromVertex(IGraph, Int32) Remarks ADVANTAGES AND DISADVANTAGES Implemented fully recursively, so limited by stack depth and usable with graphs of a \"reasonable\" size. ALGORITHM - A of the ids of already visited vertices is instantiated to an empty set. - The set of already visited vertices is updated, adding the visited vertex, every time a visit is made. - The visit starts from the specified start vertex and looks for all the neighboring edges of such vertex (taking into account the direction of the edge or not, depending on the specified parameters). - Only neighboring edges connecting the start vertex to a vertex not already visited are taken into account. - However, to reach all relevant vertices, the algorithm may go through all edges of the graph. - All other vertices are skipped, since those vertices, their neighborhood, neighbors of their neighborhood etc. have already been visited in previous steps of the recursive visit. - When the recursive visit terminates, all vertices directly or indirectly connected to the start vertex S (i.e. all vertices V for which there is a path of edges e1, e2, ..., en, connecting S to V) will have been visited. - Vertices which are not connected to S (i.e. for which there is no path), are not included in the resulting sequence of vertices. COMPLEXITY - Instantiating and adding items to the set of already visited vertices are constant-time operations. - The set of already visited vertices ensures that each vertex of the graph is visited at most once. - The complexity of retrieving the neighborhood of a vertex depends on the implementation of GetAdjacentVerticesAndEdges(Int32, Boolean) , thus on the specific IGraph implementation being used. - Checking whether a neighbor has already been visited is a O(1) operation, because the set used is an . - Therefore, Time Complexity is O(v * Ta + e) and Space Complexity is O(v * Sa + e), where v is the number of vertices, e is the number of edges and Ta and Sa are the time and space cost of retrieving the neighborhood of a given vertex. | Improve this Doc View Source DepthFirstSearchOfGraph(IGraph) Declaration public override IEnumerable<int> DepthFirstSearchOfGraph(IGraph graph) Parameters Type Name Description IGraph graph Returns Type Description IEnumerable < System.Int32 > Overrides DirectionableVisit.DepthFirstSearchOfGraph(IGraph) Remarks ADVANTAGES AND DISADVANTAGES Implemented fully recursively, so limited by stack depth and usable with graphs of a \"reasonable\" size. ALGORITHM - An of the ids of already visited vertices is instantiated to an empty set. - Vertices are iterated over, from the first (id = 0), to the last (id = v - 1, where v is the total number of vertices). - The total number of vertices is retrieved via GetNumberOfVertices() . - If the vertex i has not already been visited (i.e. it appears in the ), it is visited, with the same algorithm it would be visited by DepthFirstSearchFromVertex(IGraph, Int32) . - The order of visit is returned as a sequence of integers. - The set of already visited vertices is updated, adding the visited vertex, every time a visit is made, and it is shared by all visits of all vertices, whether they are connected to each other or not. - When the sequence of recursive visits terminates, all vertices of the graph will have been visited. COMPLEXITY - Instantiating and adding items to the set of already visited vertices are constant-time operations. - The set of already visited vertices ensures that each vertex of the graph is visited at most once. - To reach all vertices, the algorithm goes through all edges of the graph. - Because each vertex is visited at most once throughout the entire execution, edges are visited at most once, when edge direction is taken into account during the visit, and twice, when it is not. - The complexity of retrieving the total number of vertices depends on GetNumberOfVertices() . While being specific to the IGraph implementation being used, all implementation provide O(1) runtime for such operation. - Checking whether a neighbor has already been visited is a O(1) operation, because the set used is an . - Therefore, Time Complexity is O(v * Ta + e) and Space Complexity is O(v * Sa + e), where v is the number of vertices, e is the number of edges and Ta and Sa are the time and space cost of retrieving the neighborhood of a given vertex. COMPLEXITY AND EVENTS - Event handlers are externally defined and have been considered O(1) in this analysis. - To include them in the analysis, it should be taken into account that VisitingVertex and VisitedVertex happen once per visited vertex, whereas AlreadyVisitedVertex can happen globally as many times as the number of edges. Implements IVisitStrategy Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.Visitor.html": {
    "href": "api/MoreStructures.Graphs.Visitor.html",
    "title": "Namespace MoreStructures.Graphs.Visitor",
    "keywords": "Namespace MoreStructures.Graphs.Visitor Classes DirectionableVisit A IVisitStrategy implementation which can perform the visit taking into account or not the direction of the edges of the graph, based on the DirectedGraph property. FullyIterativeHashSetBasedGraphVisit A IVisitStrategy implementation which uses an of System.Int32 to store already visited vertices, while visiting the graph, and performs the visit iteratively, using a XStack<T> . FullyRecursiveHashSetBasedGraphVisit A IVisitStrategy implementation which uses an of System.Int32 to store already visited vertices, while visiting the graph, and performs the visit recursively. VisitEventArgs An object carrying information about the visit of a vertex of a graph being visited by a . Interfaces IVisitStrategy An algorithm exploring IGraph instances."
  },
  "api/MoreStructures.Graphs.Visitor.IVisitStrategy.html": {
    "href": "api/MoreStructures.Graphs.Visitor.IVisitStrategy.html",
    "title": "Interface IVisitStrategy",
    "keywords": "Interface IVisitStrategy An algorithm exploring IGraph instances. Namespace : MoreStructures.Graphs.Visitor Assembly : MoreStructures.dll Syntax public interface IVisitStrategy Methods | Improve this Doc View Source BreadthFirstSearchFromVertex(IGraph, Int32) Runs a partial Breadth First Search of the provided graph , returning the list of vertices which are reachable from the vertex with id vertex , along the edges of the graph, in the order in which they have been explored. Declaration IEnumerable<int> BreadthFirstSearchFromVertex(IGraph graph, int vertex) Parameters Type Name Description IGraph graph The IGraph instance to be explored. Can be considered directed or undirected, depending on the actual exploration implementation and visit. System.Int32 vertex The System.Int32 id identifying the vertex, from which the exploration has to be started. Different starting points will result into different sequences (by items and/or order) of vertices. Returns Type Description IEnumerable < System.Int32 > The sequence of vertices, lazily generated. Neighbors of the same vertex are visited by ascending id. | Improve this Doc View Source BreadthFirstSearchFromVertices(IGraph, IEnumerable<Int32>) Runs a partial Breadth First Search of the provided graph , returning the list of vertices which are reachable from the provided vertices , along the edges of the graph, in the order in which they have been explored. Declaration IEnumerable<int> BreadthFirstSearchFromVertices(IGraph graph, IEnumerable<int> vertices) Parameters Type Name Description IGraph graph The IGraph instance to be explored. Can be considered directed or undirected, depending on the actual exploration implementation and visit. IEnumerable < System.Int32 > vertices The sequence of System.Int32 ids identifying the vertices, from which the exploration has to be started. Different starting points will result into different sequences (by items and/or order) of vertices. Returns Type Description IEnumerable < System.Int32 > The sequence of vertices, lazily generated. Neighbors of the same vertex are visited by ascending id. | Improve this Doc View Source ConnectedComponents(IGraph) Explores the provided graph entirely, via a Depth First Search, returning the mapping between the id of each vertex and the label of its connected component. Declaration IDictionary<int, int> ConnectedComponents(IGraph graph) Parameters Type Name Description IGraph graph The IGraph instance to be explored. Can be considered directed or undirected, depending on the actual exploration implementation and visit. However, connected components usually make sense for undirected graphs only, since a vertex can reach any other vertex of the same connected component only when edges can be traversed in both directions. Returns Type Description IDictionary < System.Int32 , System.Int32 > A dictionary, mapping the id of each vertex of the graph to the label of its connected component, which is a non-negative integer. | Improve this Doc View Source DepthFirstSearchFromVertex(IGraph, Int32) Runs a partial Depth First Search of the the provided graph , returning the list of vertices which are reachable from the vertex with id vertex , along the edges of the graph, in the order in which they have been explored. Declaration IEnumerable<int> DepthFirstSearchFromVertex(IGraph graph, int vertex) Parameters Type Name Description IGraph graph The IGraph instance to be explored. Can be considered directed or undirected, depending on the actual exploration implementation and visit. System.Int32 vertex The System.Int32 id identifying the vertex, from which the exploration has to be started. Different starting points will result into different sequences (by items and/or order) of vertices. Returns Type Description IEnumerable < System.Int32 > The sequence of vertices, lazily generated. Neighbors of the same vertex are visited by ascending id. | Improve this Doc View Source DepthFirstSearchOfGraph(IGraph) Explores the provided graph entirely, returning its list of vertices in the order in which they have been explored. Declaration IEnumerable<int> DepthFirstSearchOfGraph(IGraph graph) Parameters Type Name Description IGraph graph The IGraph instance to be explored. Can be considered directed or undirected, depending on the actual exploration implementation and visit. Returns Type Description IEnumerable < System.Int32 > The sequence of vertices, lazily generated. Neighbors of the same vertex are visited by ascending id. Events | Improve this Doc View Source AlreadyVisitedVertex Invoked when a node would be about to be visited, but it has been already visited before, and won't be visited again. Declaration event EventHandler<VisitEventArgs> AlreadyVisitedVertex Event Type Type Description EventHandler < VisitEventArgs > Remarks The event may happen multiple times per vertex per graph visit and can signal the presence of one or more cycles (if the connected component across visits is the same). Unlike VisitingVertex and VisitedVertex , the event may also not happen at all, for example in trees. It surely is raised at least once in graphs with cycles. However, cycles are not required for this event to happen: for example, a vertex is encountered multiple times in DAGs. / Check VisitEventArgs for the contextual information carried by the event (such as its connected component and previous vertex). | Improve this Doc View Source VisitedVertex Invoked just after a node has been visited, by DepthFirstSearchOfGraph(IGraph) , ConnectedComponents(IGraph) , DepthFirstSearchFromVertex(IGraph, Int32) or any other method exploring vertices of the graph. Declaration event EventHandler<VisitEventArgs> VisitedVertex Event Type Type Description EventHandler < VisitEventArgs > Remarks The event happens at most once per vertex per graph visit. / Check VisitEventArgs for the contextual information carried by the event. | Improve this Doc View Source VisitingVertex Invoked when a node is about to be visited, by DepthFirstSearchOfGraph(IGraph) , ConnectedComponents(IGraph) , DepthFirstSearchFromVertex(IGraph, Int32) or any other method exploring vertices of the graph. Declaration event EventHandler<VisitEventArgs> VisitingVertex Event Type Type Description EventHandler < VisitEventArgs > Remarks The event happens at most once per vertex per graph visit. / Check VisitEventArgs for the contextual information carried by the event. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Graphs.Visitor.VisitEventArgs.html": {
    "href": "api/MoreStructures.Graphs.Visitor.VisitEventArgs.html",
    "title": "Class VisitEventArgs",
    "keywords": "Class VisitEventArgs An object carrying information about the visit of a vertex of a graph being visited by a . Inheritance System.Object VisitEventArgs Implements System.IEquatable < VisitEventArgs > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Graphs.Visitor Assembly : MoreStructures.dll Syntax public class VisitEventArgs : IEquatable<VisitEventArgs> Constructors | Improve this Doc View Source VisitEventArgs(Int32, Int32, Nullable<Int32>) An object carrying information about the visit of a vertex of a graph being visited by a . Declaration public VisitEventArgs(int Vertex, int ConnectedComponent, int? PreviousVertex) Parameters Type Name Description System.Int32 Vertex The vertex being visited. System.Int32 ConnectedComponent The label of the connected component, Vertex is in. System.Nullable < System.Int32 > PreviousVertex The vertex whose visit led to the visit of Vertex . Properties | Improve this Doc View Source ConnectedComponent Declaration public int ConnectedComponent { get; set; } Property Value Type Description System.Int32 | Improve this Doc View Source PreviousVertex Declaration public int? PreviousVertex { get; set; } Property Value Type Description System.Nullable < System.Int32 > | Improve this Doc View Source Vertex Declaration public int Vertex { get; set; } Property Value Type Description System.Int32 Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.html": {
    "href": "api/MoreStructures.html",
    "title": "Namespace MoreStructures",
    "keywords": "Namespace MoreStructures Classes RotatedTextWithTerminator A text string with a terminator character which has been rotated leftwards or rightwards, of a number of positions (0 included). TextWithTerminator A text string with a terminator character, not present in the text. TextWithTerminatorExtensions Extension methods for TextWithTerminator . VirtuallyRotatedTextWithTerminator A text string with a terminator character which has been rotated leftwards or rightwards, of a number of positions (0 included). Interfaces TextWithTerminator.ISelector A selector of a part of a TextWithTerminator or RotatedTextWithTerminator ."
  },
  "api/MoreStructures.KnuthMorrisPratt.Borders.html": {
    "href": "api/MoreStructures.KnuthMorrisPratt.Borders.html",
    "title": "Namespace MoreStructures.KnuthMorrisPratt.Borders",
    "keywords": "Namespace MoreStructures.KnuthMorrisPratt.Borders Classes NaiveBordersExtraction An implementation of IBordersExtraction which checks every prefix of the text. PrefixFunctionBasedBorderExtraction An implementation of IBordersExtraction which first calculate the prefix function of the text, and then uses it to calculate the borders efficiently. Interfaces IBordersExtraction An algorithm extracting borders from the given text."
  },
  "api/MoreStructures.KnuthMorrisPratt.Borders.IBordersExtraction.html": {
    "href": "api/MoreStructures.KnuthMorrisPratt.Borders.IBordersExtraction.html",
    "title": "Interface IBordersExtraction",
    "keywords": "Interface IBordersExtraction An algorithm extracting borders from the given text. Namespace : MoreStructures.KnuthMorrisPratt.Borders Assembly : MoreStructures.dll Syntax public interface IBordersExtraction Remarks DEFINITION A border of a text T of a prefix of T which is also a suffix of T, T excluded. For example, the borders of T = \"abcabeabcab\" are \"a\" , \"ab\" and \"abcab\" . Methods | Improve this Doc View Source GetAllBordersByDescLength(String) Retrieves all borders from the provided text, by decreasing length. Declaration IEnumerable<string> GetAllBordersByDescLength(string text) Parameters Type Name Description System.String text The text, to extract borders from. Returns Type Description IEnumerable < System.String > An enumerable of strings. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.KnuthMorrisPratt.Borders.NaiveBordersExtraction.html": {
    "href": "api/MoreStructures.KnuthMorrisPratt.Borders.NaiveBordersExtraction.html",
    "title": "Class NaiveBordersExtraction",
    "keywords": "Class NaiveBordersExtraction An implementation of IBordersExtraction which checks every prefix of the text. Inheritance System.Object NaiveBordersExtraction Implements IBordersExtraction Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.KnuthMorrisPratt.Borders Assembly : MoreStructures.dll Syntax public class NaiveBordersExtraction : IBordersExtraction Remarks ALGORITHM - The algorithm checks all the prefixes of the text, which are not the text itself, by decreasing length. - For each prefix, it checks whether the prefix is also a suffix of the text. - If so, returns it. - An empty string has no prefixes shorter than the text, so an empty sequence is returned. COMPLEXITY - A text T of length n has n - 1 prefixes which are strictly shorter than T. - Each of the prefix has a length O(n). - Checking whether a prefix of T of length w is also a suffix of T requires comparing all w chars. - Therefore, Time Complexity is O(n^2) and Space Complexity is O(1). Methods | Improve this Doc View Source GetAllBordersByDescLength(String) Declaration public IEnumerable<string> GetAllBordersByDescLength(string text) Parameters Type Name Description System.String text Returns Type Description IEnumerable < System.String > Remarks Implements IBordersExtraction Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.KnuthMorrisPratt.Borders.PrefixFunctionBasedBorderExtraction.html": {
    "href": "api/MoreStructures.KnuthMorrisPratt.Borders.PrefixFunctionBasedBorderExtraction.html",
    "title": "Class PrefixFunctionBasedBorderExtraction",
    "keywords": "Class PrefixFunctionBasedBorderExtraction An implementation of IBordersExtraction which first calculate the prefix function of the text, and then uses it to calculate the borders efficiently. Inheritance System.Object PrefixFunctionBasedBorderExtraction Implements IBordersExtraction Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.KnuthMorrisPratt.Borders Assembly : MoreStructures.dll Syntax public class PrefixFunctionBasedBorderExtraction : IBordersExtraction Remarks ALGORITHM - The algorithm takes advantage of the following property of borders: any non-longest border of the text is a also a border of the longest border of the text. - That is, if T[0..w] is a border of T of length w, and T has longest border T[0..lb] of length lb, where 0 < w < lb, then T[0..w] is also border of T[0..lb]. That is: any non-longest border of T is also border of the longest border of T. - Given the Prefix Function s of T, the length of the longest border of T can be calculated as s(n - 1), where n is the length of T. The longest border of the longest border can be calculated as s(s(n - 1) - 1). And so on... - Therefore, borders are found iteratively: the next border (shorter than the longest) can be calculated as the longest border of the border found at the previous iteration, by using the Prefix Function on the predecessor of the previous result: w(i) = s(w(i - 1) - 1); w(i + 1) = s(w(i) - 1) = s(s(w(i - 1) - 1) - 1), etc. - The iteration terminates when the Prefix Function returns 0, i.e. there is no border. COMPLEXITY - Values of the Prefix Function have to be iterated up to the last, since the longest border of the provided text T has a length equal to the value of the Prefix Function in n - 1, where n is the length of T. - Then there are as many iterations as the number of borders of T. In the worst case, T can have a number of borders comparable to the chars in it. For example, the string new string('a', n) has n - 1 borders: new string('a', n - 1) , new string('a', n - 2) , ..., \"a\". - For each iteration, the border is returned as new string, and that requires iterating over each char of the border. In the worst case, borders of T can have a length comparable to the length of T. For example the string new string('a', n) has a border of length n - 1 . - Direct accessing of the list of values of the Prefix Function is done in constant time. - Storing the Prefix Function values requires storing n integers, each of constant size. - Every iteration the string of a single border is built and returned. - Therefore, Time Complexity is O(Tpf * n + n ^ 2) and Space Complexity is O(Spf * n + n), where Tpf and Spf are the amortized cost of the Prefix Function values over the n chars of T. Constructors | Improve this Doc View Source PrefixFunctionBasedBorderExtraction(IPrefixFunctionCalculator) Declaration public PrefixFunctionBasedBorderExtraction(IPrefixFunctionCalculator prefixFunctionCalculator) Parameters Type Name Description IPrefixFunctionCalculator prefixFunctionCalculator Remarks Properties | Improve this Doc View Source PrefixFunctionCalculator The IPrefixFunctionCalculator implementation to be used, to calculate the Prefix Function of the text. Declaration protected IPrefixFunctionCalculator PrefixFunctionCalculator { get; } Property Value Type Description IPrefixFunctionCalculator Methods | Improve this Doc View Source GetAllBordersByDescLength(String) Declaration public IEnumerable<string> GetAllBordersByDescLength(string text) Parameters Type Name Description System.String text Returns Type Description IEnumerable < System.String > Remarks Implements IBordersExtraction Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.KnuthMorrisPratt.Matching.html": {
    "href": "api/MoreStructures.KnuthMorrisPratt.Matching.html",
    "title": "Namespace MoreStructures.KnuthMorrisPratt.Matching",
    "keywords": "Namespace MoreStructures.KnuthMorrisPratt.Matching Classes Matcher Exposes utility methods to match a text against a pattern, using the Knuth-Morris-Pratt algorithm."
  },
  "api/MoreStructures.KnuthMorrisPratt.Matching.Matcher.html": {
    "href": "api/MoreStructures.KnuthMorrisPratt.Matching.Matcher.html",
    "title": "Class Matcher",
    "keywords": "Class Matcher Exposes utility methods to match a text against a pattern, using the Knuth-Morris-Pratt algorithm. Inheritance System.Object Matcher Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.KnuthMorrisPratt.Matching Assembly : MoreStructures.dll Syntax public static class Matcher Methods | Improve this Doc View Source Match(String, String, Char, Boolean) Tries to match the provided pattern against the provided text , using the Knuth-Morris-Pratt algorithm. Returns all matches found. Declaration public static IEnumerable<Match<int>> Match(string text, string pattern, char separator, bool validateSeparator = false) Parameters Type Name Description System.String text The text, to match the pattern against. System.String pattern The pattern to match. System.Char separator A special character, to be used as separator in the concatenated string, between pattern and text . The special character is required by the algorithm and must be absent from both the pattern and the text . System.Boolean validateSeparator Whether an additional validation check should be performed, before actually running the algorithm, on whether text and pattern contain separator or not. The check requires going through all chars of text and pattern, and can be expensive. This is why it has to be explicitely opted-in. Returns Type Description IEnumerable < Match < System.Int32 >> A sequence of all matches, from the one starting at the lowest index in text to the one starting at the highest index. Remarks ALGORITHM The Knuth-Morris-Pratt algorithm: - First builds a concatenated string in the form \"pattern-separator-text\". - Then calculates the Prefix Function of the concatenated string. - Finally, iterates over the Prefix Function, retaining all indexes i such that the value of the Prefix Function at i is equal to the length of the pattern. That means that the prefix of the concatenated string from 0 to i (included) has a border of length equal to the length of the pattern, which means that the prefix contains the pattern. - For each retained index i, a successful match is emitted, starting at index i - 2 * m and matching exactly m chars, where m is the length of the pattern. COMPLEXITY - The only validation check which is not done in constant time is whether text and pattern contain the separator. This validation check is by default not done, and has to be opted in via the flag validateSeparator . When executed it takes O(n + m) time, since it has to compare the separator against each char of the text and of the pattern. - The concatenated string has length n + m + 1, where n is the length of the text and m is the length of the pattern. Building it requires iterating both over the pattern and the text. - Calculating the Prefix Function of the concatenated string via FastPrefixFunctionCalculator is a O(n + m + 1) operation, both in time and space. - Iterating over the indexes of the Prefix Function which refer to the text is an O(n) operation. - Each iteration makes a constant-time comparison and yield the result. - Therefore, both Time and Space Complexity are O(n + m)."
  },
  "api/MoreStructures.KnuthMorrisPratt.PrefixFunction.FastPrefixFunctionCalculator.html": {
    "href": "api/MoreStructures.KnuthMorrisPratt.PrefixFunction.FastPrefixFunctionCalculator.html",
    "title": "Class FastPrefixFunctionCalculator",
    "keywords": "Class FastPrefixFunctionCalculator An implementation of IPrefixFunctionCalculator which takes advantage of the property that any non-longest border is a also a border of the longest border, to calculate the Prefix Function efficiently. Inheritance System.Object FastPrefixFunctionCalculator Implements IPrefixFunctionCalculator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.KnuthMorrisPratt.PrefixFunction Assembly : MoreStructures.dll Syntax public class FastPrefixFunctionCalculator : IPrefixFunctionCalculator Remarks ALGORITHM - The algorithm iterates over all the chars of the text, from the first to the last, calculating the Prefix Function s for each index i. - The Prefix Function at index 0, s(0) = 0 , since a 1-char string can't have any border. - For each any other index, it calculates the value of the Prefix Function based on values of s at lower indexes and based on T. - if T[i] = T[s(i - 1)] , where s(i - 1) has been calculated at the previous step, then s(i) = s(i - 1) + 1 . - This is because T[0..s(i - 1)] is, by definition of s, a border of T[0..i] and, if T[i] = T[s(i - 1)] , then T[0..s(i - 1) + 1] = T[i - s(i)..i] . So T[0..s(i - 1) + 1] is a border of T[0..(i + 1)] and there can't be any longer border, since s(i + 1) <= s(i) + 1 (the Prefix Function can grow of at most 1 at each index). - if T[i] != T[s(i - 1)] , s(i) will be smaller than s(i - 1) + 1 . While s can increase of at most 1 at each index, it can decrease to 0 in a single step (if T[i] is such that there are no borders of T[0..(i + 1)]). - Because a border of T[0..(i + 1)] (prefix of T including up to the i-th char) is also a border of T[0..i] (prefix of T at previous step, i.e. including up to the (i - 1)-th char), EXCEPT for the char T[i], which would come just after the border of T[0..i], the longest border of T[0..(i + 1)] (whose length is s(i)), can be found by looking for the longest border of T[0..i] followed by T[i]. - If such a border of length w is found, then there is a border of T[0..i], T[0..w], followed by T[w] = T[i]. - Which means that T[0..(w + 1)] == T[(i - w)..(i + 1)] . - Therefore, T[0..(w + 1)] is a border of T[0..(i + 1)] and s(i + 1) = w . - If no borders are found, the Prefix Function at index i is zero. COMPLEXITY - There are as many top-level iterations as indexes of the Prefix Function and chars of the text. - For each top-level iteration, there are at most as many sub-iterations as borders of the prefix, each one checking a single char of the text. In the worst case there are O(n) borders, meaning that each sub-iteration requires O(n) char comparisons. - That would seem to imply that the number of sub-iterations in total, throughout all top-level iterations, would be quadratic. - However, the length of the border calculated by the inner loop is always non-negative and is increased of at most n times (since it is increased of at most 1 per char of text). - Moreover, it is progressively shorten by the inner loop, decreased of at least 1 per sub-iteration. This is because, when the char following the current border is different than the current char (which is the condition of the inner loop), the next border is the longest border of the current border, which is strictly shorter than the current border. - Therefore the length of the border can reach at most n thoughout all top-level iterations, and is always non-negative and decreased by 1 at each sub-iteration, which means that the total number of inner loop iterations through all top-level iterations is O(n). - All accesses to values calculated in previous steps and to chars of the text are done in constant time. - An array of integers, as big as the numbers of chars in the text, is allocated at the beginning, to memoize the value calculated at each step, since that value may be used in following iterations. - No other data structure is allocated by the algorithm. - Therefore, Time Complexity is O(n) and Space Complexity is O(n). Methods | Improve this Doc View Source GetValues(String) Declaration public IEnumerable<int> GetValues(string text) Parameters Type Name Description System.String text Returns Type Description IEnumerable < System.Int32 > Remarks Implements IPrefixFunctionCalculator Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.KnuthMorrisPratt.PrefixFunction.html": {
    "href": "api/MoreStructures.KnuthMorrisPratt.PrefixFunction.html",
    "title": "Namespace MoreStructures.KnuthMorrisPratt.PrefixFunction",
    "keywords": "Namespace MoreStructures.KnuthMorrisPratt.PrefixFunction Classes FastPrefixFunctionCalculator An implementation of IPrefixFunctionCalculator which takes advantage of the property that any non-longest border is a also a border of the longest border, to calculate the Prefix Function efficiently. NaivePrefixFunctionCalculator An implementation of IPrefixFunctionCalculator which retrieves the longest border, then checks its length. Interfaces IPrefixFunctionCalculator An algorithm which calculates the Prefix Function of the provided text."
  },
  "api/MoreStructures.KnuthMorrisPratt.PrefixFunction.IPrefixFunctionCalculator.html": {
    "href": "api/MoreStructures.KnuthMorrisPratt.PrefixFunction.IPrefixFunctionCalculator.html",
    "title": "Interface IPrefixFunctionCalculator",
    "keywords": "Interface IPrefixFunctionCalculator An algorithm which calculates the Prefix Function of the provided text. Namespace : MoreStructures.KnuthMorrisPratt.PrefixFunction Assembly : MoreStructures.dll Syntax public interface IPrefixFunctionCalculator Remarks The Prefix Function of a text T is a function s such that s(i) is the length of the longest border of the prefix of T up to the character with index i, included, i.e. T[0..(i+1)]. For example, if T = \"aabaabacaabaa\" : - s(0) = 0 , since T[0..1] = \"a\" has no borders; - s(1) = 1 , since T[0..2] = \"aa\" has a single border \"a\" , which is of length 1; - s(2) = 0 , since T[0..3] = \"aab\" has no borders; - s(3) = 1 , since T[0..4] = \"aaba\" has a single border \"a\" , which is of length 1; - s(4) = 1 , since T[0..5] = \"aabaa\" has 2 borders { \"a\", \"aa\" } , and the longest one is of length 2; - s(5) = 1 , since T[0..6] = \"aabaab\" has 3 borders { \"a\", \"aa\", \"aab\" } , and the longest one of length 3; - etc. Methods | Improve this Doc View Source GetValues(String) Calculate the values of the Prefix Function of the provided text . Declaration IEnumerable<int> GetValues(string text) Parameters Type Name Description System.String text The text, to calculate the Prefix Function of. Returns Type Description IEnumerable < System.Int32 > The sequence of System.Int32 values of the Prefix Function. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.KnuthMorrisPratt.PrefixFunction.NaivePrefixFunctionCalculator.html": {
    "href": "api/MoreStructures.KnuthMorrisPratt.PrefixFunction.NaivePrefixFunctionCalculator.html",
    "title": "Class NaivePrefixFunctionCalculator",
    "keywords": "Class NaivePrefixFunctionCalculator An implementation of IPrefixFunctionCalculator which retrieves the longest border, then checks its length. Inheritance System.Object NaivePrefixFunctionCalculator Implements IPrefixFunctionCalculator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.KnuthMorrisPratt.PrefixFunction Assembly : MoreStructures.dll Syntax public class NaivePrefixFunctionCalculator : IPrefixFunctionCalculator Remarks ALGORITHM - The algorithm iterates over all the chars of the text, from the first to the last. - For each char at index i, it retrieves the longest border of the prefix, up to char at index i included, by using the IBordersExtraction implementation provided at construction time. - GetAllBordersByDescLength(String) retrieves the borders from the longest to the shortest, whatever the implementation. Therefore, only the first border needs to be enumerated. - If no borders are found, the Prefix Function at index i is zero. Otherwise, it's the length of the longest. COMPLEXITY - There are as many prefixes of the text as chars. - The time and space cost of retrieving the longest border depends on the actual implementation of IBordersExtraction used, to retrieve the longest border, which, when it exists, it is the first in the sequence. - Checking whether a border has been found and, in case, its length are both constant time operations. - Therefore, Time Complexity is O(n * Tlb) and Space Complexity is O(n * Slb), where Tlb and Slb are the Time and Space Complexity of finding the longest border (1st item) via the provided BordersExtraction . - When NaiveBordersExtraction is used as BordersExtraction , Time Complexity is O(n^3) and Space Complexity is O(n). Constructors | Improve this Doc View Source NaivePrefixFunctionCalculator(IBordersExtraction) Declaration public NaivePrefixFunctionCalculator(IBordersExtraction bordersExtraction) Parameters Type Name Description IBordersExtraction bordersExtraction Properties | Improve this Doc View Source BordersExtraction The IBordersExtraction implementation to be used, to retrieve the longest border of the text. Declaration protected IBordersExtraction BordersExtraction { get; } Property Value Type Description IBordersExtraction Methods | Improve this Doc View Source GetValues(String) Declaration public IEnumerable<int> GetValues(string text) Parameters Type Name Description System.String text Returns Type Description IEnumerable < System.Int32 > Remarks Implements IPrefixFunctionCalculator Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Lists.Counting.DictionaryBasedOccurrencesCounter.html": {
    "href": "api/MoreStructures.Lists.Counting.DictionaryBasedOccurrencesCounter.html",
    "title": "Class DictionaryBasedOccurrencesCounter",
    "keywords": "Class DictionaryBasedOccurrencesCounter An implementation of IOccurrencesCounter which uses a to build the two-level of occurrences, indexed by distinct item values and index. Inheritance System.Object DictionaryBasedOccurrencesCounter Implements IOccurrencesCounter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Lists.Counting Assembly : MoreStructures.dll Syntax public class DictionaryBasedOccurrencesCounter : IOccurrencesCounter Methods | Improve this Doc View Source Count<T>(IEnumerable<T>) Declaration public IDictionary<T, IDictionary<int, int>> Count<T>(IEnumerable<T> enumerable) Parameters Type Name Description IEnumerable <T> enumerable Returns Type Description IDictionary <T, IDictionary < System.Int32 , System.Int32 >> Type Parameters Name Description T The type of items of enumerable . Remarks Perform counting by keeping a of the current number of occurrences per item encountered, by distinct value of T and index, while enumerating enumerable . Both Time Complexity and Space Complexity are O(n * sigma), where n = number of items in enumerable and sigma = number of the alphabet of enumerable , i.e. the number of distinct items of type T in enumerable . Implements IOccurrencesCounter Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Lists.Counting.html": {
    "href": "api/MoreStructures.Lists.Counting.html",
    "title": "Namespace MoreStructures.Lists.Counting",
    "keywords": "Namespace MoreStructures.Lists.Counting Classes DictionaryBasedOccurrencesCounter An implementation of IOccurrencesCounter which uses a to build the two-level of occurrences, indexed by distinct item values and index. Interfaces IOccurrencesCounter An object able to count the number of occurrences of each item of a , also known as Count Array."
  },
  "api/MoreStructures.Lists.Counting.IOccurrencesCounter.html": {
    "href": "api/MoreStructures.Lists.Counting.IOccurrencesCounter.html",
    "title": "Interface IOccurrencesCounter",
    "keywords": "Interface IOccurrencesCounter An object able to count the number of occurrences of each item of a , also known as Count Array. Namespace : MoreStructures.Lists.Counting Assembly : MoreStructures.dll Syntax public interface IOccurrencesCounter Methods | Improve this Doc View Source Count<T>(IEnumerable<T>) For each item t of type T in enumerable and for each index i of E, counts the total number of items equal to t in E[0..i] (extremes included). Declaration IDictionary<T, IDictionary<int, int>> Count<T>(IEnumerable<T> enumerable) Parameters Type Name Description IEnumerable <T> enumerable The enumerable, to count the items of. Returns Type Description IDictionary <T, IDictionary < System.Int32 , System.Int32 >> A new, lazy evaluated two-levels dictionary of System.Int32 , the 1st-level one having as many items as the number of distinct chars in enumerable , the 2nd-level one having as many items as the length of enumerable . Type Parameters Name Description T The type of items of enumerable . Required to be a non-nullable type (value or reference). Examples var counter = ... var enumerable = new List<int> { 1, 4, 2, 1, 3, 4, 2, 2 } var counts = counter.Count(enumerable) // Result = // { // [1, 0] = 1, [2, 0] = 0, [3, 0] = 0, [4, 0] = 0, // Counts by char in E[0..0] // [1, 1] = 1, [2, 1] = 0, [3, 1] = 0, [4, 1] = 1, // Counts by char in E[0..1] // [1, 2] = 1, [2, 2] = 1, [3, 2] = 0, [4, 2] = 1, // Counts by char in E[0..2] // ... // [1, 7] = 2, [2, 7] = 2, [3, 7] = 1, [4, 7] = 2, // Counts by char in E[0..7] // } Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Lists.Searching.BinarySearch.html": {
    "href": "api/MoreStructures.Lists.Searching.BinarySearch.html",
    "title": "Class BinarySearch",
    "keywords": "Class BinarySearch An object able to search in logarithmic time for items in direct random access structures, such as lists and arrays, which are monodimensional, implement the interface and are sorted in ascending order according to the provided comparer (which is the property enabling the search to be carried out in O(log(n)) time. Inheritance System.Object BinarySearch Implements ISearch Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Lists.Searching Assembly : MoreStructures.dll Syntax public class BinarySearch : ISearch Remarks The sorting order assumed by this search can be reversed by simply inverting the comparer implementation. Methods | Improve this Doc View Source First<T>(IEnumerable<T>, T, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) This specific implementation assumes that source is sorted in ascending order. Declaration public int First<T>(IEnumerable<T> source, T item, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source T item System.Nullable < IComparer <T>> comparer System.Nullable < System.Int32 > fromIndex System.Nullable < System.Int32 > toIndex Returns Type Description System.Int32 Type Parameters Name Description T Remarks The algorithm split in half the search space at every iteration, reducing it exponentially to a single item or to an empty set. Time Complexity = O(log(n)), Space Complexity = O(1), where n = number of items between fromIndex and toIndex . | Improve this Doc View Source FirstAll<T>(IEnumerable<T>, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) This specific implementation assumes that source is sorted in ascending order. Declaration public IDictionary<T, int> FirstAll<T>(IEnumerable<T> source, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source System.Nullable < IComparer <T>> comparer System.Nullable < System.Int32 > fromIndex System.Nullable < System.Int32 > toIndex Returns Type Description IDictionary <T, System.Int32 > Type Parameters Name Description T Remarks The size of the output and the Space Complexity is O(sigma), where: A binary search for the next different element gives an overall O(sigma * log(sigma)) Time Complexity. | Improve this Doc View Source Interval<T>(IEnumerable<T>, T, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) This specific implementation assumes that source is sorted in ascending order. Declaration public (int first, int last) Interval<T>(IEnumerable<T> source, T item, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source T item System.Nullable < IComparer <T>> comparer System.Nullable < System.Int32 > fromIndex System.Nullable < System.Int32 > toIndex Returns Type Description System.ValueTuple < System.Int32 , System.Int32 > Type Parameters Name Description T Remarks The algorithm peforms two successive binary search operations: the first to find the lower extreme of the interval and the second to find the higher extreme of the interval. Each binary search runs in logarithmic time. Time Complexity = O(log(n)), Space Complexity = O(1), where n = number of items between fromIndex and toIndex . | Improve this Doc View Source Last<T>(IEnumerable<T>, T, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) This specific implementation assumes that source is sorted in ascending order. Declaration public int Last<T>(IEnumerable<T> source, T item, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source T item System.Nullable < IComparer <T>> comparer System.Nullable < System.Int32 > fromIndex System.Nullable < System.Int32 > toIndex Returns Type Description System.Int32 Type Parameters Name Description T Remarks The algorithm split in half the search space at every iteration, reducing it exponentially to a single item or to an empty set. Time Complexity = O(log(n)), Space Complexity = O(1), where n = number of items between fromIndex and toIndex . | Improve this Doc View Source Nth<T>(IEnumerable<T>, T, Int32, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) This specific implementation assumes that source is sorted in ascending order. Declaration public int Nth<T>(IEnumerable<T> source, T item, int occurrenceRank, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source T item System.Int32 occurrenceRank System.Nullable < IComparer <T>> comparer System.Nullable < System.Int32 > fromIndex System.Nullable < System.Int32 > toIndex Returns Type Description System.Int32 Type Parameters Name Description T Remarks The algorithm first performs a binary search to find the index i of the 1st item. Then it checks whether the n-th occurrence of the item exists at index i + n, taking advantage of the fact that source is sorted. The first step takes logarithmic time, whereas the second step takes constant time and space to execute. Time Complexity = O(log(n)), Space Complexity = O(1), where n = number of items between fromIndex and toIndex . Implements ISearch Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Lists.Searching.html": {
    "href": "api/MoreStructures.Lists.Searching.html",
    "title": "Namespace MoreStructures.Lists.Searching",
    "keywords": "Namespace MoreStructures.Lists.Searching Classes BinarySearch An object able to search in logarithmic time for items in direct random access structures, such as lists and arrays, which are monodimensional, implement the interface and are sorted in ascending order according to the provided comparer (which is the property enabling the search to be carried out in O(log(n)) time. LinearSearch An object able to search in linear time for items in direct random access structures, such as lists and arrays, which are monodimensional and implement the interface. Interfaces ISearch An object able to search for items in direct random access structures, such as lists and arrays, which are monodimensional and implement the interface."
  },
  "api/MoreStructures.Lists.Searching.ISearch.html": {
    "href": "api/MoreStructures.Lists.Searching.ISearch.html",
    "title": "Interface ISearch",
    "keywords": "Interface ISearch An object able to search for items in direct random access structures, such as lists and arrays, which are monodimensional and implement the interface. Namespace : MoreStructures.Lists.Searching Assembly : MoreStructures.dll Syntax public interface ISearch Remarks In .NET, random access structures usually have an indexer defined, which takes as an index the address of the item in the data structure (usually an integer). Most random access structures (but not all) inherit and define . A notable exception is System.String , which has an indexer ( System.String.Chars(System.Int32) ), but does not implement . For System.String , specific optimizations are done, to ensure random access in O(1) time. Methods | Improve this Doc View Source First<T>(IEnumerable<T>, T, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) Find the index of the first item in the sub-sequence of items of source from fromIndex to toIndex included, which is equal to item . Declaration int First<T>(IEnumerable<T> source, T item, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source The enumerable where to search for item . T item The item to search for. System.Nullable < IComparer <T>> comparer The comparer to be used when performing the search. If not specified, is used. System.Nullable < System.Int32 > fromIndex The first index, marking the begin of the sub-sequence of source where to search. If not specified, 0 is used. System.Nullable < System.Int32 > toIndex The last index, marking the end of the sub-sequence of source where to search. If not specified, is called on source to calculate the count of items, and count - 1 is used. If source is a System.String , however, System.String.Length is used instead. Returns Type Description System.Int32 The first index of item in source . Type Parameters Name Description T The type of items of source . Must be comparable. If it is System.String , random access is done in O(1) via System.String.Chars(System.Int32) . Otherwise, random access is done via the generic LINQ method , which is O(n) or O(1) dependending on the concretion. | Improve this Doc View Source FirstAll<T>(IEnumerable<T>, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) Find the indexes of the first occurrence of each item in the sub-sequence of items of source from fromIndex to toIndex included. Declaration IDictionary<T, int> FirstAll<T>(IEnumerable<T> source, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source The enumerable. System.Nullable < IComparer <T>> comparer The comparer to be used when performing the search, to tell apart different items. If not specified, is used. System.Nullable < System.Int32 > fromIndex The first index, marking the begin of the sub-sequence of source where to search. If not specified, 0 is used. System.Nullable < System.Int32 > toIndex The last index, marking the end of the sub-sequence of source where to search. If not specified, is called on source to calculate the count of items, and count - 1 is used. If source is a System.String , however, System.String.Length is used instead. Returns Type Description IDictionary <T, System.Int32 > A containing the 0-based index first occurrence of each item, indexed by the item itself. Type Parameters Name Description T The type of items of source . Must be comparable and non-null, since it is used as key to index first occurrence indexes in the output . If it is System.String , random access is done in O(1) via System.String.Chars(System.Int32) . Otherwise, random access is done via the generic LINQ method , which is O(n) or O(1) dependending on the concretion. | Improve this Doc View Source Interval<T>(IEnumerable<T>, T, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) Find the indexes of the first and last items in the sub-sequence of items of source from fromIndex to toIndex included, which is equal to item . Declaration (int first, int last) Interval<T>(IEnumerable<T> source, T item, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source The enumerable where to search for item . T item The item to search for. System.Nullable < IComparer <T>> comparer The comparer to be used when performing the search. If not specified, is used. System.Nullable < System.Int32 > fromIndex The first index, marking the begin of the sub-sequence of source where to search. If not specified, 0 is used. System.Nullable < System.Int32 > toIndex The last index, marking the end of the sub-sequence of source where to search. If not specified, is called on source to calculate the count of items, and count - 1 is used. If source is a System.String , however, System.String.Length is used instead. Returns Type Description System.ValueTuple < System.Int32 , System.Int32 > The first and last index, marking the end of the sub-sequence of source where to search. Type Parameters Name Description T The type of items of source . Must be comparable. If it is System.String , random access is done in O(1) via System.String.Chars(System.Int32) . Otherwise, random access is done via the generic LINQ method , which is O(n) or O(1) dependending on the concretion. | Improve this Doc View Source Last<T>(IEnumerable<T>, T, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) Find the index of the last item in the sub-sequence of items of source from fromIndex to toIndex included, which is equal to item . Declaration int Last<T>(IEnumerable<T> source, T item, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source The enumerable where to search for item . T item The item to search for. System.Nullable < IComparer <T>> comparer The comparer to be used when performing the search. If not specified, is used. System.Nullable < System.Int32 > fromIndex The first index, marking the begin of the sub-sequence of source where to search. If not specified, 0 is used. System.Nullable < System.Int32 > toIndex The last index, marking the end of the sub-sequence of source where to search. If not specified, is called on source to calculate the count of items, and count - 1 is used. If source is a System.String , however, System.String.Length is used instead. Returns Type Description System.Int32 The first and last index, marking the end of the sub-sequence of source where to search. Type Parameters Name Description T The type of items of source . Must be comparable. If it is System.String , random access is done in O(1) via System.String.Chars(System.Int32) . Otherwise, random access is done via the generic LINQ method , which is O(n) or O(1) dependending on the concretion. | Improve this Doc View Source Nth<T>(IEnumerable<T>, T, Int32, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) Find the index of the n-th occurence (0-based) of the item in the sub-sequence of items of source from fromIndex to toIndex included, which is equal to item . Declaration int Nth<T>(IEnumerable<T> source, T item, int occurrenceRank, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source T item System.Int32 occurrenceRank System.Nullable < IComparer <T>> comparer System.Nullable < System.Int32 > fromIndex System.Nullable < System.Int32 > toIndex Returns Type Description System.Int32 The n-th index, marking the end of the sub-sequence of source where to search. Type Parameters Name Description T The type of items of source . Must be comparable. If it is System.String , random access is done in O(1) via System.String.Chars(System.Int32) . Otherwise, random access is done via the generic LINQ method , which is O(n) or O(1) dependending on the concretion. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Lists.Searching.LinearSearch.html": {
    "href": "api/MoreStructures.Lists.Searching.LinearSearch.html",
    "title": "Class LinearSearch",
    "keywords": "Class LinearSearch An object able to search in linear time for items in direct random access structures, such as lists and arrays, which are monodimensional and implement the interface. Inheritance System.Object LinearSearch Implements ISearch Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Lists.Searching Assembly : MoreStructures.dll Syntax public class LinearSearch : ISearch Remarks Unlike BinarySearch , this implementation doesn't make any assumption on the order of items in in the data structure. Methods | Improve this Doc View Source First<T>(IEnumerable<T>, T, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) This specific implementation does not make any assunption on source being sorted. Declaration public int First<T>(IEnumerable<T> source, T item, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source T item System.Nullable < IComparer <T>> comparer System.Nullable < System.Int32 > fromIndex System.Nullable < System.Int32 > toIndex Returns Type Description System.Int32 Type Parameters Name Description T Remarks The algorithm linearly scans the search space from fromIndex to toIndex , one index at every iteration, reducing it linearly to a single item or to an empty set. Time Complexity = O(n), Space Complexity = O(1), where n = number of items between fromIndex and toIndex . | Improve this Doc View Source FirstAll<T>(IEnumerable<T>, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) This specific implementation does not make any assunption on source being sorted. Declaration public IDictionary<T, int> FirstAll<T>(IEnumerable<T> source, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source System.Nullable < IComparer <T>> comparer System.Nullable < System.Int32 > fromIndex System.Nullable < System.Int32 > toIndex Returns Type Description IDictionary <T, System.Int32 > Type Parameters Name Description T Remarks ALGORITHM The algorithm linearly scans the search space from fromIndex to toIndex , one index at every iteration, collecting first occurrences into a . COMPLEXITY Time Complexity = O(n), Space Complexity = O(sigma), where: - n is the number of items between fromIndex and toIndex . - For \"large alphabets\" scenarios (such as when the alphabet is int - 2^32 possible values, but source is way smaller than that), sigma is the number of distinct elements of source . - For \"small alphabets\" scenarios (such as when the alphabet is comprised of few symbols only), sigma is the size of the alphabet. - In either scenario the worst case of the O(sigma) Space Complexity is O(n), which is when all the symbols in source are different from each other). | Improve this Doc View Source Interval<T>(IEnumerable<T>, T, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) This specific implementation does not make any assunption on source being sorted. Declaration public (int first, int last) Interval<T>(IEnumerable<T> source, T item, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source T item System.Nullable < IComparer <T>> comparer System.Nullable < System.Int32 > fromIndex System.Nullable < System.Int32 > toIndex Returns Type Description System.ValueTuple < System.Int32 , System.Int32 > Type Parameters Name Description T Remarks The algorithm linearly scans the search space from fromIndex to toIndex , one index at every iteration. It just stores the smallest and the biggest index among the ones which correspond to items equal to item . So it has constant, and not linear, space requirements. Time Complexity = O(n), Space Complexity = O(1), where n = number of items between fromIndex and toIndex . | Improve this Doc View Source Last<T>(IEnumerable<T>, T, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) This specific implementation does not make any assunption on source being sorted. Declaration public int Last<T>(IEnumerable<T> source, T item, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source T item System.Nullable < IComparer <T>> comparer System.Nullable < System.Int32 > fromIndex System.Nullable < System.Int32 > toIndex Returns Type Description System.Int32 Type Parameters Name Description T Remarks The algorithm linearly scans the search space from toIndex to fromIndex , one index at every iteration, reducing it linearly to a single item or to an empty set. Time Complexity = O(n), Space Complexity = O(1), where n = number of items between fromIndex and toIndex . | Improve this Doc View Source Nth<T>(IEnumerable<T>, T, Int32, Nullable<IComparer<T>>, Nullable<Int32>, Nullable<Int32>) This specific implementation does not make any assunption on source being sorted. Declaration public int Nth<T>(IEnumerable<T> source, T item, int occurrenceRank, IComparer<T>? comparer = null, int? fromIndex = null, int? toIndex = null) Parameters Type Name Description IEnumerable <T> source T item System.Int32 occurrenceRank System.Nullable < IComparer <T>> comparer System.Nullable < System.Int32 > fromIndex System.Nullable < System.Int32 > toIndex Returns Type Description System.Int32 Type Parameters Name Description T Remarks The algorithm linearly scans the search space from toIndex to fromIndex , one index at every iteration, reducing it linearly to a single item or to an empty set. It just stores the current counter of occurrences of item in source , not all of them. So it has constant, and not linear, space requirements. Time Complexity = O(n), Space Complexity = O(1), where n = number of items between fromIndex and toIndex . Implements ISearch Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Lists.Sorting.Extensions.html": {
    "href": "api/MoreStructures.Lists.Sorting.Extensions.html",
    "title": "Class Extensions",
    "keywords": "Class Extensions Extensions methods for , in the context of list sorting. Inheritance System.Object Extensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Lists.Sorting Assembly : MoreStructures.dll Syntax public static class Extensions Methods | Improve this Doc View Source IsSorted<T>(IList<T>) Verifies that the provided list is sorted. Declaration public static bool IsSorted<T>(this IList<T> list) where T : IComparable<T> Parameters Type Name Description IList <T> list The to check. Returns Type Description System.Boolean true if list is sorted, false otherwise. Type Parameters Name Description T The type of items of list . Remarks Zips the list with itself, shifted one item forward. Then checks whether each of the couples of the zip has a non-bigger than . Stops at the first encountered. Time Complexity is O(n), when fully enumerated and in the worst case. Space Complexity is O(1). | Improve this Doc View Source IsSorted<T>(IList<T>, IComparer<T>) Verifies that the provided list is sorted, using the provided comparer . Declaration public static bool IsSorted<T>(this IList<T> list, IComparer<T> comparer) Parameters Type Name Description IList <T> list The to check. IComparer <T> comparer The to be used to comparer T instances. Returns Type Description System.Boolean true if list is sorted, false otherwise. Type Parameters Name Description T The type of items of list . Remarks"
  },
  "api/MoreStructures.Lists.Sorting.HeapSort.html": {
    "href": "api/MoreStructures.Lists.Sorting.HeapSort.html",
    "title": "Class HeapSort",
    "keywords": "Class HeapSort An IInPlaceSorting implementation based on heapsort. Inheritance System.Object HeapSort Implements IInPlaceSorting Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Lists.Sorting Assembly : MoreStructures.dll Syntax public class HeapSort : IInPlaceSorting Remarks ALGORITHM - This sorting algorithm relies entirely on the max binary heap data structure. - Given the list L to sort, it builds an heap H out of the entire list, passing L as backing structure for H. - H is defined at the end of L and with an inverted order, so that it always pops the current minimum from the root located at very end of the list, and leaves holes at the beginning of the list. - Then, it pops items from H, one by one, appending at the front of L, where the pop has left a hole. - For example if L is 10 items long, the first pop will leave the item at index 0 unoccupied, the second pop will leave the item at index 1 unoccupied (the item at index 0 already is out of the picture), etc. - Once the last item of H is popped, the heap is empty and L is sorted in ascending order. COMPLEXITY - Building a heap in batch from a list of n items takes a linear amount of time. - Each pop takes a logarithmic amount of time, due to the sift down required to restore the heap property. - Storing the popped item at the back of the list is a constant time operation. - Because the heap is built in place on the provided list, the list is never replicated in memroy and only a constant amount of additional space is required, for heap re-adjustment operations. - Therefore, Time Complexity is O(n * log(n)) and Space Complexity is O(1), where n is the number of items being sorted (which can be lower than the size of the provided list). Methods | Improve this Doc View Source Sort<T>(IList<T>) Uses the heapsort algorithm with the default comparer for T , given by . Declaration public void Sort<T>(IList<T> list) where T : IComparable<T> Parameters Type Name Description IList <T> list Type Parameters Name Description T Remarks | Improve this Doc View Source Sort<T>(IList<T>, IComparer<T>) Uses the heapsort algorithm with the specified comparer . Declaration public void Sort<T>(IList<T> list, IComparer<T> comparer) Parameters Type Name Description IList <T> list IComparer <T> comparer Type Parameters Name Description T Remarks Implements IInPlaceSorting Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Lists.Sorting.html": {
    "href": "api/MoreStructures.Lists.Sorting.html",
    "title": "Namespace MoreStructures.Lists.Sorting",
    "keywords": "Namespace MoreStructures.Lists.Sorting Classes Extensions Extensions methods for , in the context of list sorting. HeapSort An IInPlaceSorting implementation based on heapsort. InsertionSort An IInPlaceSorting implementation based on insertion sort. SelectionSort An IInPlaceSorting implementation based on selection sort. ShellSort An IInPlaceSorting implementation based on Shell sort. Interfaces IInPlaceSorting An algorithm sorting the given list in place, i.e. directly modifying the list given in input and using such list as \"workspace\", rather than generating a brand new list sorted. IStableSortingAlgorithm Used to mark sorting algorithms (in place or not), which are stable . Just for marking and information."
  },
  "api/MoreStructures.Lists.Sorting.IInPlaceSorting.html": {
    "href": "api/MoreStructures.Lists.Sorting.IInPlaceSorting.html",
    "title": "Interface IInPlaceSorting",
    "keywords": "Interface IInPlaceSorting An algorithm sorting the given list in place, i.e. directly modifying the list given in input and using such list as \"workspace\", rather than generating a brand new list sorted. Namespace : MoreStructures.Lists.Sorting Assembly : MoreStructures.dll Syntax public interface IInPlaceSorting Methods | Improve this Doc View Source Sort<T>(IList<T>) Sorts the provided in place. Uses the default comparer of instances of type T to compare items. Declaration void Sort<T>(IList<T> list) where T : IComparable<T> Parameters Type Name Description IList <T> list Type Parameters Name Description T The type of items of the list . Unlike in Sort<T>(IList<T>) , it doesn't necessarily have to support , as an external is provided. Remarks Alternative to Sort<T>(IList<T>) when T doesn't support or when the sorting strategy to be used is not the default one. | Improve this Doc View Source Sort<T>(IList<T>, IComparer<T>) Sorts the provided in place. Uses the provided comparer of instances of type T to compare items. Declaration void Sort<T>(IList<T> list, IComparer<T> comparer) Parameters Type Name Description IList <T> list The list to be sorted. IComparer <T> comparer The comparer of instances of T , to be used for comparisons (if necessary). Type Parameters Name Description T The type of items of the list . Unlike in Sort<T>(IList<T>) , it doesn't necessarily have to support , as an external is provided. Remarks Alternative to Sort<T>(IList<T>) when T doesn't support or when the sorting strategy to be used is not the default one. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Lists.Sorting.InsertionSort.html": {
    "href": "api/MoreStructures.Lists.Sorting.InsertionSort.html",
    "title": "Class InsertionSort",
    "keywords": "Class InsertionSort An IInPlaceSorting implementation based on insertion sort. Inheritance System.Object InsertionSort Implements IInPlaceSorting Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Lists.Sorting Assembly : MoreStructures.dll Syntax public class InsertionSort : IInPlaceSorting Remarks ALGORITHM - This sorting algorithm split the list L being sorted in two parts: the sorted part, located at the beginning of the list (L[..i]), and the unsorted part, located at the end of the list (L[i..]). - At the beginning the sorted part is empty (i.e. length 0) and the unsorted part covers the entire list (i.e. length n). - The algorithm runs n - 1 1-based iterations, where n is the number of items in the list. - At the beginning of iteration i, the sorted sub-list is L[..i] and the unsorted sub-list is L[i..]. - The first item L[i], of the unsorted sub-list L[i..], is compared against its predecessor, L[i - 1]. - If L[i] is smaller than L[i - 1], the two items are swapped and the new L[i - 1] is compared with L[i - 2]. Comparisons and swapping continues until the predecessor is not bigger than its successor, potentially until the head of the list is reached. - When a L[j] is found, which is not strictly smaller than L[j - 1], L[.. (i + 1)] is sorted, and the iteration i can terminate. COMPLEXITY - Each of the n - 1 iterations runs at most i - 1 comparisons, if it has to swap all the way up to the head of the list. - The total number of comparisons, over the n iterations, is around n * n / 2. - Therefore, Time Complexity is O(n^2) and Space Complexity is O(1), since the algorithm runs in place and hence only requires additional constant space to perform the sorting. Methods | Improve this Doc View Source Sort<T>(IList<T>) Uses the insertion sort algorithm with the default comparer for T , given by . Declaration public void Sort<T>(IList<T> list) where T : IComparable<T> Parameters Type Name Description IList <T> list Type Parameters Name Description T Remarks | Improve this Doc View Source Sort<T>(IList<T>, IComparer<T>) Uses the insertion sort algorithm with the specified comparer . Declaration public void Sort<T>(IList<T> list, IComparer<T> comparer) Parameters Type Name Description IList <T> list IComparer <T> comparer Type Parameters Name Description T Remarks Implements IInPlaceSorting Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Lists.Sorting.IStableSortingAlgorithm.html": {
    "href": "api/MoreStructures.Lists.Sorting.IStableSortingAlgorithm.html",
    "title": "Interface IStableSortingAlgorithm",
    "keywords": "Interface IStableSortingAlgorithm Used to mark sorting algorithms (in place or not), which are stable . Just for marking and information. Namespace : MoreStructures.Lists.Sorting Assembly : MoreStructures.dll Syntax public interface IStableSortingAlgorithm Remarks A sorting algorithm is stable when for any two items of the input list L, L[i] and L[j] with i != j, which are equivalent acconding to the IComparable of IComparer being used, if i < j then i* < j*, where i* and j* are the indexes of L[i] and L[j] in the sorted version of L given as output. In other words, a stable sorting algorithm preserves the input order of equivalent items from the input to the output. Standard implementations of QuickSort and HeapSort are examples of non-stable algorithms. QuickSort partitioning, depending on how the pivot is selected and where it ends up being, can change relative position of equivalent items. HeapSort may also change the order, since Sift Down and Up operation may swap relative position of equivalent items, either during heap construction or during heap rearrangement on pop. MergeSort can be implemented as a stable algorithm, if the 2-way merge procedure prefers the lower index when choice between two equivalent items, one from the lower half and one from the higher half, is given. Selection and Insertion Sort can both be implemented as stable sorting algorithms. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Lists.Sorting.SelectionSort.html": {
    "href": "api/MoreStructures.Lists.Sorting.SelectionSort.html",
    "title": "Class SelectionSort",
    "keywords": "Class SelectionSort An IInPlaceSorting implementation based on selection sort. Inheritance System.Object SelectionSort Implements IInPlaceSorting Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Lists.Sorting Assembly : MoreStructures.dll Syntax public class SelectionSort : IInPlaceSorting Remarks ADVANTAGES AND DISADVANTAGES - The algorithm performs sorting in place and is online. - It is not stable in its basic form and requires additional space or specific assumptions on the type of list being sorted (such as it being a linked list). - Compared to other quadratic comparison-based algorithms, such as InsertionSort , it is generally simpler but requires in average an higher number of comparisons, therefore yielding worse performance. - Compared to linearithmic comparison-based algorithms, such as HeapSort , it is way simpler to understand and predict in exact number of operations executed. However, the performance is sensibly worse. - Compared to non-comparison-based algorithms, such as counting sort, it doesn't require any assumption on the type or values of the items in the input, the only requirement being their total comparability and the comparison behaving according to total order operators rules. ALGORITHM - This sorting algorithm split the list L being sorted in two parts: the sorted part, located at the beginning of the list (L[..i]), and the unsorted part, located at the end of the list (L[i..]). - At the beginning the sorted part is empty (i.e. length 0) and the unsorted part covers the entire list (i.e. length n). - The algorithm runs n iterations, where n is the number of items in the list. - At the beginning of iteration i, the sorted sub-list is L[..i] and the unsorted sub-list is L[i..]. - The unsorted sub-list L[i..] is scanned linearly, looking for the index j, between i and n - 1, of the item of L[i..] with minimum value. - L[i] is swapped with L[j] and the iteration i terminates. - Now L[..(i + 1)] is the new sorted sub-list, and L[(i + 1)..] is the new unsorted sub-list. COMPLEXITY - Each of the n iterations runs n - i - 1 comparisons, to identify the index of the item with the minimum value in the sub-list L[i..]. - The total number of comparisons, over the n iterations, is around n * n / 2. - Therefore, Time Complexity is O(n^2) and Space Complexity is O(1), since the algorithm runs in place. Methods | Improve this Doc View Source Sort<T>(IList<T>) Uses the selection sort algorithm with the default comparer for T , given by . Declaration public void Sort<T>(IList<T> list) where T : IComparable<T> Parameters Type Name Description IList <T> list Type Parameters Name Description T Remarks | Improve this Doc View Source Sort<T>(IList<T>, IComparer<T>) Uses the selection sort algorithm with the specified comparer . Declaration public void Sort<T>(IList<T> list, IComparer<T> comparer) Parameters Type Name Description IList <T> list IComparer <T> comparer Type Parameters Name Description T Remarks Implements IInPlaceSorting Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Lists.Sorting.ShellSort.html": {
    "href": "api/MoreStructures.Lists.Sorting.ShellSort.html",
    "title": "Class ShellSort",
    "keywords": "Class ShellSort An IInPlaceSorting implementation based on Shell sort. Inheritance System.Object ShellSort Implements IInPlaceSorting Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Lists.Sorting Assembly : MoreStructures.dll Syntax public class ShellSort : IInPlaceSorting Remarks ADVANTAGES AND DISADVANTAGES - Compared to InsertionSort , it has better runtime, because it reduces the total number of swapping operations performed. - That comes the cost of its complexity, which is higher than InsertionSort since Shell sort requires execution of InsertionSort on multiple interleaved lists. - However, its performance heavily depends on the chosen gap sequence, with best cases being O(n * log(n)) and worst cases being O(n^2), depending on the gap sequence. - Its average complexity characterization is to this day an open problem, and its lack of predictability is one of its main drawbacks. - Unlike InsertionSort , it is not stable, i.e. it doesn't preserve the order of items in the input with the same sorting key. This is due to the fact that the algorithm performs sorting of the subset of the input with the highest gap first, potentially skipping first occurrences of some of the duplicated items. ALGORITHM - This sorting algorithm runs the basic insertion sort algorithm, multiple times and with multiple steps. - In a standard insertion sort, comparisons and swapping at the iteration i of the main loop of the algorithm are always made between items at consecutive locations, going back until the i-th item is placed in order w.r.t. all preceding items. - That means that large items appearing early in the input will be swapped many times, before reaching their final position in the input. - For example the items 5 to 9 in the input [5, 6, 7, 8, 9, 0, 1, 2, 3, 4] are swapped to make room for the items 0 to 4. After 4 iterations, the iteration with i = 5 places 0 correctly by shifting from 9 all the way down to 5. Same with all following iterations, with a total of 5 * 5 = 25 swapping operations before the value 9 gets into its final place. - The idea behind Shell sort is that it gives the chance to bigger values to be placed closer to their final position, faster than insertion sort. - It does that by sorting via insertion sort not just once and for the entire input, but multiple times and on different sub-sets of it. Sub-sets are appropriately chosen, in a way that bigger values require less swapping before getting to their final place. - The first sub-set of indexes sorted is defined by all locations of the input which are at a relative distance equal to the gap. The gap is first set at its highest value and then decreased at every iteration. - Gap sequence is externally provided. For example, if the sequence provided is the powers of 2, the actual gap sequence used for an input of 10 items is [8, 4, 2, 1] (8 is the highest power of 2 smaller than 10). - After the 1st run of insertion sort (gap = 8), the list is [2, 6, 7, 8, 9, 0, 1, 5, 3, 4]. - After the 2nd run of insertion sort (gap = 4), the list is [2, 6, 7, 8, 4, 0, 1, 5, 3, 9]. - As visible from the example, after only 3 comparisons, both the smallest and biggest items are already in place. COMPLEXITY - Space Complexity is always O(1), since the algorithm runs in place. - Time Complexity, however, is strictly connected to the gap sequence selected. - Worst-case performance is O(n^2), assuming worst-case gap sequence, and O(n * log^2(n)), assuming best-case gap sequence. - Best-case performance is O(n * log^2(n)), assuming worst-case gap sequence, and O(n * log(n)), assuming best-case gap sequence. - Best-case performance is still O(n * log(n)) for most gap sequences in general. Constructors | Improve this Doc View Source ShellSort(IEnumerable<Int32>) Declaration public ShellSort(IEnumerable<int> gapGenerator) Parameters Type Name Description IEnumerable < System.Int32 > gapGenerator Properties | Improve this Doc View Source GapGenerator A generator of a monotonically strictly increasing sequence of System.Int32 , each representing a gap between locations of the input. Declaration protected IEnumerable<int> GapGenerator { get; } Property Value Type Description IEnumerable < System.Int32 > Methods | Improve this Doc View Source Sort<T>(IList<T>) Uses the Shell sort algorithm with the default comparer for T , given by . Declaration public void Sort<T>(IList<T> list) where T : IComparable<T> Parameters Type Name Description IList <T> list Type Parameters Name Description T Remarks | Improve this Doc View Source Sort<T>(IList<T>, IComparer<T>) Uses the Shell sort algorithm with the specified comparer . Declaration public void Sort<T>(IList<T> list, IComparer<T> comparer) Parameters Type Name Description IList <T> list IComparer <T> comparer Type Parameters Name Description T Remarks Implements IInPlaceSorting Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.PriorityQueues..html": {
    "href": "api/MoreStructures.PriorityQueues..html",
    "title": "Class",
    "keywords": "Class An item of type T with a priority and a \"push timestamp\" assigned to it. Inheritance System.Object Implements System.IEquatable < MoreStructures.PriorityQueues. > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.PriorityQueues Assembly : MoreStructures.dll Syntax public class : IEquatable<> Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.PriorityQueues.ArrayList.ArrayListPriorityQueue-1.html": {
    "href": "api/MoreStructures.PriorityQueues.ArrayList.ArrayListPriorityQueue-1.html",
    "title": "Class ArrayListPriorityQueue<T>",
    "keywords": "Class ArrayListPriorityQueue<T> An IPriorityQueue<T> implementation based on an unsorted list of its items. On top of basic operations it also supports IUpdatablePriorityQueue<T> , IPeekKthPriorityQueue<T> and IMergeablePriorityQueue<T, TPQTarget> . operations. Inheritance System.Object ArrayListPriorityQueue<T> Implements IUpdatablePriorityQueue <T> IPeekKthPriorityQueue <T> IMergeablePriorityQueue <T, ArrayListPriorityQueue <T>> IPriorityQueue <T> IEnumerable <T> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.PriorityQueues.ArrayList Assembly : MoreStructures.dll Syntax public sealed class ArrayListPriorityQueue<T> : IUpdatablePriorityQueue<T>, IPeekKthPriorityQueue<T>, IMergeablePriorityQueue<T, ArrayListPriorityQueue<T>>, IPriorityQueue<T> Type Parameters Name Description T Remarks ADVANTAGES AND DISADVANTAGES This represents one of the simplest implementations of a Priority Queue. It provides O(1) count and amortized insertion, at the cost of all other operations, which are O(n). If insertion performance is the only highly critical operation, to the point that a constant time performance is the only acceptable runtime, and not even the logarithmic time insertion of a tree-based solution can be applied, this implementation may be the best choice, although lazy approaches such as FibonacciHeapPriorityQueue<T> can provide constant-time insertion performance, while keeping sub-linear complexity for all other operations. If merging performance is also important, a solution based on linked lists can offer constant-time merging and still similar simplicity of implementation, same insertion performance and same tradeoff in terms of the complexity of all other operations. When data extraction performance is also a concern, or the main concern, a more balanced solution in terms of complexity of its operations should be preferred. This implementation can also be useful as a benchmark baseline in tests, when comparing against more complex solutions. Constructors | Improve this Doc View Source ArrayListPriorityQueue() Builds an empty priority queue. Declaration public ArrayListPriorityQueue() | Improve this Doc View Source ArrayListPriorityQueue(List<PrioritizedItem<T>>) Builds a priority queue using the provided list as direct backing structure. Declaration public ArrayListPriorityQueue(List<PrioritizedItem<T>> items) Parameters Type Name Description List < MoreStructures.PriorityQueues.PrioritizedItem <T>> items The structure to be used as backing structure. Remarks The provided list is not copied over: it is used directly as backing structure for the queue. Therefore, operations mutating the queue such as Push(T, Int32) will alter the content of the items list. | Improve this Doc View Source ArrayListPriorityQueue(IEnumerable<PrioritizedItem<T>>) Builds a priority queue using the provided items to populate its backing structure. Declaration public ArrayListPriorityQueue(IEnumerable<PrioritizedItem<T>> items) Parameters Type Name Description System.Collections.IEnumerable < MoreStructures.PriorityQueues.PrioritizedItem <T>> items The items to be added to the queue. Remarks The provided sequence is enumerated and copied over onto a dedicated list: it is not used directly as backing structure for the queue. Therefore, operations mutating the queue won't alter the provided items sequence. Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description System.Int32 Remarks Calls Count on the underlying list. Time and Space Complexity are O(1). Methods | Improve this Doc View Source Clear() Declaration public void Clear() Remarks Just clears the underlying array list. Time and Space Complexity is O(1). | Improve this Doc View Source GetEnumerator() Declaration public IEnumerator<T> GetEnumerator() Returns Type Description System.Collections.IEnumerator <T> Remarks Sorts the underlying list in descending order of priority and selects the items. Time Complexity is O(n * log(n)) (when fully enumerated). Space Complexity is O(n), as required by sorting. | Improve this Doc View Source GetPrioritiesOf(T) Declaration public IEnumerable<int> GetPrioritiesOf(T item) Parameters Type Name Description T item Returns Type Description System.Collections.IEnumerable < System.Int32 > Remarks Linearly scans the underlying list looking for MoreStructures.PriorityQueues.PrioritizedItem<T> having an item equals to the provided item ( System.Object.Equals(System.Object, System.Object) is used to compare the two items of type T ). It then selects all priorities found for item and builds a ArrayListPriorityQueue<T> of System.Int32 values out of them. Such a priority queue is returned as result. Time Complexity is O(n * Teq) and Space Complexity is O(Seq), where Teq and Seq are the time and space cost of comparing two items of type T . | Improve this Doc View Source MergeFrom(ArrayListPriorityQueue<T>) Declaration public void MergeFrom(ArrayListPriorityQueue<T> targetPriorityQueue) Parameters Type Name Description ArrayListPriorityQueue <T> targetPriorityQueue Remarks Just pushes all items in the targetPriorityQueue via Push(T, Int32) , which appends each item to the end. Then clears the content of the targetPriorityQueue , to respect the contract defined by IMergeablePriorityQueue<T, TPQTarget> . Because the underlying structures of both source and target is an array list, there isn't an effective strategy for achieving sub-linear performance, and Push(T, Int32) gives the optimal linear performance. Time and Space Complexity are O(m), where m is the number of items in the target. | Improve this Doc View Source Peek() Declaration public PrioritizedItem<T> Peek() Returns Type Description MoreStructures.PriorityQueues.PrioritizedItem <T> Remarks Linearly scans the underlying list looking for the highest priority. Time Complexity is O(n). Space Complexity is O(1). | Improve this Doc View Source PeekKth(Int32) Declaration public PrioritizedItem<T>? PeekKth(int k) Parameters Type Name Description System.Int32 k Returns Type Description System.Nullable < MoreStructures.PriorityQueues.PrioritizedItem <T>> Remarks Uses the Quick Select algorithm to find the k -th largest element by in the underlying list. Because Quick Select requires at least partial in-place sorting, the entire content of the underlying list is first copied into a temporary list, which is passed as target to the Quick Select procedure. Selected pivot is always at the end of the range of indexes in which selection is happening. So If input is already sorted in ascending order, Time Complexity is O(n^2), whereas in the average case Time Complexity is O(n). Space Complexity is always O(n). | Improve this Doc View Source Pop() Declaration public PrioritizedItem<T> Pop() Returns Type Description MoreStructures.PriorityQueues.PrioritizedItem <T> Remarks Linearly scans the underlying list looking for the index with the highest priority. Then removes the item with such index from the underlying list and returns it as result. Time Complexity is O(n). Space Complexity is O(1). | Improve this Doc View Source Push(T, Int32) Declaration public void Push(T item, int priority) Parameters Type Name Description T item System.Int32 priority Remarks Appends the provided item with its priority to the end of the underlying list. Time Complexity is O(n). Space Complexity is O(1) (amortized over multiple executions of Push(T, Int32) ). | Improve this Doc View Source Remove(T) Declaration public PrioritizedItem<T>? Remove(T item) Parameters Type Name Description T item Returns Type Description System.Nullable < MoreStructures.PriorityQueues.PrioritizedItem <T>> Remarks Linearly scans the underlying list looking for the index of the item equals to the provided item ( System.Object.Equals(System.Object, System.Object) is used to compare the two items of type T ). If multiple occurrences of item are present with the same highest priority, the one with the lowest is selected, to guarantee stability . If no such index is found, nothing is changed and null is returned. Otherwise the item at such position is removed from the list and returned as result. Time Complexity is O(n * Teq) and Space Complexity is O(Seq), where Teq and Seq are the time and space cost of comparing two items of type T . | Improve this Doc View Source UpdatePriority(T, Int32) Declaration public PrioritizedItem<T> UpdatePriority(T item, int newPriority) Parameters Type Name Description T item System.Int32 newPriority Returns Type Description MoreStructures.PriorityQueues.PrioritizedItem <T> Remarks Linearly scans the underlying list looking for the index of the item equals to the provided item ( System.Object.Equals(System.Object, System.Object) is used to compare the two items of type T ) with the highest priority . If multiple occurrences of item are present with the same highest priority, the one with the lowest is selected, to guarantee stability . If no occurrence of item is found, a is raised. Then replaces the MoreStructures.PriorityQueues.PrioritizedItem<T> at such index with a new one having same and , but set to newPriority . Finally returns the previously stored MoreStructures.PriorityQueues.PrioritizedItem<T> at that index. Time Complexity is O(n * Teq) and Space Complexity is O(Seq), where Teq and Seq are the time and space cost of comparing two items of type T . Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description System.Collections.IEnumerator Remarks Implements IUpdatablePriorityQueue<T> IPeekKthPriorityQueue<T> IMergeablePriorityQueue<T, TPQTarget> IPriorityQueue<T> IEnumerable<> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) UpdatablePriorityQueueExtensions.PushOrUpdate<T>(IUpdatablePriorityQueue<T>, T, Int32) UpdatablePriorityQueueExtensions.PopAll<T>(IPriorityQueue<T>)"
  },
  "api/MoreStructures.PriorityQueues.ArrayList.html": {
    "href": "api/MoreStructures.PriorityQueues.ArrayList.html",
    "title": "Namespace MoreStructures.PriorityQueues.ArrayList",
    "keywords": "Namespace MoreStructures.PriorityQueues.ArrayList Classes ArrayListPriorityQueue<T> An IPriorityQueue<T> implementation based on an unsorted list of its items. On top of basic operations it also supports IUpdatablePriorityQueue<T> , IPeekKthPriorityQueue<T> and IMergeablePriorityQueue<T, TPQTarget> . operations."
  },
  "api/MoreStructures.PriorityQueues.BinaryHeap.BinaryHeapListWrapper-1.html": {
    "href": "api/MoreStructures.PriorityQueues.BinaryHeap.BinaryHeapListWrapper-1.html",
    "title": "Class BinaryHeapListWrapper<T>",
    "keywords": "Class BinaryHeapListWrapper<T> A wrapper around a , which preserve the max heap property on the subset of items of the list, at the beginning or at the end of it. Inheritance System.Object BinaryHeapListWrapper<T> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.PriorityQueues.BinaryHeap Assembly : MoreStructures.dll Syntax public sealed class BinaryHeapListWrapper<T> Type Parameters Name Description T The type of items in the wrapped list. Remarks Heap items are either stored: from index 0 to HeapCount - 1, i.e. at the beginning of the list, or from index ListCount - HeapCount to ListCount - 1, i.e. at the end. That leaves a buffer of ListCount - HeapCount items, either at the end or at the beginning of the list. The functionalities of this wrapper can be used to support HeapSort or a priority queue based on a Max Binary Heap. In the first case the buffer area is used (to store already sorted items). In the second case it is not. Constructors | Improve this Doc View Source BinaryHeapListWrapper(IList<T>, IComparer<T>, Int32, Boolean, Int32) Built around the provided items . Declaration public BinaryHeapListWrapper(IList<T> items, IComparer<T> comparer, int count, bool storeHeapAtTheEnd = false, int indexDelta = 0) Parameters Type Name Description IList <T> items The of items to be wrapped. IComparer <T> comparer The comparer to be used to establish a order relationship between items. System.Int32 count The size of the subset of items to be kept in order according to the max heap property. Goes from index 0 to index count - 1. Current size must be non-bigger than the . System.Boolean storeHeapAtTheEnd Whether heap items should be stored at the beginning or at the end of the items list. By default heap items are stored at the beginning (root at index 0) and buffer are is at the end. System.Int32 indexDelta The delta, positive or negative, with which heap items will be stored in the items list, w.r.t. the beginning (if storeHeapAtTheEnd is false ) or the end (if storeHeapAtTheEnd is true ) of the list. By default it is zero (i.e. no displacement). | Improve this Doc View Source BinaryHeapListWrapper(BinaryHeapListWrapper<T>) Built from the provided BinaryHeapListWrapper<T> source . Declaration public BinaryHeapListWrapper(BinaryHeapListWrapper<T> source) Parameters Type Name Description BinaryHeapListWrapper <T> source Properties | Improve this Doc View Source HeapCount The number of items in the heap only, buffer area of the underlying list excluded. Declaration public int HeapCount { get; } Property Value Type Description System.Int32 Remarks May be smaller than the current of the underlying , which in turn may be smaller than the current Length of the underlying . | Improve this Doc View Source Item[Int32] Retrieves the index -th item in the underlying list (heap or buffer). Declaration public T this[int index] { get; set; } Parameters Type Name Description System.Int32 index A non-negative System.Int32 . It can be non-smaller than HeapCount , if an element of the buffer is being accessed, but it necessarily has to be smaller than the of the underlying . Property Value Type Description T The item, an instance of type T . | Improve this Doc View Source ListCount The number of items in the underlying list, heap and buffer are included. Declaration public int ListCount { get; } Property Value Type Description System.Int32 Remarks It's always non-smaller than HeapCount , since all the heap items are contained in the underlying list. | Improve this Doc View Source RaiseItemPopping Invoked just before an item is removed from MoreStructures.PriorityQueues.BinaryHeap.BinaryHeapListWrapper`1.Items (at the beginning of the heap), and before \"sifting down\" procedure is performed. Declaration public Action<int, int> RaiseItemPopping { get; set; } Property Value Type Description Action < System.Int32 , System.Int32 > Remarks The actual index of the item pushed may be different than 0, if the heap is stored in reverse, in which case it is equal to ListCount - 1. Same applies to the index of the item pushed out of the heap (but still in the list, in the buffer area). | Improve this Doc View Source RaiseItemPushed Invoked just after an item has been pushed into MoreStructures.PriorityQueues.BinaryHeap.BinaryHeapListWrapper`1.Items (at the end of the heap), and before the \"sifting up\" procedure is performed. Declaration public Action<int> RaiseItemPushed { get; set; } Property Value Type Description Action < System.Int32 > Remarks The actual index of the item pushed will be different than ListCount - 1, if ListCount is different than HeapCount , or if the heap is stored in reverse. | Improve this Doc View Source RaiseItemsSwapped Invoked just after two items have been swapped of position in MoreStructures.PriorityQueues.BinaryHeap.BinaryHeapListWrapper`1.Items . Declaration public Action<int, int> RaiseItemsSwapped { get; set; } Property Value Type Description Action < System.Int32 , System.Int32 > Methods | Improve this Doc View Source Clear() Clears the underlying list (heap and buffer), wiping all its items out, if the list is not readonly. If it is readonly (e.g. an array), it just resets the HeapCount . Declaration public void Clear() | Improve this Doc View Source GetEnumerator() Returns an enumerator of T instances, going through all items of the underlying list, not just the first HeapCount items which form the heap, but also the buffer area at the end of the underlying list. Declaration public IEnumerator<T> GetEnumerator() Returns Type Description IEnumerator <T> An of T . | Improve this Doc View Source Peek() Peeks the item with max priority from the root of the heap, if any. Declaration public T Peek() Returns Type Description T | Improve this Doc View Source PeekKth(Int32) Retrieves the item of the heap with priority k , without extracting any of the items in the heap. Declaration public (T result, bool valid) PeekKth(int k) Parameters Type Name Description System.Int32 k The non-negative priority rank: 0 means highest priority, 1 second highest, etc. Returns Type Description System.ValueTuple <T, System.Boolean > The item with k-th highest priority if any, with true as valid flag. The default for T otherwise, with false as valid flag. | Improve this Doc View Source Pop() Pops the item with max priority from the root of the heap, if any, moving the last leaf to the now vacant root and sifting it down until the heap property is restored. Declaration public T Pop() Returns Type Description T The popped item. | Improve this Doc View Source PopAll() Pops all items of the heap in sequence, from the one with highest priority to the one with lowest priority. Declaration public IEnumerable<T> PopAll() Returns Type Description IEnumerable <T> A sequence of T instances. | Improve this Doc View Source Push(T, Boolean) Pushes the provided item into the heap, sifting it up until the max heap property is restored. Declaration public void Push(T item, bool siftUp = true) Parameters Type Name Description T item The item to be added to the heap. System.Boolean siftUp Whether the sift up procedure should be executed or not. By default it is set to true . If it is not executed, the max heap property will be temporary violated. The push may fail if the heap is stored at the back of the list and grows backwards (which is the layout applied when MoreStructures.PriorityQueues.BinaryHeap.BinaryHeapListWrapper`1.StoreHeapAtTheEnd is set to true ), if the buffer is empty (i.e. if the last leaf of the heap has reached the front of the list, and adding a new leaf would require adding an element before the position 0 of the list). The push never fails when the heap is stored at the front of the list and grows forwards, because the list is able to grow at the back. | Improve this Doc View Source RestoreHeapProperty() Restores the max heap property, ensuring that each node of the heap is at least as big as its children, if any. Declaration public void RestoreHeapProperty() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.PriorityQueues.BinaryHeap.BinaryHeapPriorityQueue-1.html": {
    "href": "api/MoreStructures.PriorityQueues.BinaryHeap.BinaryHeapPriorityQueue-1.html",
    "title": "Class BinaryHeapPriorityQueue<T>",
    "keywords": "Class BinaryHeapPriorityQueue<T> An IPriorityQueue<T> implementation based on a Binary Max Heap of its items. On top of basic operations it also supports IPeekKthPriorityQueue<T> and IMergeablePriorityQueue<T, TPQTarget> . Inheritance System.Object BinaryHeapPriorityQueue<T> UpdatableBinaryHeapPriorityQueue<T> Implements IPeekKthPriorityQueue <T> IMergeablePriorityQueue <T, BinaryHeapPriorityQueue <T>> IPriorityQueue <T> IEnumerable <T> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.PriorityQueues.BinaryHeap Assembly : MoreStructures.dll Syntax public class BinaryHeapPriorityQueue<T> : IPeekKthPriorityQueue<T>, IMergeablePriorityQueue<T, BinaryHeapPriorityQueue<T>>, IPriorityQueue<T> Type Parameters Name Description T Remarks ADVANTAGES AND DISADVANTAGES - The Binary Max Heap is used to store items with their priorities, in a way that the item with max priority is immediately retrievable (making Peek() a constant-time operation), and easily extractable (making Pop() a logarithmic-time operation). - This comes a cost of the Push(T, Int32) operation, which is O(1) in ArrayListPriorityQueue<T> and becomes a logarithmic-time operation in this implementation. - So this implementation can be considered as a balanced compromise between insertion and extraction, which complexifies the underlying data structure and loses some performance in insertion to obtain all-around logarithmic performance. - Given the \"exponentially better\" runtime of logarithmic operations w.r.t. linear ones, such compromise makes sense for most scenarios. - Merging two Binary Max Heap structures, however, still requires linear time. If merging performance is critical, a more advanced tree-based implementation, such as BinomialHeapPriorityQueue<T> , FibonacciHeapPriorityQueue<T> and their derivations, should be used instead. BINARY MAX HEAP REPRESENTATION - The Binary Max Heap used for items and priorities is backed by a complete Binary Tree, represented as an Array List of its items. - The root of the tree is always in position 0, its children in positions 1 and 2, grand-children in positions 3, 4, 5 and 6 (where 3 and 4 are children of 1 and 5 and 6 are children of 2), etc. - This is the most space-efficient layout for a complete tree, which allows O(1) root access, parent-to-child navigation and child-to-parent navigation, by performing simple indexing arithmetic. - The underlying Binary Tree is complete, hence balanced: it's height h is Math.Floor(log(n, 2)), where n is the number of nodes in the tree. For example a complete Binary Tree of 3 nodes has necessarily height 1, whereas one of 4 nodes has to have height 2. - While the Binary Tree is complete, it is non necessarily full, meaning that the last level may not be entirely filled with leaves and the number of leaves at the last level may vary from 1 up to 2^(h + 1) - 1. - All modification operations (such as Pop() ) done on the Binary Max Heap ensure that the tree is kept complete and balanced. REPEATED ITEMS AND PRIORITIES - Repeated items, as well as repeated priorities, are supported. - The implementation is stable both for priorities and items. - If two items I1 and I2 are pushed with the same priority P at times T1 and T2 with T1 < T2, when P becomes the highest priority in the heap, I1 is popped out of the heap before I2 is. - That also applies to the case where I1 and I2 are equal by value and different by reference. - Stability is achieved by keeping a \"push index\", i.e. a System.Int32 counter set to 0 in the constructor and incremented every time a new item is introduced in the queue via a Push(T, Int32) . - The push index is included in the heap item record, together with the item of type T and its priority of type System.Int32 . - This way two heap item records I1 and I2 with the same priority I1.Priority and I2.Priority, and potentially the same or equal items I1.Item and I2.Item, will necessarily differ by push index, I1.PushTimestamp and I2.PushTimestamp. - Therefore a total strict order can be imposed. Constructors | Improve this Doc View Source BinaryHeapPriorityQueue() Builds an empty priority queue. Declaration public BinaryHeapPriorityQueue() Remarks The underlying data structure for priorities and items is initialized to an empty structure. Therefore, Time and Space Complexity is O(1). | Improve this Doc View Source BinaryHeapPriorityQueue(BinaryHeapPriorityQueue<T>) Builds a new priority queue with the same items of the provided source . Declaration protected BinaryHeapPriorityQueue(BinaryHeapPriorityQueue<T> source) Parameters Type Name Description BinaryHeapPriorityQueue <T> source The BinaryHeapPriorityQueue<T> instance to use as a source of data. Remarks The underlying data structure is shallow copied. Because it is made of immutable records, a shallow-copy is enough to ensure that its mutation in source won't affect the new priority queue or viceversa. Because the data structure contain O(n) items, Time and Space Complexity are O(n), where n is the number of items in source . Properties | Improve this Doc View Source Count Declaration public virtual int Count { get; } Property Value Type Description System.Int32 Remarks Checks the count of the underlying heap. The size of the heap may be smaller than the size of the underlying list, if there is buffer at the end. Time and Space Complexity are O(1). | Improve this Doc View Source CurrentPushTimestamp A non-negative, zero-based, monotonically strictly increasing counter, incremented at every insertion into this data structure by a Push(T, Int32) . Declaration protected int CurrentPushTimestamp { get; set; } Property Value Type Description System.Int32 | Improve this Doc View Source Items The wrapped of MoreStructures.PriorityQueues.PrioritizedItem<T> backing the binary max heap. Declaration protected BinaryHeapListWrapper<PrioritizedItem<T>> Items { get; } Property Value Type Description BinaryHeapListWrapper < MoreStructures.PriorityQueues.PrioritizedItem <T>> Methods | Improve this Doc View Source Clear() Declaration public virtual void Clear() Remarks Just clears the underlying array list. The internal push timestamp counter is not reset, nor the era. Therefore, new pushes after the clear will receive push timestamps strictly higher than the ones assigned to the items in the queue before the clear. Time and Space Complexity are O(1). | Improve this Doc View Source GetEnumerator() Declaration public virtual IEnumerator<T> GetEnumerator() Returns Type Description System.Collections.IEnumerator <T> Remarks In order to return items in heap order (i.e. the max at each step), it first copies this priority queue into a second temporary queue, which can be mutated without affecting the state of this queue. It then iterates over the copy, calling Pop() until it becomes empty. Time Complexity is O(n * log(n)) (when fully enumerated), because a single Pop() on an complete binary heap takes logarithmic time, and there are n items to be extracted. Space Complexity is O(n), as a copy of this queue is required as auxiliary data structure to emit elements in the right order of priority. | Improve this Doc View Source MergeFrom(BinaryHeapPriorityQueue<T>) Declaration public virtual void MergeFrom(BinaryHeapPriorityQueue<T> targetPriorityQueue) Parameters Type Name Description BinaryHeapPriorityQueue <T> targetPriorityQueue Remarks ALGORITHM - Pushing all items in the targetPriorityQueue via Push(T, Int32) , would result in O(m * log(m)) Time Complexity, where m is the number of items in the targetPriorityQueue . - Instead, each of the m items from the targetPriorityQueue is added to the underlying array list of this queue, at the end. - Then, the content of targetPriorityQueue is cleared, to respect the contract defined by IMergeablePriorityQueue<T, TPQTarget> . - Finally, the heap property is restored globally for all items in the underlying array list, by sifting down all items in the first half of the list, proceeding backwards from the middle of the list to its first item. - Such global sift down is required for the first half of the items only, because the second half only contains leaves of the tree, for which a sift down would do nothing (i.e. the heap property is already satisfied). COMPLEXITY - Appending m items has a linear cost over m. - Clearing the target only takes constant time. - Restoring the heap property globally would seem to take n / 2 * log(n), where n is the total number of items in this queue, after the merge: the number of items to sift down plus the cost of sifting down the tree. That would give O(n * log(n)) complexity: not a real improvement over the naive approach of pushing n items. - However, the length of the path to sift down is not as big as the entire height of the tree. Instead, the closer the starting node is to the leave, the smaller it becomes: leaves have sift down paths of length 0, their parent of length 1, etc., up to the root, which has sift down path of length equal to the height of the tree. - A key observation is that in a complete and full tree there are more leaves than all nodes in other levels combined, and that applies to all levels w.r.t. all smaller levels. - So, sift down will cost less for way more nodes, resulting in overall O(n) Time Complexity. - Space Complexity is O(m), since m items are added to the list storing the items of this queue. | Improve this Doc View Source Peek() Declaration public virtual PrioritizedItem<T> Peek() Returns Type Description MoreStructures.PriorityQueues.PrioritizedItem <T> Remarks Peeks the item with max priority from the root of the heap, if any. That is located at index 0 in the underlying list, and can be accessed in constant-time. Therefore, Time and Space Complexity are O(1). | Improve this Doc View Source PeekKth(Int32) Declaration public virtual PrioritizedItem<T>? PeekKth(int k) Parameters Type Name Description System.Int32 k Returns Type Description System.Nullable < MoreStructures.PriorityQueues.PrioritizedItem <T>> Remarks ALGORITHM - If k is negative, an is returned. - If k is non-smaller than the Count , null is returned. - If k is 0, Peek() is returned. - Otherwise, the main algorithm loop is performed, at most k times. - A dedicated BinaryHeapPriorityQueue<T> C of System.Int32 values is instantiated. - The values of C are the indexes of the underlying list of this priority queue, and identify candidates for the k -th largest item. - Such candidates are sorted in C by priority and push timestamps, exactly in the same way they are sorted in this priority queue. - At the beginning only the root of the priority queue (i.e. index 0) is pushed to C. - At each iteration the max of C is popped from C and its left and right children (if any) are pushed into C. - After k iterations, the Peek() of C gives the k -th largest item. - Notice that C cannot run short of candidates (due to lack of children), because of the preconditions on k . COMPLEXITY - Checks on the value of k w.r.t. the size of this priority queue and direct access to the underlying list, to return the final result once the index has been found, are both done in constant time. - Candidates queue instantiation and 1st push into it are also constant time operations. - The main loop consist of k iterations. - At each iteration 1 item is popped and 2 are pushed, so the candidates queue grows of 1 item per cycle. - Each Pop() and Push(T, Int32) operation on the candidates queue has logarithmic run, since they are done on a BinaryHeapPriorityQueue<T> instance. - Therefore, Time Complexity is O(k * log(k)) and Space Complexity is O(k). | Improve this Doc View Source Pop() Declaration public virtual PrioritizedItem<T> Pop() Returns Type Description MoreStructures.PriorityQueues.PrioritizedItem <T> Remarks ALGORITHM - Peeks the first item from the heap and stores to return it as result. - Takes the last item of the heap and moves to the root, in first position. - Restores heap constraints by recursively sifting down new root, as many time as needed. COMPLEXITY - Peek() and removal of item with max priority and last leaf of the heap are all constant-time operations. - Since the heap is an complete binary tree, the heigh of the three is O(log(n)). - So the number of \"sift down\" operations is logarithmic w.r.t. the input. - Therefore, Time Complexity is O(log(n)) and Space Complexity is O(1), since modifications are all done in-place in underlying data structures. | Improve this Doc View Source Push(T, Int32) Declaration public virtual void Push(T item, int priority) Parameters Type Name Description T item System.Int32 priority Remarks Negative priorities are supported. ALGORITHM - Adds a new leaf to the heap, carrying priority, item and unique push index. - Restores heap constraints by recursively sifting up new leaf, as many time as needed. COMPLEXITY - Adding a new item with given priority and a leaf to the heap are constant-time operations. - Since the heap is an complete binary tree, the heigh of the three is O(log(n)). - So the number of \"sift up\" operations is logarithmic w.r.t. the input. - Therefore, Time Complexity is O(log(n)) and Space Complexity is O(1), since modifications are all done in-place in underlying data structure. | Improve this Doc View Source RaiseItemPopping(Int32, Int32) Invoked just before an item is removed from Items . Declaration protected virtual void RaiseItemPopping(int indexPopped, int indexInBufferArea) Parameters Type Name Description System.Int32 indexPopped The index of the item being popped. When the heap is at the beginning of the list (which is the layout used by this queue), it is equal to 0. System.Int32 indexInBufferArea The index of the item of the last leaf, which is going to be swapped with the root during pop. | Improve this Doc View Source RaiseItemPushed(Int32) Invoked just after an item has been pushed into Items . Declaration protected virtual void RaiseItemPushed(int indexPushed) Parameters Type Name Description System.Int32 indexPushed The index of the item being pushed. When the heap is at the beginning of the list (which is the layout used by this queue), it is equal to Count - 1 if the underlying list is fully utilized, and it's smaller than that otherwise (there is buffer at the end of the list, after the last item of the heap). | Improve this Doc View Source RaiseItemsSwapped(Int32, Int32) Invoked just after two items have been swapped of position in Items . Declaration protected virtual void RaiseItemsSwapped(int index1, int index2) Parameters Type Name Description System.Int32 index1 The index of the first item swapped. System.Int32 index2 The index of the second item swapped. Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description System.Collections.IEnumerator Remarks Implements IPeekKthPriorityQueue<T> IMergeablePriorityQueue<T, TPQTarget> IPriorityQueue<T> IEnumerable<> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) UpdatablePriorityQueueExtensions.PopAll<T>(IPriorityQueue<T>)"
  },
  "api/MoreStructures.PriorityQueues.BinaryHeap.html": {
    "href": "api/MoreStructures.PriorityQueues.BinaryHeap.html",
    "title": "Namespace MoreStructures.PriorityQueues.BinaryHeap",
    "keywords": "Namespace MoreStructures.PriorityQueues.BinaryHeap Classes BinaryHeapListWrapper<T> A wrapper around a , which preserve the max heap property on the subset of items of the list, at the beginning or at the end of it. BinaryHeapPriorityQueue<T> An IPriorityQueue<T> implementation based on a Binary Max Heap of its items. On top of basic operations it also supports IPeekKthPriorityQueue<T> and IMergeablePriorityQueue<T, TPQTarget> . UpdatableBinaryHeapPriorityQueue<T> A refinement of BinaryHeapPriorityQueue<T> which supports IUpdatablePriorityQueue<T> operations, such as retrieval and update of priorities and removal of items."
  },
  "api/MoreStructures.PriorityQueues.BinaryHeap.UpdatableBinaryHeapPriorityQueue-1.html": {
    "href": "api/MoreStructures.PriorityQueues.BinaryHeap.UpdatableBinaryHeapPriorityQueue-1.html",
    "title": "Class UpdatableBinaryHeapPriorityQueue<T>",
    "keywords": "Class UpdatableBinaryHeapPriorityQueue<T> A refinement of BinaryHeapPriorityQueue<T> which supports IUpdatablePriorityQueue<T> operations, such as retrieval and update of priorities and removal of items. Inheritance System.Object BinaryHeapPriorityQueue <T> UpdatableBinaryHeapPriorityQueue<T> Implements IPeekKthPriorityQueue <T> IMergeablePriorityQueue <T, BinaryHeapPriorityQueue <T>> IUpdatablePriorityQueue <T> IPriorityQueue <T> IEnumerable <T> Inherited Members BinaryHeapPriorityQueue<T>.CurrentPushTimestamp BinaryHeapPriorityQueue<T>.Items BinaryHeapPriorityQueue<T>.Count BinaryHeapPriorityQueue<T>.GetEnumerator() BinaryHeapPriorityQueue<T>.IEnumerable.GetEnumerator() BinaryHeapPriorityQueue<T>.Peek() BinaryHeapPriorityQueue<T>.Pop() BinaryHeapPriorityQueue<T>.Push(T, Int32) BinaryHeapPriorityQueue<T>.PeekKth(Int32) BinaryHeapPriorityQueue<T>.MergeFrom(BinaryHeapPriorityQueue<T>) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.PriorityQueues.BinaryHeap Assembly : MoreStructures.dll Syntax public sealed class UpdatableBinaryHeapPriorityQueue<T> : BinaryHeapPriorityQueue<T>, IPeekKthPriorityQueue<T>, IMergeablePriorityQueue<T, BinaryHeapPriorityQueue<T>>, IUpdatablePriorityQueue<T>, IPriorityQueue<T> Type Parameters Name Description T Remarks In order to support updates and deletions, two additional data structures are introduced: a Item2PT, mapping items I of type T to BinaryHeapPriorityQueue<T> instances, containing values of type System.Int32 , of MoreStructures.PriorityQueues.PrioritizedItem<T> instances containing I . a PT2Idx from values to indexes of type System.Int32 , into the backing list of the Binary Max Heap of this priority queue. Every time a request to remove or update an item I from the priority queue is made, Item2PT is used to retrieve all the values of MoreStructures.PriorityQueues.PrioritizedItem<T> instances with item. Those push timestamps can be multiple because the same item can be added multiple times to the queue. The push timestamps are organized themselves in per-item priority queues, with the same priority as the items in the main priority queue. This way, the push timestamp of highest priority for a given item can be peeked in constant time and extracted in logarithmic time. Once the timestamp of highest priority has been found, the corresponding index (if any) in the backing list of the Binary Max Heap of this priority queue can be found in constant time via the PT2Idx dictionary. Once the index is found, operations such as Remove(T) and UpdatePriority(T, Int32) can be executed in logarithmic time, since restoring heap properties after the modification of a single item of the heap requires a logarithmic number of sift down and/or sift up operations. The two dictionaries are kept up-to-date by implementing the extensibility points provided by BinaryHeapPriorityQueue<T> , after pushing, before popping and on items swapping. Methods | Improve this Doc View Source Clear() Declaration public override void Clear() Overrides MoreStructures.PriorityQueues.BinaryHeap.BinaryHeapPriorityQueue<T>.Clear() Remarks Clears the underlying array list and the additional dictionaries introduced to support updates and deletions. Time and Space Complexity is O(1). | Improve this Doc View Source GetPrioritiesOf(T) Declaration public IEnumerable<int> GetPrioritiesOf(T item) Parameters Type Name Description T item Returns Type Description IEnumerable < System.Int32 > Remarks ALGORITHM - First, the priority queue of push timestamps for the provided item is retrieved from the dictionary of per-item queues of push timestamps. - If such a queue is not found, item is not present in the main priority queue, and an empty sequence is returned. - Otherwise, the queue is iterated over, getting the index corresponding to each timestamp extracted from the queue (where such index exists). - The index is used to make a direct access to the corresponding MoreStructures.PriorityQueues.PrioritizedItem<T> in the list backing the main priority queue. The priority is taken from . COMPLEXITY - Retrieving the priority queue of push timestamps from the dictionary of per-item priority queues is a O(1) operation. - Iterating such a priority queue requires duplicating the underlying data structure, which is a O(dup_factor) operation, where dup_factor is the average number of occurrences of an item in the data structure (1 means no duplicates, 2 means the item appears twice, etc.). - Retrieving the index from the push timestamp and the priority from the MoreStructures.PriorityQueues.PrioritizedItem<T> instance are both constant-time operations. - Therefore Time and Space Complexity are O(dup_factor). | Improve this Doc View Source RaiseItemPopping(Int32, Int32) Invoked just before an item is removed from Items . Declaration protected override void RaiseItemPopping(int indexPopped, int indexInBufferArea) Parameters Type Name Description System.Int32 indexPopped The index of the item being popped. When the heap is at the beginning of the list (which is the layout used by this queue), it is equal to 0. System.Int32 indexInBufferArea The index of the item of the last leaf, which is going to be swapped with the root during pop. Overrides MoreStructures.PriorityQueues.BinaryHeap.BinaryHeapPriorityQueue<T>.RaiseItemPopping(System.Int32, System.Int32) | Improve this Doc View Source RaiseItemPushed(Int32) Invoked just after an item has been pushed into Items . Declaration protected override void RaiseItemPushed(int indexPushed) Parameters Type Name Description System.Int32 indexPushed The index of the item being pushed. When the heap is at the beginning of the list (which is the layout used by this queue), it is equal to Count - 1 if the underlying list is fully utilized, and it's smaller than that otherwise (there is buffer at the end of the list, after the last item of the heap). Overrides MoreStructures.PriorityQueues.BinaryHeap.BinaryHeapPriorityQueue<T>.RaiseItemPushed(System.Int32) | Improve this Doc View Source RaiseItemsSwapped(Int32, Int32) Invoked just after two items have been swapped of position in Items . Declaration protected override void RaiseItemsSwapped(int index1, int index2) Parameters Type Name Description System.Int32 index1 The index of the first item swapped. System.Int32 index2 The index of the second item swapped. Overrides MoreStructures.PriorityQueues.BinaryHeap.BinaryHeapPriorityQueue<T>.RaiseItemsSwapped(System.Int32, System.Int32) | Improve this Doc View Source Remove(T) Declaration public PrioritizedItem<T>? Remove(T item) Parameters Type Name Description T item Returns Type Description System.Nullable < MoreStructures.PriorityQueues.PrioritizedItem <T>> Remarks ALGORITHM - The priority queue of push timestamps for the provided item is retrieved from the dictionary of per-item queues of push timestamps. - If such a priority queue is not found, it means that item is not present in the main priority queue either. So, null is returned. - If the priority queue is found, push timestamps are popped from it until the root of the priority queue contains a valid timestamp ts, i.e. a timestamp present in the dictionary mapping timestamps to indexes. - If such a timestamp is not found, it means that that item used to be present in the main priority, but it is not anymore. So, null is returned. - If such a timestamp is found, the backing list L for the main priority queue can be accessed via the index i, corresponding to the timestamp ts, simply by L[i] . L[i] represents the item to be removed. - The priority of L[i] is set to the highest priority in the queue + 1 and the item is made sift up to the root, due to its new priority being the highest in the heap. - Finally, the item, now at the root of the heap, is removed via a Pop() . COMPLEXITY - Retrieving the priority queue associated with the item is a O(1) operation. - Finding the right push timestamp may require a number of Pop() proportional to the number of times the priority of item has been changed. - In the worst case, such number is equal to the number of insertion of item . - Changing the priority of the MoreStructures.PriorityQueues.PrioritizedItem<T> to remove requires constant work. - Sifting it up to the root and then popping it are both logarithmic in time and constant in space. - Therefore, Time Complexity is O(log(n) + dup_factor) and Space Complexity is O(1), where dup_factor is the average number of occurrences of an item in the data structure (1 means no duplicates, 2 means the item appears twice, etc.). | Improve this Doc View Source UpdatePriority(T, Int32) Declaration public PrioritizedItem<T> UpdatePriority(T item, int newPriority) Parameters Type Name Description T item System.Int32 newPriority Returns Type Description MoreStructures.PriorityQueues.PrioritizedItem <T> Remarks ALGORITHM - It first removes the provided item from the queue via Remove(T) . - Then, it pushes the same item with newPriority via Push(T, Int32) . - Finally it returns the MoreStructures.PriorityQueues.PrioritizedItem<T> removed in the first step. COMPLEXITY - Both Remove(T) and Push(T, Int32) have logarithmic Time Complexity and constant Space Complexity. - Therefore, Time Complexity is O(log(n) + dup_factor) and Space Complexity is O(1), where dup_factor is the average number of occurrences of an item in the data structure (1 means no duplicates, 2 means the item appears twice, etc.). Implements IPeekKthPriorityQueue<T> IMergeablePriorityQueue<T, TPQTarget> IUpdatablePriorityQueue<T> IPriorityQueue<T> IEnumerable<> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) UpdatablePriorityQueueExtensions.PushOrUpdate<T>(IUpdatablePriorityQueue<T>, T, Int32) UpdatablePriorityQueueExtensions.PopAll<T>(IPriorityQueue<T>)"
  },
  "api/MoreStructures.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueue-1.html": {
    "href": "api/MoreStructures.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueue-1.html",
    "title": "Class BinomialHeapPriorityQueue<T>",
    "keywords": "Class BinomialHeapPriorityQueue<T> An IPriorityQueue<T> implementation based on a Binomial Max Heap of its items. It also supports IMergeablePriorityQueue<T, TPQTarget> operations. Inheritance System.Object BinomialHeapPriorityQueue<T> UpdatableBinomialHeapPriorityQueue<T> FibonacciHeapPriorityQueue<T> Implements IMergeablePriorityQueue <T, BinomialHeapPriorityQueue <T>> IPriorityQueue <T> IEnumerable <T> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.PriorityQueues.BinomialHeap Assembly : MoreStructures.dll Syntax public class BinomialHeapPriorityQueue<T> : IMergeablePriorityQueue<T, BinomialHeapPriorityQueue<T>>, IPriorityQueue<T> Type Parameters Name Description T Remarks DEFINITION - A Binomial Heap is a forest of n-ary trees , each respecting the heap max property , having a binomial layout and unicity of degree . - A tree respects the heap max property when each node has a value to be non-smaller than all its children (and, by transitivity, its grand-children, grand-grand-children etc.). - A tree has a binomial layout when is in the set of tree defined in the following constructive way: a singleton tree is a binomial tree of degree 0, a binomial tree of degree k + 1 is obtained merging two binomial trees of degree k, so that the root of one becomes immediate child of the root of the other. - A tree has unicity of degree when it is the only tree in the forest having its degree, which is the number of children it has. That means that there can be a single tree with 0 children (singleton), a single tree with 1 child, etc. ADVANTAGES AND DISADVANTAGES - This heap implementation is conceptually extending BinaryHeapPriorityQueue<T> , making heaps easily mergeable (i.e. in less time than O(n). - Binary Heaps provide logarithmic insertion and extraction. They can also provide linear construction, when the data is provided in batch and not online. - However, Binary Heap have O(n * log(n)) Time Complexity in merge. Merging the smaller heap into the bigger one, in the worst case the two heaps being merged have comparable size n / 2, resulting into an overall O(n / 2 * log(n / 2)) = O(n * log(n)) Time Complexity. - Merging the underlying arrays and building the new Binary Heap in batch would improve performance, yielding O(n) Time Complexity. Still an expensive operation, as it means going through all elements of one heap. - Binomial Heaps overcome this limitation and offer sub-linear performance by taking advantage of both the linked list layout and the tree layout, and taking the best of both worlds. - So the underlying idea behind Binomial Heaps is to combine linked lists and trees, and represent the data as a forest of n-ry heap trees (respecting the binomial layout), which can be easily merged together into a single Binomial Heap, due to their \"recurrent\" structure. - While Push(T, Int32) and Pop() retain logarithmic complexity, merging also becomes a logarithmic operation. Constructors | Improve this Doc View Source BinomialHeapPriorityQueue() Builds an empty priority queue. Declaration public BinomialHeapPriorityQueue() | Improve this Doc View Source BinomialHeapPriorityQueue(BinomialHeapPriorityQueue<T>) Builds a deep, separate copy of the provided source priority queue. Declaration protected BinomialHeapPriorityQueue(BinomialHeapPriorityQueue<T> source) Parameters Type Name Description BinomialHeapPriorityQueue <T> source The priority queue to be copied over. Remarks Doesn't copy the items themselves, it only deep-copies the internal structure of the source queue. Warning: push timestamp eras are shared between items of the two queues! To be used only for GetEnumerator() support. Properties | Improve this Doc View Source Count Declaration public virtual int Count { get; } Property Value Type Description System.Int32 Remarks Checks the count internally stored, keeping track of the sum of the size of all trees in the linked list. Time and Space Complexity are O(1). | Improve this Doc View Source CurrentPushTimestamp A non-negative, zero-based, monotonically strictly increasing counter, incremented at every insertion into this data structure by a Push(T, Int32) . Declaration protected int CurrentPushTimestamp { get; set; } Property Value Type Description System.Int32 | Improve this Doc View Source ItemsCount The total number of items in this queue. Declaration protected int ItemsCount { get; set; } Property Value Type Description System.Int32 | Improve this Doc View Source MaxRootsListNode Reference to the tree root in the forest with the highest priority. Makes Peek O(1). Declaration protected LinkedListNode<TreeNode<T>>? MaxRootsListNode { get; set; } Property Value Type Description System.Nullable < LinkedListNode < TreeNode <T>>> | Improve this Doc View Source PushTimestampEras The eras in which all push timestamps created by this instance (e.g. on push), or merged into this instance, leave in. The last in the list is the current one. Declaration protected IList<PushTimestampEra> PushTimestampEras { get; } Property Value Type Description System.Collections.IList < PushTimestampEra > Remarks By default, initialized to a singleton list containing the era \"0\". Depending on the implementation, may be relevant in merging. | Improve this Doc View Source Roots A of all the roots of the forest representing the heap. Declaration protected LinkedList<TreeNode<T>> Roots { get; } Property Value Type Description LinkedList < TreeNode <T>> Methods | Improve this Doc View Source AddRoot(TreeNode<T>) Adds a brand new TreeNode<T> to the heap, as a new root in the forest. Declaration protected void AddRoot(TreeNode<T> newRoot) Parameters Type Name Description TreeNode <T> newRoot The new root. | Improve this Doc View Source AttachToRoots(TreeNode<T>) Attaches the provided TreeNode<T> to the Roots . Declaration protected LinkedListNode<TreeNode<T>> AttachToRoots(TreeNode<T> newRoot) Parameters Type Name Description TreeNode <T> newRoot A node with no parent, and not already a root. Returns Type Description LinkedListNode < TreeNode <T>> The of Roots pointing to the newRoot . | Improve this Doc View Source Clear() Declaration public virtual void Clear() Remarks First, calls RaiseItemsClearing() . Then, removes all the trees from the forest, reset to the items count to 0 and set the reference to the max priority root to null . The internal push timestamp counter is not reset, nor the era. Therefore, new pushes after the clear will receive push timestamps strictly higher than the ones assigned to the items in the queue before the clear. Time and Space Complexity are O(1), with RaiseItemsClearing() assumed to be O(1). | Improve this Doc View Source DetachFromRoots(LinkedListNode<TreeNode<T>>) Detaches the TreeNode<T> pointed by the provided rootsListNode from the Roots . Declaration protected TreeNode<T> DetachFromRoots(LinkedListNode<TreeNode<T>> rootsListNode) Parameters Type Name Description LinkedListNode < TreeNode <T>> rootsListNode The of Roots , pointing to the TreeNode<T> root. Returns Type Description TreeNode <T> The detached TreeNode<T> root. | Improve this Doc View Source GetEnumerator() Declaration public virtual IEnumerator<T> GetEnumerator() Returns Type Description System.Collections.IEnumerator <T> Remarks In order to return items in heap order (i.e. the max at each step), it first copies this priority queue into a second temporary queue, which can be mutated without affecting the state of this queue. It then iterates over the copy, calling Pop() until it becomes empty. Time Complexity is O(n * log(n)) (when fully enumerated), because a single Pop() on a Binomial Heap takes logarithmic time, and there are n items to be extracted. Space Complexity is O(n), as a copy of this queue is required as auxiliary data structure to emit elements in the right order of priority. | Improve this Doc View Source MergeEquiDegreeTrees() Merges all trees of the Roots forest with the same degree (number of children of the root). Declaration protected virtual void MergeEquiDegreeTrees() | Improve this Doc View Source MergeFrom(BinomialHeapPriorityQueue<T>) Declaration public virtual void MergeFrom(BinomialHeapPriorityQueue<T> targetPriorityQueue) Parameters Type Name Description BinomialHeapPriorityQueue <T> targetPriorityQueue Remarks ALGORITHM - Before the actual merge of roots, push timestamp eras need to be adjusted, to deal with potentially conflicting timestamps from the two queues without scanning through all items, which would take a linear amount of time. - In order to do so, the max push timestamp era M, between the current era of the source and the current era of the target (the last in the list of eras of each), is calculated. - Then, all the push timestamp eras of the target are mutated (i.e. by a set accessor on the instance) in order (from the first = the older, to the last = the most recent) to M + 1, M + 2, ... - This way all items of the target are considered as added after all current items of the source, and keep the order they had in the target between themselves, before the merge. - Then, a new current push timestamp era of the source is added (i.e. new instance) with a new push timestamp era set to M + N + 1, so that all items of the source coming after the merge are considered as added after all items of the target added during merge. - After that, the algorithm iterates over all the roots of the target heap. - Add each root R to the linked list of roots of the source heap and increases the total items count of the source heap by the number of items in R, which can be calculated without traversing, from the number of immediate children c of R as 2^c, being R a binomial tree. tree. - For each added root, RaiseRootMerged(TreeNode<T>) is invoked. - Then binomial heap shape is restored by merging together all trees with the same degree and a new linear scan of the root is done, to update the reference to the root with highest priority, exactly as in Push(T, Int32) and Pop() . - To separate avoid interferences between this queue and the targetPriorityQueue , the targetPriorityQueue is cleared of all its items. - Its current push timestamp is left unchanged and the push timestamp eras are cleared and set to a new single instance with the same era value it had before the merge. This way all new items in the targetPriorityQueue will share the reference to the new era object, and wont interfere with the era object of all items moved to this priority queue. COMPLEXITY - For this analysis, events, and in particular RaiseRootMerged(TreeNode<T>) , are considered O(1) both in Time and Space Complexity. - The number of roots of the target heap is logarithmic with the number m of items in the target heap. - Adding each root R of the target heap to the forest of the source heap and increasing the items count are both constant-time operations. - Housekeeping operations, done after that on the source heap, take logarithmic time, as explained in Pop() . - Clearing the target is also a constant-time operation. - Therefore, Time and Space Complexity are O(log(m)). | Improve this Doc View Source MergeRoots(LinkedListNode<TreeNode<T>>, LinkedListNode<TreeNode<T>>) Merges the two provided trees of the forest into a single one, preserving the heap property. Declaration protected LinkedListNode<TreeNode<T>> MergeRoots(LinkedListNode<TreeNode<T>> first, LinkedListNode<TreeNode<T>> second) Parameters Type Name Description LinkedListNode < TreeNode <T>> first The of Roots pointing to the root of the first tree to merge. LinkedListNode < TreeNode <T>> second The of Roots pointing to the root of the second tree to merge. Returns Type Description LinkedListNode < TreeNode <T>> The of Roots pointing to the root of the merged tree: either first or second , depending on the MoreStructures.PriorityQueues.PrioritizedItem<T> stored in the PrioritizedItem of . | Improve this Doc View Source Peek() Declaration public virtual PrioritizedItem<T> Peek() Returns Type Description MoreStructures.PriorityQueues.PrioritizedItem <T> Remarks Peeks the item of the linked list pointed by the \"max root\" internal property. By transitivity, the item of the max root contains the max item in the queue, since all roots are non-smaller than their descendants. Therefore, Time and Space Complexity are O(1). | Improve this Doc View Source Pop() Declaration public virtual PrioritizedItem<T> Pop() Returns Type Description MoreStructures.PriorityQueues.PrioritizedItem <T> Remarks ALGORITHM - The value of the tree root with highest priority is read, then the root is removed from the forest. - The orphan children of the removed root are promoted to being roots and added to the forest. - Then all trees with the same degree are merged together, where the root with lower priority becomes immediate child of the root with higher priority. - Merging is done efficiently by linearly scanning all the tree roots in the forest, and keeping an array A of tree roots indexed by their degree. - Every time a second tree with the same degree is encountered: if T1 has degree k and A[k] already references another tree T2 with degree k, T1 and T2 are merged into a tree whose root has degree k + 1, A[k] is reset and A[k + 1] is set. - After all equi-degree trees have been merged, a new linear scan of the root is done, to update the reference to the root with highest priority. COMPLEXITY - Removing the root with highest priority from the forest is a O(1) operation. - Promoting to roots all its children is proportional to the number of children, a root of the forest has. - In a Binomial Heap the max degree of the roots of the forest is logarithmic with the total number of items in the heap. Therefore, promotion of children to roots is a O(log(n)) operation. - Merging equi-degree trees requires a full scan of the roots in the forest. If the forest were made of a lot of shallow trees, that would result into a O(n) operation. - However, while Push(T, Int32) increases every time by 1 the count of trees, after n insertions in O(1), a single O(n) scan done by a Pop() would merge trees, making them logarithmic in number. - Updating the max root reference takes time proportional to the number of trees in the forest AFTER the merging. - Because the merging of equi-degree trees leaves a forest of trees all of different degrees, and the max degree is logarithmic with n, at the end of the merging procedure there can be at most a logarithmic number of different trees in the forest. - So the linear scan of tree roots in the forest to find the max root reference takes only a logarithmic amount of time. - Therefore, Time Complexity is O(log(n)). Space Complexity is also O(log(n)), since merging equi-degree trees requires instantiating an array index by degrees, and max degree is O(log(n)). | Improve this Doc View Source PromoteChildToRoot(TreeNode<T>) Promotes the provided TreeNode<T> , to being a root, detaching it from its current parent. Declaration protected virtual void PromoteChildToRoot(TreeNode<T> child) Parameters Type Name Description TreeNode <T> child A child of a node of a tree in the forest. | Improve this Doc View Source Push(T, Int32) Declaration public virtual void Push(T item, int priority) Parameters Type Name Description T item System.Int32 priority Remarks ALGORITHM - Adds a new singleton tree T (degree 0) to the forest, wrapping the provided item with its priority into an object R with no children, and wrapping R into a LLN, which represents the root of T. - Then all trees with the same degree are merged together, with the same procedure explained in the documentation of Pop() . - That ensures that the binomial shape of the forest (i.e. binomial trees all of different degrees) is preserved. Without merging, if a tree of degree 0 (i.e. a singleton tree) was already present before the push of the new root, the binomial heap property would have been violated. - After all equi-degree trees have been merged, a new linear scan of the root is done, to update the reference to the root with highest priority (so that Peek() will work correctly and in constant time). COMPLEXITY - Adding a new root to the forest of trees is a constant-time operation, since the root is added at the end of the linked list representing the forest, which keeps references to both ends of the chain of nodes. - Merging equi-degree trees, to restore the binomial shape of the heap forest, and updating the max root reference are both logarithmic operations in time. The merge also requires a space proportional to the logarithm of the number of items in the heap, to instantiate its data structure. - Check the complexity analysis of Pop() for further details. - Therefore, Time and Space Complexity are both O(log(n)). | Improve this Doc View Source RaiseItemPopping(TreeNode<T>) Invoked just before an item is removed from the heap. Declaration protected virtual void RaiseItemPopping(TreeNode<T> root) Parameters Type Name Description TreeNode <T> root The TreeNode<T> about to be removed from the heap. | Improve this Doc View Source RaiseItemPushed(TreeNode<T>) Invoked just after an item has been pushed into the heap (as a root). Declaration protected virtual void RaiseItemPushed(TreeNode<T> newRoot) Parameters Type Name Description TreeNode <T> newRoot The TreeNode<T> added to the heap. Remarks Not invoked on merging, for which RaiseRootMerged(TreeNode<T>) is invoked instead. | Improve this Doc View Source RaiseItemsClearing() Invoked just before the all the items in the heap are wiped out. Declaration protected virtual void RaiseItemsClearing() | Improve this Doc View Source RaiseRootMerged(TreeNode<T>) Invoked just after an heap tree has been added to the forest (root and all its descendants). Declaration protected virtual void RaiseRootMerged(TreeNode<T> root) Parameters Type Name Description TreeNode <T> root The root TreeNode<T> of the heap tree added to the forest. | Improve this Doc View Source UpdateMaxRootsListNode() Performs a linear scan of the roots and update the MaxRootsListNode with a reference to the root of max priority. Declaration protected void UpdateMaxRootsListNode() | Improve this Doc View Source UpdateMaxRootsListNodeAfterRootNewOrIncrease(LinkedListNode<TreeNode<T>>) Updates the reference to the max priority root to the provided rootsListNode , if that root has a higher priority than the value of the current max priority root. Declaration protected void UpdateMaxRootsListNodeAfterRootNewOrIncrease(LinkedListNode<TreeNode<T>> rootsListNode) Parameters Type Name Description LinkedListNode < TreeNode <T>> rootsListNode The root whose priority has been increased. Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description System.Collections.IEnumerator Remarks Implements IMergeablePriorityQueue<T, TPQTarget> IPriorityQueue<T> IEnumerable<> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) UpdatablePriorityQueueExtensions.PopAll<T>(IPriorityQueue<T>)"
  },
  "api/MoreStructures.PriorityQueues.BinomialHeap.DuplicatedItemsResolution-2.html": {
    "href": "api/MoreStructures.PriorityQueues.BinomialHeap.DuplicatedItemsResolution-2.html",
    "title": "Class DuplicatedItemsResolution<TItems, THeap>",
    "keywords": "Class DuplicatedItemsResolution<TItems, THeap> An object storing and keeping up-to-date the \" TItems to TreeNode<T> \" back-references, necessary to find back the TreeNode<T> in the heap with highest priority for a given item, without exposing iterators to the client. Inheritance System.Object DuplicatedItemsResolution<TItems, THeap> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.PriorityQueues.BinomialHeap Assembly : MoreStructures.dll Syntax public class DuplicatedItemsResolution<TItems, THeap> where THeap : IPriorityQueue<int>, new() Type Parameters Name Description TItems THeap A type constructor for an heap of System.Int32 . Needed to store all push timestamps for each item. Remarks In order to support updates and deletions of items, two additional data structures are introduced: a Item2PT, mapping items I of type TItems to THeap instances, containing values of type System.Int32 , of MoreStructures.PriorityQueues.PrioritizedItem<T> instances containing I . a PT2Idx from values to TreeNode<T> of type System.Int32 , into the backing THeap structure of this priority queue. Every time a request to remove or update an item I from the priority queue is made, Item2PT is used to retrieve all the values of MoreStructures.PriorityQueues.PrioritizedItem<T> instances with item. Those push timestamps can be multiple because the same item can be added multiple times to the queue. The push timestamps are organized themselves in per-item priority queues, with the same priority as the items in the main priority queue. This way, the push timestamp of highest priority for a given item can be peeked in constant time and extracted in logarithmic time. Once the timestamp of highest priority has been found, the corresponding TreeNode<T> (if any) in the backing THeap structure of this priority queue can be found in constant time via the PT2Idx dictionary. Methods | Improve this Doc View Source Clear() Clears the content of this object. Declaration public void Clear() | Improve this Doc View Source FindTreeNode(TItems) Retrieves the TreeNode<T> associated with the provided item in the queue, selecting the one of highest priority in case of duplicates (i.e. multiple occurrences of item within the priority queue). Declaration public TreeNode<TItems> FindTreeNode(TItems item) Parameters Type Name Description TItems item The item to be mapped to a TreeNode<T> . Returns Type Description TreeNode <TItems> The corresponding TreeNode<T> . Remarks ALGORITHM - TREENODE RETRIEVAL PART - The priority queue of push timestamps for the provided item is retrieved from the dictionary of per-item queues of push timestamps. - If such a priority queue is not found, it means that item is not present in the main priority queue either. So, an is thrown. - If the priority queue is found, push timestamps are popped from it until the root of the priority queue contains a valid timestamp ts, i.e. a timestamp present in the dictionary mapping timestamps to TreeNode<T> instances and the IsInAHeap . - If such a timestamp is not found, it means that that item used to be present in the main priority, but it is not anymore. So, an is thrown. - If such a timestamp is found, the MoreStructures.PriorityQueues.PrioritizedItem<T> can be accessed via the PrioritizedItem property. COMPLEXITY - TREENODE RETRIEVAL PART - Retrieving the priority queue associated with the item is a O(1) operation. - Finding the right push timestamp may require a number of Pop() proportional to the number of times the priority of item has been changed. - In the worst case, such number is equal to the number of insertion of item . - Therefore, Time Complexity is O(dup_factor) and Space Complexity is O(1), where dup_factor is the average number of occurrences of an item in the data structure (1 means no duplicates, 2 means the item appears twice, etc.). | Improve this Doc View Source GetPrioritiesOf(TItems) Returns all the priorities with which item is registered in the queue, sorted by highest to smallest. Declaration public IEnumerable<int> GetPrioritiesOf(TItems item) Parameters Type Name Description TItems item Returns Type Description IEnumerable < System.Int32 > The sequence of System.Int32 values, each being a priority. Remarks ALGORITHM - First, the priority queue of push timestamps for the provided item is retrieved from the dictionary of per-item queues of push timestamps. - If such a queue is not found, item is not present in the main priority queue, and an empty sequence is returned. - Otherwise, the queue is iterated over, getting the TreeNode<T> corresponding to each timestamp extracted from the queue, where such node is still in a heap (it may have been detached since). - The TreeNode<T> is used to make a direct access to the corresponding MoreStructures.PriorityQueues.PrioritizedItem<T> . The priority is taken from . COMPLEXITY - Retrieving the priority queue of push timestamps from the dictionary of per-item priority queues is a O(1) operation. - Iterating such a priority queue requires duplicating the underlying data structure, which is a O(dup_factor) operation, where dup_factor is the average number of occurrences of an item in the data structure (1 means no duplicates, 2 means the item appears twice, etc.). - Retrieving the TreeNode<T> from the push timestamp and the priority from the MoreStructures.PriorityQueues.PrioritizedItem<T> instance are both constant-time operations. - Therefore Time and Space Complexity are O(dup_factor), where dup_factor is the average number of occurrences of an item in the data structure (1 means no duplicates, 2 means the item appears twice, etc.). | Improve this Doc View Source RaiseItemPopping(TreeNode<TItems>) To be invoked just before the provided root is popped from the heap. Declaration public void RaiseItemPopping(TreeNode<TItems> root) Parameters Type Name Description TreeNode <TItems> root The root about to be popped from the heap forest. | Improve this Doc View Source RaiseItemPriorityChanged(TreeNode<TItems>, PrioritizedItem<TItems>) To be invoked just after the priority of a TreeNode<T> has changed. Declaration public void RaiseItemPriorityChanged(TreeNode<TItems> treeNode, PrioritizedItem<TItems> itemBefore) Parameters Type Name Description TreeNode <TItems> treeNode The node in the heap which has changed priority. MoreStructures.PriorityQueues.PrioritizedItem <TItems> itemBefore The MoreStructures.PriorityQueues.PrioritizedItem<T> as it was before the priority change. | Improve this Doc View Source RaiseItemPushed(TreeNode<TItems>) To be invoked just after a newRoot has been pushed into the heap. Declaration public void RaiseItemPushed(TreeNode<TItems> newRoot) Parameters Type Name Description TreeNode <TItems> newRoot The new root pushed into the heap forest. | Improve this Doc View Source RaiseItemsSwapped(TreeNode<TItems>, TreeNode<TItems>) Invoked just after two items have had their MoreStructures.PriorityQueues.PrioritizedItem<T> swapped. Declaration public void RaiseItemsSwapped(TreeNode<TItems> treeNode1, TreeNode<TItems> treeNode2) Parameters Type Name Description TreeNode <TItems> treeNode1 The first node. TreeNode <TItems> treeNode2 The second node. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.PriorityQueues.BinomialHeap.html": {
    "href": "api/MoreStructures.PriorityQueues.BinomialHeap.html",
    "title": "Namespace MoreStructures.PriorityQueues.BinomialHeap",
    "keywords": "Namespace MoreStructures.PriorityQueues.BinomialHeap Classes BinomialHeapPriorityQueue<T> An IPriorityQueue<T> implementation based on a Binomial Max Heap of its items. It also supports IMergeablePriorityQueue<T, TPQTarget> operations. DuplicatedItemsResolution<TItems, THeap> An object storing and keeping up-to-date the \" TItems to TreeNode<T> \" back-references, necessary to find back the TreeNode<T> in the heap with highest priority for a given item, without exposing iterators to the client. TreeNode<T> A node of a tree, root or non-root, in the underlying forest representing the heap. UpdatableBinomialHeapPriorityQueue<T> A refinement of BinomialHeapPriorityQueue<T> which supports IUpdatablePriorityQueue<T> operations, such as retrieval and update of priorities and removal of items."
  },
  "api/MoreStructures.PriorityQueues.BinomialHeap.TreeNode-1.html": {
    "href": "api/MoreStructures.PriorityQueues.BinomialHeap.TreeNode-1.html",
    "title": "Class TreeNode<T>",
    "keywords": "Class TreeNode<T> A node of a tree, root or non-root, in the underlying forest representing the heap. Inheritance System.Object TreeNode<T> TreeNodeTests.TreeNodeMock Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.PriorityQueues.BinomialHeap Assembly : MoreStructures.dll Syntax public class TreeNode<T> Type Parameters Name Description T Properties | Improve this Doc View Source Children A of the children of this node. Empty if leaf. Declaration public LinkedList<TreeNode<T>> Children { get; } Property Value Type Description LinkedList < TreeNode <T>> | Improve this Doc View Source IsALoser Whether this node has lost a child since last reset, and will be promoted to roots next time they will lose a child. Only applies to, and it is taken into account from, Fibonacci heaps. Declaration public bool IsALoser { get; set; } Property Value Type Description System.Boolean | Improve this Doc View Source IsInAHeap Whether this node is in the heap, either as a root or as a non-root node in a tree of the forest, or it is a dangling or detached node. Declaration public bool IsInAHeap { get; } Property Value Type Description System.Boolean | Improve this Doc View Source Parent A back-reference to the parent node. Null if a root. Declaration public TreeNode<T> Parent { get; set; } Property Value Type Description TreeNode <T> | Improve this Doc View Source ParentListNode A back-reference to the wrapper, in the of children of the Parent of this node. Null if a root. Declaration public LinkedListNode<TreeNode<T>>? ParentListNode { get; set; } Property Value Type Description System.Nullable < LinkedListNode < TreeNode <T>>> | Improve this Doc View Source PrioritizedItem The item of type T , with its priority and push timestamp. Declaration public PrioritizedItem<T> PrioritizedItem { get; set; } Property Value Type Description MoreStructures.PriorityQueues.PrioritizedItem <T> | Improve this Doc View Source RootsListNode A back-reference to the wrapper, in the of tree roots in the underlying forest representing the heap. Null if not a root. Declaration public LinkedListNode<TreeNode<T>>? RootsListNode { get; set; } Property Value Type Description System.Nullable < LinkedListNode < TreeNode <T>>> Methods | Improve this Doc View Source AddChild(TreeNode<T>) Add the provides treeNode to the Children of this instance. Declaration public void AddChild(TreeNode<T> treeNode) Parameters Type Name Description TreeNode <T> treeNode The TreeNode<T> instance to become a child. | Improve this Doc View Source DeepCopy() Deep copies this TreeNode<T> and its entire structure. Declaration public TreeNode<T> DeepCopy() Returns Type Description TreeNode <T> A new instance of TreeNode<T> , pointing to a new, separate but equivalent structure. Remarks This method is supposed to be used for a temporary copy of the heap, in order to iterate over it without modifying the original heap. It is not conceived to support full clones of a heap, such the one required by . It doesn't copy Parent for the top-level TreeNode<T> , nor its RootsListNode or ParentListNode : those have to be set, according to the scenario, by the caller of DeepCopy() . | Improve this Doc View Source DetachFromParent() Removes this node from the Children of its Parent . Declaration public void DetachFromParent() | Improve this Doc View Source ToString() Includes the PrioritizedItem , IsInAHeap and IsALoser . Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.PriorityQueues.BinomialHeap.UpdatableBinomialHeapPriorityQueue-1.html": {
    "href": "api/MoreStructures.PriorityQueues.BinomialHeap.UpdatableBinomialHeapPriorityQueue-1.html",
    "title": "Class UpdatableBinomialHeapPriorityQueue<T>",
    "keywords": "Class UpdatableBinomialHeapPriorityQueue<T> A refinement of BinomialHeapPriorityQueue<T> which supports IUpdatablePriorityQueue<T> operations, such as retrieval and update of priorities and removal of items. Inheritance System.Object BinomialHeapPriorityQueue <T> UpdatableBinomialHeapPriorityQueue<T> Implements IMergeablePriorityQueue <T, BinomialHeapPriorityQueue <T>> IUpdatablePriorityQueue <T> IPriorityQueue <T> IEnumerable <T> Inherited Members BinomialHeapPriorityQueue<T>.Roots BinomialHeapPriorityQueue<T>.ItemsCount BinomialHeapPriorityQueue<T>.MaxRootsListNode BinomialHeapPriorityQueue<T>.CurrentPushTimestamp BinomialHeapPriorityQueue<T>.PushTimestampEras BinomialHeapPriorityQueue<T>.Count BinomialHeapPriorityQueue<T>.GetEnumerator() BinomialHeapPriorityQueue<T>.IEnumerable.GetEnumerator() BinomialHeapPriorityQueue<T>.Peek() BinomialHeapPriorityQueue<T>.Push(T, Int32) BinomialHeapPriorityQueue<T>.Pop() BinomialHeapPriorityQueue<T>.MergeFrom(BinomialHeapPriorityQueue<T>) BinomialHeapPriorityQueue<T>.RaiseItemsClearing() BinomialHeapPriorityQueue<T>.RaiseRootMerged(TreeNode<T>) BinomialHeapPriorityQueue<T>.UpdateMaxRootsListNodeAfterRootNewOrIncrease(LinkedListNode<TreeNode<T>>) BinomialHeapPriorityQueue<T>.UpdateMaxRootsListNode() BinomialHeapPriorityQueue<T>.AddRoot(TreeNode<T>) BinomialHeapPriorityQueue<T>.AttachToRoots(TreeNode<T>) BinomialHeapPriorityQueue<T>.MergeEquiDegreeTrees() BinomialHeapPriorityQueue<T>.MergeRoots(LinkedListNode<TreeNode<T>>, LinkedListNode<TreeNode<T>>) BinomialHeapPriorityQueue<T>.DetachFromRoots(LinkedListNode<TreeNode<T>>) BinomialHeapPriorityQueue<T>.PromoteChildToRoot(TreeNode<T>) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.PriorityQueues.BinomialHeap Assembly : MoreStructures.dll Syntax public sealed class UpdatableBinomialHeapPriorityQueue<T> : BinomialHeapPriorityQueue<T>, IMergeablePriorityQueue<T, BinomialHeapPriorityQueue<T>>, IUpdatablePriorityQueue<T>, IPriorityQueue<T> Type Parameters Name Description T Remarks Check DuplicatedItemsResolution<TItems, THeap> for detailed informations about how the mapping between items of type T and heap nodes of type TreeNode<T> is performed, in presence of duplicates. Methods | Improve this Doc View Source Clear() Declaration public override void Clear() Overrides MoreStructures.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueue<T>.Clear() Remarks Clears the BinomialHeapPriorityQueue<T> structures and the additional DuplicatedItemsResolution<TItems, THeap> object introduced to support updates and deletions. Time and Space Complexity is O(1). | Improve this Doc View Source GetPrioritiesOf(T) Declaration public IEnumerable<int> GetPrioritiesOf(T item) Parameters Type Name Description T item Returns Type Description IEnumerable < System.Int32 > Remarks | Improve this Doc View Source RaiseItemPopping(TreeNode<T>) Declaration protected override void RaiseItemPopping(TreeNode<T> root) Parameters Type Name Description TreeNode <T> root Overrides MoreStructures.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueue<T>.RaiseItemPopping(MoreStructures.PriorityQueues.BinomialHeap.TreeNode<T>) Remarks Hands over to RaiseItemPopping(TreeNode<TItems>) . | Improve this Doc View Source RaiseItemPushed(TreeNode<T>) Declaration protected override void RaiseItemPushed(TreeNode<T> newRoot) Parameters Type Name Description TreeNode <T> newRoot Overrides MoreStructures.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueue<T>.RaiseItemPushed(MoreStructures.PriorityQueues.BinomialHeap.TreeNode<T>) Remarks Hands over to RaiseItemPushed(TreeNode<TItems>) . | Improve this Doc View Source Remove(T) Declaration public PrioritizedItem<T>? Remove(T item) Parameters Type Name Description T item Returns Type Description System.Nullable < MoreStructures.PriorityQueues.PrioritizedItem <T>> Remarks ALGORITHM - It first retrieves the max priority P from the max priority item the queue via Peek() . - Then, it updates the priority of the provided item via UpdatePriority(T, Int32) , setting it to P + 1 and making item the one with max priority. - Finally it pops the item via Pop() . COMPLEXITY - Peek() has constant Time and Space Complexity. - However, Pop() and UpdatePriority(T, Int32) have logarithmic Time Complexity. - Therefore, Time Complexity is O(log(n) + dup_factor) and Space Complexity is O(1). | Improve this Doc View Source UpdatePriority(T, Int32) Declaration public PrioritizedItem<T> UpdatePriority(T item, int newPriority) Parameters Type Name Description T item System.Int32 newPriority Returns Type Description MoreStructures.PriorityQueues.PrioritizedItem <T> Remarks ALGORITHM - BINOMIAL HEAP UPDATE PART - When the priority is higher or equal, the value of priority is updated and the node is sifted up the tree, until the heap property is restored. If the root of the tree is reached, the reference to the max priority is checked and potentially updated. - When the priority is lower, the value of priority is updated and the node is sifted down the tree, until the heap property is restored. If the node was a root, a linear scan of all the roots is made, to update the reference to the max priority, which may have changed due to the decrease in priority. - No merging is required, since no node has been added or removed from any of the tree of the heap forest. Nodes have been swapped by sift up or sift down procedures, but the shape of each tree, and so the layout of the forest, hasn't changed. Therefore the binomial heap shape hasn't been violated. - Finally, the MoreStructures.PriorityQueues.PrioritizedItem<T> before the update is returned as result. COMPLEXITY - BINOMIAL HEAP UPDATE PART - Sift up, sift down and linear scan of roots are all logarithmic operations in time and constant in space. - Therefore, Time Complexity is O(log(n)) and Space Complexity is O(1). COMPLEXITY - OVERALL - Time Complexity is O(log(n) + dup_factor) and Space Complexity is O(1). - Notice how this is higher than the Time Complexity for the corresponding functionality in a Fibonacci Heap, which supports both pushing and priority updating in constant time. Implements IMergeablePriorityQueue<T, TPQTarget> IUpdatablePriorityQueue<T> IPriorityQueue<T> IEnumerable<> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) UpdatablePriorityQueueExtensions.PushOrUpdate<T>(IUpdatablePriorityQueue<T>, T, Int32) UpdatablePriorityQueueExtensions.PopAll<T>(IPriorityQueue<T>)"
  },
  "api/MoreStructures.PriorityQueues.Extensions.html": {
    "href": "api/MoreStructures.PriorityQueues.Extensions.html",
    "title": "Namespace MoreStructures.PriorityQueues.Extensions",
    "keywords": "Namespace MoreStructures.PriorityQueues.Extensions Classes UpdatablePriorityQueueExtensions Extension methods for IUpdatablePriorityQueue<T> implementations."
  },
  "api/MoreStructures.PriorityQueues.Extensions.UpdatablePriorityQueueExtensions.html": {
    "href": "api/MoreStructures.PriorityQueues.Extensions.UpdatablePriorityQueueExtensions.html",
    "title": "Class UpdatablePriorityQueueExtensions",
    "keywords": "Class UpdatablePriorityQueueExtensions Extension methods for IUpdatablePriorityQueue<T> implementations. Inheritance System.Object UpdatablePriorityQueueExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.PriorityQueues.Extensions Assembly : MoreStructures.dll Syntax public static class UpdatablePriorityQueueExtensions Methods | Improve this Doc View Source PopAll<T>(IPriorityQueue<T>) Pops in sequence all items of the provided queue , returning the sequence of extracted items. Declaration public static IEnumerable<PrioritizedItem<T>> PopAll<T>(this IPriorityQueue<T> queue) Parameters Type Name Description IPriorityQueue <T> queue The IPriorityQueue<T> , to extract all items of. Returns Type Description IEnumerable < MoreStructures.PriorityQueues.PrioritizedItem <T>> A sequence of extracted MoreStructures.PriorityQueues.PrioritizedItem<T> , in order of priority. Type Parameters Name Description T The type of items in the queue. | Improve this Doc View Source PushOrUpdate<T>(IUpdatablePriorityQueue<T>, T, Int32) If the provided item already is in the queue , it updates its priority to the newPriority . Otherwise, it pushes the item in the queue , with the priority newPriority . Declaration public static PrioritizedItem<T>? PushOrUpdate<T>(this IUpdatablePriorityQueue<T> queue, T item, int newPriority) Parameters Type Name Description IUpdatablePriorityQueue <T> queue The IUpdatablePriorityQueue<T> instance to update. T item The item of type T to be pushed or updated. System.Int32 newPriority The new priority value. Returns Type Description System.Nullable < MoreStructures.PriorityQueues.PrioritizedItem <T>> The MoreStructures.PriorityQueues.PrioritizedItem<T> entry before the update, or null , if there was no entry of item before the update (and a push has been done instead). Type Parameters Name Description T The type of items of the queue . Remarks ALGORITHM - A Remove(T) of the provided item is attempted. - Then, a Push(T, Int32) of the same item is made, with the newPriority . - Finally, the removed item, if any, is returned as result. COMPLEXITY - Time Complexity is O(Tremove + Tpush) and Space Complexity is O(Sremove + Spush), where Tremove and Sremove are the time and space cost of Remove(T) and Tpush and Spush are the time and space cost of Push(T, Int32) , respectively."
  },
  "api/MoreStructures.PriorityQueues.FibonacciHeap.FibonacciHeapPriorityQueue-1.html": {
    "href": "api/MoreStructures.PriorityQueues.FibonacciHeap.FibonacciHeapPriorityQueue-1.html",
    "title": "Class FibonacciHeapPriorityQueue<T>",
    "keywords": "Class FibonacciHeapPriorityQueue<T> An IPriorityQueue<T> implementation based on a Fibonacci Max Heap of its items. Inheritance System.Object BinomialHeapPriorityQueue <T> FibonacciHeapPriorityQueue<T> UpdatableFibonacciHeapPriorityQueue<T> Implements IMergeablePriorityQueue <T, BinomialHeapPriorityQueue <T>> IPriorityQueue <T> IEnumerable <T> Inherited Members BinomialHeapPriorityQueue<T>.Roots BinomialHeapPriorityQueue<T>.ItemsCount BinomialHeapPriorityQueue<T>.MaxRootsListNode BinomialHeapPriorityQueue<T>.CurrentPushTimestamp BinomialHeapPriorityQueue<T>.PushTimestampEras BinomialHeapPriorityQueue<T>.Count BinomialHeapPriorityQueue<T>.IEnumerable.GetEnumerator() BinomialHeapPriorityQueue<T>.Peek() BinomialHeapPriorityQueue<T>.Pop() BinomialHeapPriorityQueue<T>.MergeFrom(BinomialHeapPriorityQueue<T>) BinomialHeapPriorityQueue<T>.Clear() BinomialHeapPriorityQueue<T>.RaiseItemPushed(TreeNode<T>) BinomialHeapPriorityQueue<T>.RaiseItemPopping(TreeNode<T>) BinomialHeapPriorityQueue<T>.RaiseItemsClearing() BinomialHeapPriorityQueue<T>.RaiseRootMerged(TreeNode<T>) BinomialHeapPriorityQueue<T>.UpdateMaxRootsListNodeAfterRootNewOrIncrease(LinkedListNode<TreeNode<T>>) BinomialHeapPriorityQueue<T>.UpdateMaxRootsListNode() BinomialHeapPriorityQueue<T>.AddRoot(TreeNode<T>) BinomialHeapPriorityQueue<T>.AttachToRoots(TreeNode<T>) BinomialHeapPriorityQueue<T>.MergeEquiDegreeTrees() BinomialHeapPriorityQueue<T>.MergeRoots(LinkedListNode<TreeNode<T>>, LinkedListNode<TreeNode<T>>) BinomialHeapPriorityQueue<T>.DetachFromRoots(LinkedListNode<TreeNode<T>>) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.PriorityQueues.FibonacciHeap Assembly : MoreStructures.dll Syntax public class FibonacciHeapPriorityQueue<T> : BinomialHeapPriorityQueue<T>, IMergeablePriorityQueue<T, BinomialHeapPriorityQueue<T>>, IPriorityQueue<T> Type Parameters Name Description T Remarks DEFINITION - A Fibonacci Heap is a Binomial Heap which has its heap max property and binomial layout invariants always satisfied, but can have unicity of degree temporarily invalidated (until next Pop() operation). - Nodes of the heaps can be flagged as losers , meaning that they have lost at least once a children, after its promotion to being a new root. ADVANTAGES AND DISADVANTAGES - This heap implementation is a Binomial Heap refinement which prioritises performance of Push(T, Int32) and update operations over Pop() . - It does so by taking advantage of both the linked list layout and the tree layout, pretty much like Binomial Heaps. - Implementations based on linked or array lists are really fast at insertion, because they don't internally keep the data sorted. However, extraction becomes expensive, for the very same reason that data is unsorted. - At the other end of the spectrum, trees are logarithmic at insertion, because they have to keep data at least partially sorted, at all time. Extraction, however, is very cheap. - So the underlying idea behind Fibonacci Heaps is to combine linked lists and trees, and represent the data as a forest of n-ry heap trees, exactly like Binomial Heaps, and exploit the easy insertion in linked list (which is not implemented by the standard Push into a Binomial Heap). - In doing so, both Push(T, Int32) and update becomes extremely fast, running in O(1) and O(1) amortized, respectively. - However, unlike ArrayListPriorityQueue<T> , Pop() doesn't become a O(n) operation. Instead, it retains logarithmic runtime. - This proves to be the best compromise for applications such as the Dijkstra algorithm (implemented in DijkstraShortestDistanceFinder ), which uses a priority queue to find the next best vertex. - Dijkstra algorithm performs O(e) PushOrUpdate<T>(IUpdatablePriorityQueue<T>, T, Int32) operations and O(v) Pop() operations, where e and v are the number of edges and vertices in the graph, respectively. - In dense graphs e is O(v^2), so the number of push/update operations is way higher than the number of pop operations, and it makes sense to optimize the former, at the cost of the latter. Constructors | Improve this Doc View Source FibonacciHeapPriorityQueue() Builds an empty priority queue. Declaration public FibonacciHeapPriorityQueue() | Improve this Doc View Source FibonacciHeapPriorityQueue(FibonacciHeapPriorityQueue<T>) Builds a deep, separate copy of the provided source priority queue. Declaration protected FibonacciHeapPriorityQueue(FibonacciHeapPriorityQueue<T> source) Parameters Type Name Description FibonacciHeapPriorityQueue <T> source The priority queue to be copied over. Remarks Doesn't copy the items themselves, it only deep-copies the internal structure of the source queue. Methods | Improve this Doc View Source GetEnumerator() Declaration public override IEnumerator<T> GetEnumerator() Returns Type Description IEnumerator <T> Overrides MoreStructures.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueue<T>.GetEnumerator() Remarks In order to return items in heap order (i.e. the max at each step), it first copies this priority queue into a second temporary queue, which can be mutated without affecting the state of this queue. It then iterates over the copy, calling Pop() until it becomes empty. Time Complexity is O(n * log(n)) (when fully enumerated), because a single Pop() on a Fibonacci Heap takes logarithmic time, and there are n items to be extracted. Space Complexity is O(n), as a copy of this queue is required as auxiliary data structure to emit elements in the right order of priority. | Improve this Doc View Source PromoteChildToRoot(TreeNode<T>) Promotes the provided TreeNode<T> , to being a root, detaching it from its current parent. Also, resets the \"loser\" flag of the child (behavior specific to Fibonacci Heaps). Declaration protected override void PromoteChildToRoot(TreeNode<T> child) Parameters Type Name Description TreeNode <T> child A child of a node of a tree in the forest. Overrides MoreStructures.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueue<T>.PromoteChildToRoot(MoreStructures.PriorityQueues.BinomialHeap.TreeNode<T>) | Improve this Doc View Source Push(T, Int32) Declaration public override void Push(T item, int priority) Parameters Type Name Description T item System.Int32 priority Overrides MoreStructures.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueue<T>.Push(T, System.Int32) Remarks ALGORITHM - Adds a new singleton tree T (degree 0) to the forest, wrapping the provided item with its priority into an object R with no children, and wrapping R into a LLN, which represents the root of T. - If LLN has higher priority than the root with max priority, updates the reference to the root with max priority, to point to LLN. - Unlike Push(T, Int32) , it doesn't perform any rebalancing of the forest just yet, meaning that the binomial property may be temporarily violated until the next Pop() operation. - The delay of \"housekeeping\" operations to restore the shape property of a binomial heap, and the grouping of such \"housekeeping\" operations into a single batch, executed at the next Pop() , is one of the core efficiency mechanisms of the Fibonacci Heap. COMPLEXITY - Adding a new root to the forest of trees is a constant-time operation, since the root is added at the end of the linked list representing the forest, which keeps references to both ends of the chain of nodes. - Therefore, Time Complexity and Space Complexity are O(1). - Notice that this operation executes in constant time at the cost of adding a new shallow tree to the forest. After n Push(T, Int32) consecutive operations, the forest would be made of n trees of degree 0, which is the shape of a simple heap based on a linked list. - This cost has to be beared by Pop() , which runs in logarithmic time but merges trees of the same degree and does so in batch. Implements IMergeablePriorityQueue<T, TPQTarget> IPriorityQueue<T> IEnumerable<> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) UpdatablePriorityQueueExtensions.PopAll<T>(IPriorityQueue<T>)"
  },
  "api/MoreStructures.PriorityQueues.FibonacciHeap.html": {
    "href": "api/MoreStructures.PriorityQueues.FibonacciHeap.html",
    "title": "Namespace MoreStructures.PriorityQueues.FibonacciHeap",
    "keywords": "Namespace MoreStructures.PriorityQueues.FibonacciHeap Classes FibonacciHeapPriorityQueue<T> An IPriorityQueue<T> implementation based on a Fibonacci Max Heap of its items. UpdatableFibonacciHeapPriorityQueue<T> A refinement of FibonacciHeapPriorityQueue<T> which supports IUpdatablePriorityQueue<T> operations, such as retrieval and update of priorities and removal of items."
  },
  "api/MoreStructures.PriorityQueues.FibonacciHeap.UpdatableFibonacciHeapPriorityQueue-1.html": {
    "href": "api/MoreStructures.PriorityQueues.FibonacciHeap.UpdatableFibonacciHeapPriorityQueue-1.html",
    "title": "Class UpdatableFibonacciHeapPriorityQueue<T>",
    "keywords": "Class UpdatableFibonacciHeapPriorityQueue<T> A refinement of FibonacciHeapPriorityQueue<T> which supports IUpdatablePriorityQueue<T> operations, such as retrieval and update of priorities and removal of items. Inheritance System.Object BinomialHeapPriorityQueue <T> FibonacciHeapPriorityQueue <T> UpdatableFibonacciHeapPriorityQueue<T> Implements IMergeablePriorityQueue <T, BinomialHeapPriorityQueue <T>> IUpdatablePriorityQueue <T> IPriorityQueue <T> IEnumerable <T> Inherited Members FibonacciHeapPriorityQueue<T>.GetEnumerator() FibonacciHeapPriorityQueue<T>.Push(T, Int32) FibonacciHeapPriorityQueue<T>.PromoteChildToRoot(TreeNode<T>) BinomialHeapPriorityQueue<T>.Roots BinomialHeapPriorityQueue<T>.ItemsCount BinomialHeapPriorityQueue<T>.MaxRootsListNode BinomialHeapPriorityQueue<T>.CurrentPushTimestamp BinomialHeapPriorityQueue<T>.PushTimestampEras BinomialHeapPriorityQueue<T>.Count BinomialHeapPriorityQueue<T>.IEnumerable.GetEnumerator() BinomialHeapPriorityQueue<T>.Peek() BinomialHeapPriorityQueue<T>.Pop() BinomialHeapPriorityQueue<T>.MergeFrom(BinomialHeapPriorityQueue<T>) BinomialHeapPriorityQueue<T>.RaiseItemsClearing() BinomialHeapPriorityQueue<T>.RaiseRootMerged(TreeNode<T>) BinomialHeapPriorityQueue<T>.UpdateMaxRootsListNodeAfterRootNewOrIncrease(LinkedListNode<TreeNode<T>>) BinomialHeapPriorityQueue<T>.UpdateMaxRootsListNode() BinomialHeapPriorityQueue<T>.AddRoot(TreeNode<T>) BinomialHeapPriorityQueue<T>.AttachToRoots(TreeNode<T>) BinomialHeapPriorityQueue<T>.MergeEquiDegreeTrees() BinomialHeapPriorityQueue<T>.MergeRoots(LinkedListNode<TreeNode<T>>, LinkedListNode<TreeNode<T>>) BinomialHeapPriorityQueue<T>.DetachFromRoots(LinkedListNode<TreeNode<T>>) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.PriorityQueues.FibonacciHeap Assembly : MoreStructures.dll Syntax public sealed class UpdatableFibonacciHeapPriorityQueue<T> : FibonacciHeapPriorityQueue<T>, IMergeablePriorityQueue<T, BinomialHeapPriorityQueue<T>>, IUpdatablePriorityQueue<T>, IPriorityQueue<T> Type Parameters Name Description T Remarks Check DuplicatedItemsResolution<TItems, THeap> for detailed informations about how the mapping between items of type T and heap nodes of type TreeNode<T> is performed, in presence of duplicates. Methods | Improve this Doc View Source Clear() Declaration public override void Clear() Overrides MoreStructures.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueue<T>.Clear() Remarks Clears the FibonacciHeapPriorityQueue<T> structures and the additional DuplicatedItemsResolution<TItems, THeap> object introduced to support updates and deletions. Time and Space Complexity is O(1). | Improve this Doc View Source GetPrioritiesOf(T) Declaration public IEnumerable<int> GetPrioritiesOf(T item) Parameters Type Name Description T item Returns Type Description IEnumerable < System.Int32 > Remarks | Improve this Doc View Source RaiseItemPopping(TreeNode<T>) Declaration protected override void RaiseItemPopping(TreeNode<T> root) Parameters Type Name Description TreeNode <T> root Overrides MoreStructures.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueue<T>.RaiseItemPopping(MoreStructures.PriorityQueues.BinomialHeap.TreeNode<T>) Remarks Hands over to RaiseItemPopping(TreeNode<TItems>) . | Improve this Doc View Source RaiseItemPushed(TreeNode<T>) Declaration protected override void RaiseItemPushed(TreeNode<T> newRoot) Parameters Type Name Description TreeNode <T> newRoot Overrides MoreStructures.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueue<T>.RaiseItemPushed(MoreStructures.PriorityQueues.BinomialHeap.TreeNode<T>) Remarks Hands over to RaiseItemPushed(TreeNode<TItems>) . | Improve this Doc View Source Remove(T) Declaration public PrioritizedItem<T>? Remove(T item) Parameters Type Name Description T item Returns Type Description System.Nullable < MoreStructures.PriorityQueues.PrioritizedItem <T>> Remarks ALGORITHM - It first retrieves the max priority P from the max priority item the queue via Peek() . - Then, it updates the priority of the provided item via UpdatePriority(T, Int32) , setting it to P + 1 and making item the one with max priority. - Finally it pops the item via Pop() . COMPLEXITY - Both Peek() and UpdatePriority(T, Int32) have constant Time and Space Complexity (update having constant amortized complexity). - However, Pop() has logarithmic Time Complexity. - Therefore, Time Complexity is O(log(n) + dup_factor) and Space Complexity is O(1). | Improve this Doc View Source UpdatePriority(T, Int32) Declaration public PrioritizedItem<T> UpdatePriority(T item, int newPriority) Parameters Type Name Description T item System.Int32 newPriority Returns Type Description MoreStructures.PriorityQueues.PrioritizedItem <T> Remarks ALGORITHM - FIBONACCI HEAP UPDATE PART - The algorith behaves quite differently, depending on whether the new priority for the specified item is higher or equal than P, as opposed to when it's lower. - When the priority is higher or equal and the node is a root, there is no structural change to the heap. The value of priority is updated and the reference to the max priority is checked and potentially updated. - When the priority is higher or equal and the node is not a root, the node is promoted to a root and its loser flag is reset. If the parent of the node was flagged as a loser, the parent is promoted to root too, and its loser flag is reset as well. That continues up to the first ancestor which is not a loser. - When the priority is lower, the node is not promoted to a root. Its children are, instead. As in the Pop() , merging and max root reference update take place. - Finally, the MoreStructures.PriorityQueues.PrioritizedItem<T> before the update is returned as result. COMPLEXITY - FIBONACCI HEAP UPDATE PART - The complexity is different depending on the value of new priority for the specified item being higher or equal than the highest in the queue for that item, or lower. - When the value is bigger or equal than P, Time and Space Complexity are O(1), amortized. - When the value is smaller than P, Time Complexity and Space Complexity are both O(log(n)). Same analysis as for Pop() applies (since very similar operations are performed). COMPLEXITY - OVERALL - When the value is bigger or equal than P, Time Complexity is O(dup_factor) and Space Complexity is O(1), amortized. - When the value is smaller than P, Time Complexity is O(log(n) + dup_factor) and Space Complexity is O(1). Implements IMergeablePriorityQueue<T, TPQTarget> IUpdatablePriorityQueue<T> IPriorityQueue<T> IEnumerable<> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) UpdatablePriorityQueueExtensions.PushOrUpdate<T>(IUpdatablePriorityQueue<T>, T, Int32) UpdatablePriorityQueueExtensions.PopAll<T>(IPriorityQueue<T>)"
  },
  "api/MoreStructures.PriorityQueues.html": {
    "href": "api/MoreStructures.PriorityQueues.html",
    "title": "Namespace MoreStructures.PriorityQueues",
    "keywords": "Namespace MoreStructures.PriorityQueues Classes MoreStructures.PriorityQueues. An item of type T with a priority and a \"push timestamp\" assigned to it. PushTimestampEra Defines a reference-type object wrapping an System.Int32 Era , which is the integer value, all push timestamps of MoreStructures.PriorityQueues.PrioritizedItem<T> instances having such base should be part of. Interfaces IMergeablePriorityQueue<T, TPQTarget> An IPriorityQueue<T> which supports efficient merging of the items from a second IMergeablePriorityQueue<T, TPQTarget> of type TPQTarget . priority. IPeekKthPriorityQueue<T> An IPriorityQueue<T> which supports efficient peek of the item stored in the queue with the k-highest priority. IPriorityQueue<T> Defines the interface common to all Priority Queue implementations. IUpdatablePriorityQueue<T> An IPriorityQueue<T> which supports priority update and item removal."
  },
  "api/MoreStructures.PriorityQueues.IMergeablePriorityQueue-2.html": {
    "href": "api/MoreStructures.PriorityQueues.IMergeablePriorityQueue-2.html",
    "title": "Interface IMergeablePriorityQueue<T, TPQTarget>",
    "keywords": "Interface IMergeablePriorityQueue<T, TPQTarget> An IPriorityQueue<T> which supports efficient merging of the items from a second IMergeablePriorityQueue<T, TPQTarget> of type TPQTarget . priority. Inherited Members IPriorityQueue<T>.Push(T, Int32) IPriorityQueue<T>.Pop() IPriorityQueue<T>.Count IPriorityQueue<T>.Peek() Namespace : MoreStructures.PriorityQueues Assembly : MoreStructures.dll Syntax public interface IMergeablePriorityQueue<T, in TPQTarget> : IPriorityQueue<T> where TPQTarget : IMergeablePriorityQueue<T, TPQTarget> Type Parameters Name Description T TPQTarget Remarks ADVANTAGES AND DISADVANTAGES - MergeFrom(TPQTarget) from a source S can be implemented in a general way by copying the entire target data structure T and then performing m Pop() , where m is the number of items in T, each followed by a Push(T, Int32) into S. - This approach has the advantage of being general and not mutating the target structure when performing the merge. - It is, however, expensive both in time and space, having O(m * log(m)) Time and O(n) Space Complexity for all known implementation of IPriorityQueue<T> . - Implementing this interface can take advantage of the properties of the underlying data structure implementing the priority queue, and providing better performance. COMPLEXITY - Notice that linear performance can be achieved by basic implementations of IPriorityQueue<T> , such as ArrayListPriorityQueue<T> , by just concatenating the underlying data structures. - In cases such as BinaryHeapPriorityQueue<T> , after concatenating, heap constraints have to be restored. However, this operation too, can be performed in linear time. - An implementation based on linked lists would perform the merge in O(1) time, by just concatenating the two underlying structures. That is a the cost of all subsequent operations on the queue. - Implementations based on forest of heap trees can do it in O(log(n)) or even O(1), when lazy, and keep logarithmic time for all operations on the resulting queue. SIDE EFFECTS - However, for sub-linear performance to be achieved, both with linked lists and forests of heaps, some form of structure sharing between source and target is required, because replicating the content of the target would take linear time. - To avoid interferences between the queues after merge, the target is emptied out during merge. - This is an operation which usually takes sub-linear time, so it doesn't affect the overall complexity of the merge operation, and avoid post-merge side effects between the queues. Methods | Improve this Doc View Source Clear() Clears this queue, wiping out all its items. Declaration void Clear() Remarks Used by MergeFrom(TPQTarget) on the target IMergeablePriorityQueue<T, TPQTarget> . | Improve this Doc View Source MergeFrom(TPQTarget) Merges all items the targetPriorityQueue into this priority queue, emptying out the content of the targetPriorityQueue . Declaration void MergeFrom(TPQTarget targetPriorityQueue) Parameters Type Name Description TPQTarget targetPriorityQueue The IMergeablePriorityQueue<T, TPQTarget> , to take the items from. Remarks Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) UpdatablePriorityQueueExtensions.PopAll<T>(IPriorityQueue<T>)"
  },
  "api/MoreStructures.PriorityQueues.IPeekKthPriorityQueue-1.html": {
    "href": "api/MoreStructures.PriorityQueues.IPeekKthPriorityQueue-1.html",
    "title": "Interface IPeekKthPriorityQueue<T>",
    "keywords": "Interface IPeekKthPriorityQueue<T> An IPriorityQueue<T> which supports efficient peek of the item stored in the queue with the k-highest priority. Inherited Members IPriorityQueue<T>.Push(T, Int32) IPriorityQueue<T>.Pop() IPriorityQueue<T>.Count IPriorityQueue<T>.Peek() Namespace : MoreStructures.PriorityQueues Assembly : MoreStructures.dll Syntax public interface IPeekKthPriorityQueue<T> : IPriorityQueue<T> Type Parameters Name Description T Remarks PeekKth(Int32) can be implemented in a general way by copying the entire data structure and then performing k Pop() , followed by a single Peek() . This approach is however expensive both in time and space, having O(n) Time and Space Complexity for all known implementation of IPriorityQueue<T> .. Implementing this interface can take advantage of the properties of the underlying data structure implementing the priority queue, and providing better-than-linear performance. Methods | Improve this Doc View Source PeekKth(Int32) Retrieves the item of the queue with priority k , without extracting any of the items in the queue. Declaration PrioritizedItem<T>? PeekKth(int k) Parameters Type Name Description System.Int32 k The non-negative priority rank: 0 means highest priority, 1 second highest, etc. Returns Type Description System.Nullable < MoreStructures.PriorityQueues.PrioritizedItem <T>> The MoreStructures.PriorityQueues.PrioritizedItem<T> with k-th highest priority if any. Null otherwise. Remarks PeekKth(Int32) with k == 0 is equivalent to Peek() . Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) UpdatablePriorityQueueExtensions.PopAll<T>(IPriorityQueue<T>)"
  },
  "api/MoreStructures.PriorityQueues.IPriorityQueue-1.html": {
    "href": "api/MoreStructures.PriorityQueues.IPriorityQueue-1.html",
    "title": "Interface IPriorityQueue<T>",
    "keywords": "Interface IPriorityQueue<T> Defines the interface common to all Priority Queue implementations. Namespace : MoreStructures.PriorityQueues Assembly : MoreStructures.dll Syntax public interface IPriorityQueue<T> Type Parameters Name Description T The type of items, the queue is composed of. Remarks DEFINITION - A Priority Queue is a data structure storing items of a generic type T , together with their priority . - Duplicates, both for items and their priorities, are supported. - Priorities are defined as System.Int32 values: the bigger the value, the higher is the priority of the item. - The core operations of any Priority Queue are insertion of an item with related priority, extraction of the item with the highest priority and testing for empty. - Other operations are provided, such as total count of items and peeking (retrieval without extraction). - More advanced operations, requiring auxiliary data structures for their implementation, are not specified by this interface: examples are priority update and removal of an item. - Popular implementations make both insertion and extraction sub-linear operations (i.e. faster than O(n)). Properties | Improve this Doc View Source Count The number of items currently in the queue. Declaration int Count { get; } Property Value Type Description System.Int32 A non-negative value. Methods | Improve this Doc View Source Peek() Retrieves the item of the queue with highest priority, without extracting it. Declaration PrioritizedItem<T> Peek() Returns Type Description MoreStructures.PriorityQueues.PrioritizedItem <T> A MoreStructures.PriorityQueues.PrioritizedItem<T> wrapping the item with the highest priority, together with its priority and push timestamp. Remarks Check Pop() for retrieval and extraction of the item. | Improve this Doc View Source Pop() Extracts the item of the queue with highest priority. Declaration PrioritizedItem<T> Pop() Returns Type Description MoreStructures.PriorityQueues.PrioritizedItem <T> A MoreStructures.PriorityQueues.PrioritizedItem<T> wrapping the item with the highest priority, together with its priority and push timestamp. Remarks Check Pop() for retrieval without extraction of the item. | Improve this Doc View Source Push(T, Int32) Inserts the provided item into the queue, with the provided priority . Declaration void Push(T item, int priority) Parameters Type Name Description T item The item to be inserted into the queue. System.Int32 priority The priority to be assigned to the item . Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) UpdatablePriorityQueueExtensions.PopAll<T>(IPriorityQueue<T>)"
  },
  "api/MoreStructures.PriorityQueues.IUpdatablePriorityQueue-1.html": {
    "href": "api/MoreStructures.PriorityQueues.IUpdatablePriorityQueue-1.html",
    "title": "Interface IUpdatablePriorityQueue<T>",
    "keywords": "Interface IUpdatablePriorityQueue<T> An IPriorityQueue<T> which supports priority update and item removal. Inherited Members IPriorityQueue<T>.Push(T, Int32) IPriorityQueue<T>.Pop() IPriorityQueue<T>.Count IPriorityQueue<T>.Peek() Namespace : MoreStructures.PriorityQueues Assembly : MoreStructures.dll Syntax public interface IUpdatablePriorityQueue<T> : IPriorityQueue<T> Type Parameters Name Description T Methods | Improve this Doc View Source GetPrioritiesOf(T) Returns all the priorities with which item is registered in the queue, sorted by highest to smallest. Declaration IEnumerable<int> GetPrioritiesOf(T item) Parameters Type Name Description T item The item, to retrieve priorities of. Returns Type Description IEnumerable < System.Int32 > The sequence of System.Int32 values, each being a priority. | Improve this Doc View Source Remove(T) Removes the first occurrence of the provided item from the queue. Declaration PrioritizedItem<T>? Remove(T item) Parameters Type Name Description T item The item to be removed. Returns Type Description System.Nullable < MoreStructures.PriorityQueues.PrioritizedItem <T>> The MoreStructures.PriorityQueues.PrioritizedItem<T> with which item was present in the queue, before being removed, or null , if no occurrence of item was found. | Improve this Doc View Source UpdatePriority(T, Int32) Updates the priority of the provided item , without changing the timestamp. Declaration PrioritizedItem<T> UpdatePriority(T item, int newPriority) Parameters Type Name Description T item The item, to update the priority of. Must be present in the queue. System.Int32 newPriority The new priority to be assigned to item . Returns Type Description MoreStructures.PriorityQueues.PrioritizedItem <T> The MoreStructures.PriorityQueues.PrioritizedItem<T> with which item was present in the queue, before being updated. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) UpdatablePriorityQueueExtensions.PushOrUpdate<T>(IUpdatablePriorityQueue<T>, T, Int32) UpdatablePriorityQueueExtensions.PopAll<T>(IPriorityQueue<T>)"
  },
  "api/MoreStructures.PriorityQueues.PushTimestampEra.html": {
    "href": "api/MoreStructures.PriorityQueues.PushTimestampEra.html",
    "title": "Class PushTimestampEra",
    "keywords": "Class PushTimestampEra Defines a reference-type object wrapping an System.Int32 Era , which is the integer value, all push timestamps of MoreStructures.PriorityQueues.PrioritizedItem<T> instances having such base should be part of. Inheritance System.Object PushTimestampEra Implements System.IEquatable < PushTimestampEra > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.PriorityQueues Assembly : MoreStructures.dll Syntax public class PushTimestampEra : IEquatable<PushTimestampEra> Remarks The order of push timestamps in different eras is solely determined by the era: push timestamps in lower eras are always considered smaller than push timestamps in higher eras, no matter their value. Within the same era, higher push timestamps are considered higher than lower push timestamps (i.e. the timestamp value is taken into account). Constructors | Improve this Doc View Source PushTimestampEra(Int32) Defines a reference-type object wrapping an System.Int32 Era , which is the integer value, all push timestamps of MoreStructures.PriorityQueues.PrioritizedItem<T> instances having such base should be part of. Declaration public PushTimestampEra(int Era) Parameters Type Name Description System.Int32 Era The value of the era, the push timestamp refers to. Any integer, positive or negative. Remarks The order of push timestamps in different eras is solely determined by the era: push timestamps in lower eras are always considered smaller than push timestamps in higher eras, no matter their value. Within the same era, higher push timestamps are considered higher than lower push timestamps (i.e. the timestamp value is taken into account). Properties | Improve this Doc View Source Era Declaration public int Era { get; set; } Property Value Type Description System.Int32 Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Queues.ArrayListQueue-1.html": {
    "href": "api/MoreStructures.Queues.ArrayListQueue-1.html",
    "title": "Class ArrayListQueue<T>",
    "keywords": "Class ArrayListQueue<T> A IQueue<T> implementation based on an array list of items. Inheritance System.Object ArrayBasedDataStructure <T> ArrayListQueue<T> Implements IQueue <T> Inherited Members ArrayBasedDataStructure<T>.DefaultInitialCapacity ArrayBasedDataStructure<T>.DefaultIncreasingFactor ArrayBasedDataStructure<T>.Items ArrayBasedDataStructure<T>.IncreasingFactor System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Queues Assembly : MoreStructures.dll Syntax public class ArrayListQueue<T> : ArrayBasedDataStructure<T>, IQueue<T> Type Parameters Name Description T Remarks ADVANTAGES AND DISADVANTAGES - The advantages an disadvantages of using an array list over a linked list-based implementation are the same as the ones described in LinkedListStack<T> . Constructors | Improve this Doc View Source ArrayListQueue(Int32, Double) Declaration public ArrayListQueue(int capacity = 16, double increasingFactor = 2) Parameters Type Name Description System.Int32 capacity System.Double increasingFactor Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description System.Int32 Remarks Stored and updated in constant time at each Enqueue(T) and Dequeue() . Time and Space Complexity are O(1). Methods | Improve this Doc View Source Dequeue() Declaration public T Dequeue() Returns Type Description T Remarks First, it retrieves the least recent item set into the underlying array list (whose index is internally stored). Then, it reset the value at such index and decreases the Count by 1. Then, if the new Count is smaller than the current capacity by more than twice the IncreasingFactor compoundly (i.e. capacity * increasingFactor^2), the underlying array list is resized to have a new capacity equal to the old capacity times the increasing factor. Finally, it returns the retrieved item as result. Raises an if the array list is empty. Time and Space Complexity are O(1). | Improve this Doc View Source Enqueue(T) Declaration public void Enqueue(T item) Parameters Type Name Description T item Remarks If there is available room in the underlying array, the new item is stored in the first available location (applying circular arithmetic to indexes) and the Count is increased by 1. Otherwise the underlying array is resized by the IncreasingFactor , to accomodate the new item . Time and Space Complexity are O(1) if Count before insertion is strictly smaller than the current capacity. Time and Space Complexity are O(n) if Count before insertion is equal to the current capacity. If the IncreasingFactor is set to a sensible value (e.g. 2.0), the amortized cost over n insertions becomes O(1). | Improve this Doc View Source Peek() Declaration public T Peek() Returns Type Description T Remarks Checks and returns the item of the underlying array list at the first index set (which is internally stored), if it exists. Throws a if the underlying array is empty. Time and Space Complexity are O(1). | Improve this Doc View Source ResizeItems(Double) Declaration protected override void ResizeItems(double factor) Parameters Type Name Description System.Double factor Overrides MoreStructures.Stacks.ArrayBasedDataStructure<T>.ResizeItems(System.Double) Remarks After resizing, it copies items appropriately to restore circular arithmetic of indexes which is now based on a different modulo. If the size of the array has been increased, copy will happen from the front of the backing array to the front of its second half (introduced by the resizing). If the size of the array has been reduced, copy will simply scan the entire old array, remapping indexes into the new array. Implements IQueue<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Queues.html": {
    "href": "api/MoreStructures.Queues.html",
    "title": "Namespace MoreStructures.Queues",
    "keywords": "Namespace MoreStructures.Queues Classes ArrayListQueue<T> A IQueue<T> implementation based on an array list of items. LinkedListQueue<T> A IQueue<T> implementation based on a singly-linked linked list of items. Interfaces IQueue<T> Defines the interface common to all Queues implementations for items of type T ."
  },
  "api/MoreStructures.Queues.IQueue-1.html": {
    "href": "api/MoreStructures.Queues.IQueue-1.html",
    "title": "Interface IQueue<T>",
    "keywords": "Interface IQueue<T> Defines the interface common to all Queues implementations for items of type T . Namespace : MoreStructures.Queues Assembly : MoreStructures.dll Syntax public interface IQueue<T> Type Parameters Name Description T The type of items, the queue is composed of. Remarks DEFINITION - A Queue is a data structure storing items of a generic type T in a FIFO (First In First Out) fashion. - Items are inserted at the back (or end) of the queue and extracted from the front (or begin) of the queue. - Like stacks, they are specialized data structures for which general random access is not a priority. - As for stack, O(1) non amortized cost of insertion and extraction can be provided in some implementations. - Arrays and array lists can be used as a backing structure for a stack, and still have O(1) amortized cost within array boundaries and O(1) amortized cost to remove array boundaries constraints. - Items are in a total order relationship and duplicates are supported. Properties | Improve this Doc View Source Count The number of items currently in the queue. Declaration int Count { get; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source Dequeue() Pops the item out from the front of the queue and returns it as a result. Declaration T Dequeue() Returns Type Description T The item of type T which was at the front of the queue. Remarks The item which was on second position at the front of the queue gets promoted to first position after the item at the front is popped out. The position of all the items is shifted of -1. | Improve this Doc View Source Enqueue(T) Push the provided item at the back of the queue. Declaration void Enqueue(T item) Parameters Type Name Description T item The item of type T to be pushed. Remarks All other items in the queue keep their position. | Improve this Doc View Source Peek() Returns the item at the front of the queue, without popping it out from the queue. Declaration T Peek() Returns Type Description T The item of type T currently at the front of the queue. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Queues.LinkedListQueue-1.html": {
    "href": "api/MoreStructures.Queues.LinkedListQueue-1.html",
    "title": "Class LinkedListQueue<T>",
    "keywords": "Class LinkedListQueue<T> A IQueue<T> implementation based on a singly-linked linked list of items. Inheritance System.Object LinkedListQueue<T> Implements IQueue <T> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Queues Assembly : MoreStructures.dll Syntax public class LinkedListQueue<T> : IQueue<T> Type Parameters Name Description T Remarks ADVANTAGES AND DISADVANTAGES - The advantages and disadvantages of using a linked list over an array-based implementation are the same as the ones described in LinkedListStack<T> . Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description System.Int32 Remarks Stored and updated in constant time at each Enqueue(T) and Dequeue() . Time and Space Complexity are O(1). Methods | Improve this Doc View Source Dequeue() Declaration public T Dequeue() Returns Type Description T Remarks First, it retrieves the item referenced by the front of the underlying linked list. Then it updates the reference to the head of the linked list, to point to its \"next\". The reference to the last item is also updated, if the head is set to point to null. Time and Space Complexity are O(1). | Improve this Doc View Source Enqueue(T) Declaration public void Enqueue(T item) Parameters Type Name Description T item Remarks Creates a new node wrapping the provided item . Then, it appends it to the back of the linked list of items, updating the reference to the last item of the list. It also updates the head, if the list was previously empty, to point to the newly created item. Time and Space Complexity are O(1). | Improve this Doc View Source Peek() Declaration public T Peek() Returns Type Description T Remarks Checks the front of the underlying linked list. Time and Space Complexity are O(1). Implements IQueue<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Conversions.FullyIterativeStringifier-2.html": {
    "href": "api/MoreStructures.RecImmTrees.Conversions.FullyIterativeStringifier-2.html",
    "title": "Class FullyIterativeStringifier<TEdge, TNode>",
    "keywords": "Class FullyIterativeStringifier<TEdge, TNode> Iterative implementation. Inheritance System.Object StringifierBase <TEdge, TNode> FullyIterativeStringifier<TEdge, TNode> Implements IStringifier <TEdge, TNode> Inherited Members StringifierBase<TEdge, TNode>.NewLine StringifierBase<TEdge, TNode>.Indent StringifierBase<TEdge, TNode>.PathSeparator StringifierBase<TEdge, TNode>.RootStringifier StringifierBase<TEdge, TNode>.EdgeAndNodeStringifier StringifierBase<TEdge, TNode>.Stringify(TNode) StringifierBase<TEdge, TNode>.Stringify(TreePath<TEdge, TNode>) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees.Conversions Assembly : MoreStructures.dll Syntax public class FullyIterativeStringifier<TEdge, TNode> : StringifierBase<TEdge, TNode>, IStringifier<TEdge, TNode> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge The type of edges of the specific structure. TNode The type of nodes of the specific structure. Remarks ADVANTAGES AND DISADVANTAGES Constructors | Improve this Doc View Source FullyIterativeStringifier(Func<TNode, String>, Func<TEdge, TNode, String>) Declaration public FullyIterativeStringifier(Func<TNode, string> rootStringifier, Func<TEdge, TNode, string> edgeAndNodeStringifier) Parameters Type Name Description Func <TNode, System.String > rootStringifier Func <TEdge, TNode, System.String > edgeAndNodeStringifier Properties | Improve this Doc View Source PrependLevelAfterStopIndenting Whether the actual level should be prepended to the line, once the maximum level of indentation defined at StopIndentingLevel has been reached. Default is true . Declaration public bool PrependLevelAfterStopIndenting { get; set; } Property Value Type Description System.Boolean | Improve this Doc View Source StopIndentingLevel The maximum level at which indentation should not be done anymore. Default is System.Int32.MaxValue . Declaration public int StopIndentingLevel { get; set; } Property Value Type Description System.Int32 Remarks COMPLEXITY - When trying to render a very deep structure to string, the resulting string can become extremely big due to indentation. - This can easily happen with structures like SuffixTrieNode . Less with SuffixTreeNode , due to their coalescing of paths of nodes with single child. - For example if the structure is a linear chain of n in depth, 4 chars of indentation per line would yield a string of 2n(n-1) chars = O(n^2). - For n = 10000 nodes the produced string would be ~ 200M. - To avoid that StopIndentingLevel can be set to a constant c, limiting the size of the resulting string by an upper bound of cn = O(n). - For n = 10000 nodes and c = 10 levels the produced string would be 100K. Methods | Improve this Doc View Source Stringify(TNode) Declaration public override string Stringify(TNode node) Parameters Type Name Description TNode node Returns Type Description System.String Overrides MoreStructures.RecImmTrees.Conversions.StringifierBase<TEdge, TNode>.Stringify(TNode) | Improve this Doc View Source Stringify(TreePath<TEdge, TNode>) Declaration public override string Stringify(TreePath<TEdge, TNode> path) Parameters Type Name Description TreePath <TEdge, TNode> path Returns Type Description System.String Overrides MoreStructures.RecImmTrees.Conversions.StringifierBase<TEdge, TNode>.Stringify(MoreStructures.RecImmTrees.TreePath<TEdge, TNode>) Implements IStringifier<TEdge, TNode> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Conversions.FullyRecursiveStringifier-2.html": {
    "href": "api/MoreStructures.RecImmTrees.Conversions.FullyRecursiveStringifier-2.html",
    "title": "Class FullyRecursiveStringifier<TEdge, TNode>",
    "keywords": "Class FullyRecursiveStringifier<TEdge, TNode> Recursive implementation. Inheritance System.Object StringifierBase <TEdge, TNode> FullyRecursiveStringifier<TEdge, TNode> Implements IStringifier <TEdge, TNode> Inherited Members StringifierBase<TEdge, TNode>.NewLine StringifierBase<TEdge, TNode>.Indent StringifierBase<TEdge, TNode>.PathSeparator StringifierBase<TEdge, TNode>.RootStringifier StringifierBase<TEdge, TNode>.EdgeAndNodeStringifier StringifierBase<TEdge, TNode>.Stringify(TNode) StringifierBase<TEdge, TNode>.Stringify(TreePath<TEdge, TNode>) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees.Conversions Assembly : MoreStructures.dll Syntax public class FullyRecursiveStringifier<TEdge, TNode> : StringifierBase<TEdge, TNode>, IStringifier<TEdge, TNode> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode>, IComparable<TEdge> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge The type of edges of the specific structure. TNode The type of nodes of the specific structure. Remarks ADVANTAGES AND DISADVANTAGES Implemented fully recursively, so limited by stack depth and usable with tree of a \"reasonable\" height. Constructors | Improve this Doc View Source FullyRecursiveStringifier(Func<TNode, String>, Func<TEdge, TNode, String>) Declaration public FullyRecursiveStringifier(Func<TNode, string> rootStringifier, Func<TEdge, TNode, string> edgeAndNodeStringifier) Parameters Type Name Description Func <TNode, System.String > rootStringifier Func <TEdge, TNode, System.String > edgeAndNodeStringifier Methods | Improve this Doc View Source Stringify(TNode) Declaration public override string Stringify(TNode node) Parameters Type Name Description TNode node Returns Type Description System.String Overrides MoreStructures.RecImmTrees.Conversions.StringifierBase<TEdge, TNode>.Stringify(TNode) | Improve this Doc View Source Stringify(TreePath<TEdge, TNode>) Declaration public override string Stringify(TreePath<TEdge, TNode> path) Parameters Type Name Description TreePath <TEdge, TNode> path Returns Type Description System.String Overrides MoreStructures.RecImmTrees.Conversions.StringifierBase<TEdge, TNode>.Stringify(MoreStructures.RecImmTrees.TreePath<TEdge, TNode>) Implements IStringifier<TEdge, TNode> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Conversions.html": {
    "href": "api/MoreStructures.RecImmTrees.Conversions.html",
    "title": "Namespace MoreStructures.RecImmTrees.Conversions",
    "keywords": "Namespace MoreStructures.RecImmTrees.Conversions Classes FullyIterativeStringifier<TEdge, TNode> Iterative implementation. FullyRecursiveStringifier<TEdge, TNode> Recursive implementation. StringifierBase<TEdge, TNode> Provides concrete properties and defaults for new line, identation and stringifiers. Interfaces IStringifier<TEdge, TNode> A converter from IRecImmDictIndexedTreeNode<TEdge, TNode> structures and paths to string."
  },
  "api/MoreStructures.RecImmTrees.Conversions.IStringifier-2.html": {
    "href": "api/MoreStructures.RecImmTrees.Conversions.IStringifier-2.html",
    "title": "Interface IStringifier<TEdge, TNode>",
    "keywords": "Interface IStringifier<TEdge, TNode> A converter from IRecImmDictIndexedTreeNode<TEdge, TNode> structures and paths to string. Namespace : MoreStructures.RecImmTrees.Conversions Assembly : MoreStructures.dll Syntax public interface IStringifier<TEdge, TNode> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge The type of edges of the specific structure. TNode The type of nodes of the specific structure. Remarks REQUIREMENTS Requires TEdge to implement , so that output lines are sorted. COMPLEXITY Time Complexity = O(n) and Space Complexity = O(n) where n = number of nodes in the TNode structure/path. Each node and its incoming edge is visited once. Examples var stringifier = ... { NewLine = Environment.NewLine, Indent = '\\t', RootStringifier = n => \"R\", EdgeAndNodeStringifier = (e, n) => $\"{e} -> {n}\", }; var node = ... Console.WriteLine(stringifier.Stringify(node)); Properties | Improve this Doc View Source EdgeAndNodeStringifier A function mapping the provided edge and node to a string. Used for all lines of the output but the first. Declaration Func<TEdge, TNode, string> EdgeAndNodeStringifier { get; set; } Property Value Type Description Func <TEdge, TNode, System.String > | Improve this Doc View Source Indent The character or string used to indent output, to visually express tree levels. Declaration string Indent { get; set; } Property Value Type Description System.String Examples 2 or 4 spaces, a tab, ... | Improve this Doc View Source NewLine The character or string used to separate lines of the output. Declaration string NewLine { get; set; } Property Value Type Description System.String | Improve this Doc View Source PathSeparator The character or string used to join stringified path nodes, when building the output string. Declaration string PathSeparator { get; set; } Property Value Type Description System.String Examples \" -> \", \", \", ... | Improve this Doc View Source RootStringifier A function mapping the top-level node to a string. Used for the first line of the output. Declaration Func<TNode, string> RootStringifier { get; set; } Property Value Type Description Func <TNode, System.String > Methods | Improve this Doc View Source Stringify(TNode) Converts the provided IRecImmDictIndexedTreeNode<TEdge, TNode> into a string. Declaration string Stringify(TNode node) Parameters Type Name Description TNode node The root of the tree to stringify. Returns Type Description System.String A string version of the provided structure. Examples Using 4 spaces as indent, RootStringifier = n => \"R\", and EdgeAndNodeStringifier = (e, n) => $\"{e} -> N\": R e1 -> N e3 -> N e4 -> N e5 -> N e2 -> N e6 -> N | Improve this Doc View Source Stringify(TreePath<TEdge, TNode>) Converts the provided TreePath<TEdge, TNode> into a string. Declaration string Stringify(TreePath<TEdge, TNode> path) Parameters Type Name Description TreePath <TEdge, TNode> path The tree path to stringify. Returns Type Description System.String A string version of the provided path. Examples Using PathSeparator = \" -> \" and EdgeAndNodeStringifier = (e, n) => $\"{e}\": e1 -> e4 -> e5 Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Conversions.StringifierBase-2.html": {
    "href": "api/MoreStructures.RecImmTrees.Conversions.StringifierBase-2.html",
    "title": "Class StringifierBase<TEdge, TNode>",
    "keywords": "Class StringifierBase<TEdge, TNode> Provides concrete properties and defaults for new line, identation and stringifiers. Inheritance System.Object StringifierBase<TEdge, TNode> FullyIterativeStringifier<TEdge, TNode> FullyRecursiveStringifier<TEdge, TNode> Implements IStringifier <TEdge, TNode> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees.Conversions Assembly : MoreStructures.dll Syntax public abstract class StringifierBase<TEdge, TNode> : IStringifier<TEdge, TNode> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge The type of edges of the specific structure. TNode The type of nodes of the specific structure. Constructors | Improve this Doc View Source StringifierBase(Func<TNode, String>, Func<TEdge, TNode, String>) Builds an instance of an IStringifier<TEdge, TNode> with the provided stringifiers, for the root and for all other nodes in the three, and with default new line and indent. Declaration protected StringifierBase(Func<TNode, string> rootStringifier, Func<TEdge, TNode, string> edgeAndNodeStringifier) Parameters Type Name Description Func <TNode, System.String > rootStringifier Func <TEdge, TNode, System.String > edgeAndNodeStringifier Properties | Improve this Doc View Source EdgeAndNodeStringifier A function mapping the provided edge and node to a string. Used for all lines of the output but the first. Declaration public Func<TEdge, TNode, string> EdgeAndNodeStringifier { get; set; } Property Value Type Description Func <TEdge, TNode, System.String > | Improve this Doc View Source Indent By default is 4 spaces. Declaration public string Indent { get; set; } Property Value Type Description System.String | Improve this Doc View Source NewLine By default is . Declaration public string NewLine { get; set; } Property Value Type Description System.String | Improve this Doc View Source PathSeparator By default is a single space. Declaration public string PathSeparator { get; set; } Property Value Type Description System.String | Improve this Doc View Source RootStringifier A function mapping the top-level node to a string. Used for the first line of the output. Declaration public Func<TNode, string> RootStringifier { get; set; } Property Value Type Description Func <TNode, System.String > Methods | Improve this Doc View Source Stringify(TNode) Converts the provided IRecImmDictIndexedTreeNode<TEdge, TNode> into a string. Declaration public abstract string Stringify(TNode node) Parameters Type Name Description TNode node The root of the tree to stringify. Returns Type Description System.String A string version of the provided structure. | Improve this Doc View Source Stringify(TreePath<TEdge, TNode>) Converts the provided TreePath<TEdge, TNode> into a string. Declaration public abstract string Stringify(TreePath<TEdge, TNode> path) Parameters Type Name Description TreePath <TEdge, TNode> path The tree path to stringify. Returns Type Description System.String A string version of the provided path. Implements IStringifier<TEdge, TNode> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.html": {
    "href": "api/MoreStructures.RecImmTrees.html",
    "title": "Namespace MoreStructures.RecImmTrees",
    "keywords": "Namespace MoreStructures.RecImmTrees Classes RecImmDictIndexedTreeNodeExtensions Extension methods for all IRecImmDictIndexedTreeNode<TEdge, TNode> node concretions. TreePath<TEdge, TNode> An immutable sequence of TNode , where each node is child of its predecessor and parent of its successor and where node relationships are stored in TEdge instances. TreePathExtensions Extension methods for TreePath<TEdge, TNode> . Interfaces IRecImmDictIndexedTreeEdge<TEdge, TNode> An edge of a IRecImmDictIndexedTreeNode<TEdge, TNode> , directionally linking two nodes and forming a path hop. IRecImmDictIndexedTreeNode<TEdge, TNode> The node of a generic Tree Structure recursively defined and whose nodes are indexed in an immutable dictionary of edges. Has no specific use case in mind and can be a root node, an intermediate node or a leaf node."
  },
  "api/MoreStructures.RecImmTrees.IRecImmDictIndexedTreeEdge-2.html": {
    "href": "api/MoreStructures.RecImmTrees.IRecImmDictIndexedTreeEdge-2.html",
    "title": "Interface IRecImmDictIndexedTreeEdge<TEdge, TNode>",
    "keywords": "Interface IRecImmDictIndexedTreeEdge<TEdge, TNode> An edge of a IRecImmDictIndexedTreeNode<TEdge, TNode> , directionally linking two nodes and forming a path hop. Namespace : MoreStructures.RecImmTrees Assembly : MoreStructures.dll Syntax public interface IRecImmDictIndexedTreeEdge<TEdge, TNode> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge The type of edges of the specific structure. TNode The type of nodes of the specific structure. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.IRecImmDictIndexedTreeNode-2.html": {
    "href": "api/MoreStructures.RecImmTrees.IRecImmDictIndexedTreeNode-2.html",
    "title": "Interface IRecImmDictIndexedTreeNode<TEdge, TNode>",
    "keywords": "Interface IRecImmDictIndexedTreeNode<TEdge, TNode> The node of a generic Tree Structure recursively defined and whose nodes are indexed in an immutable dictionary of edges. Has no specific use case in mind and can be a root node, an intermediate node or a leaf node. Namespace : MoreStructures.RecImmTrees Assembly : MoreStructures.dll Syntax public interface IRecImmDictIndexedTreeNode<TEdge, TNode> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge The type of edges of the specific structure. TNode The type of nodes of the specific structure. Properties | Improve this Doc View Source Children A readonly view of the children private collection of this node. Empty for leaves. Declaration IDictionary<TEdge, TNode> Children { get; } Property Value Type Description IDictionary <TEdge, TNode> Extension Methods RecImmDictIndexedTreeNodeExtensions.IsLeaf<TEdge, TNode>(IRecImmDictIndexedTreeNode<TEdge, TNode>) SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Paths.FullyIterativeNodeToLeafPathsBuilder.html": {
    "href": "api/MoreStructures.RecImmTrees.Paths.FullyIterativeNodeToLeafPathsBuilder.html",
    "title": "Class FullyIterativeNodeToLeafPathsBuilder",
    "keywords": "Class FullyIterativeNodeToLeafPathsBuilder Iterative implementation. Inheritance System.Object FullyIterativeNodeToLeafPathsBuilder Implements INodeToLeafPathsBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees.Paths Assembly : MoreStructures.dll Syntax public class FullyIterativeNodeToLeafPathsBuilder : INodeToLeafPathsBuilder Remarks ADVANTAGES AND DISADVANTAGES ALGORITHM The implementation uses a , onto which quadrules are stacked up: (incoming edge, node, queue of subpaths of the parent node of node, queue of subpaths of the node itself). - A queue of subpaths of the root node is instantiated empty. It will collect the output TreePath<TEdge, TNode> instances. - Children (node and incoming edge) of the root node are pushed onto the stack in reverse order. The queue of subpaths of the root is passed to each child. The queue of the child is set to null , since children of the child haven't been processed yet (i.e. the child queue of subpath hasn't been populated yet). - Then the stack processing loop is performed. After every stack item is processed, the queue of subpaths of the root is unloaded, emitting TreePath<TEdge, TNode> instances from the collected of of edges and nodes. Stack processing iteration: - The frame at the top of the stack is popped. - If the node is a leaf, the node and its incoming edge are added to the queue of subpaths of the parent node. - If the node has children and the queue of subpaths of the node is set, children have been already processed. So as many paths are enqueued to the queue of subpaths of the parent node as paths in the queue of subpaths of the node. Each subpath of the node is prepended with the node itself. - If the node has children and the queue of subpaths of the node is not set, children have not been processed yet. So create a new queue for the subpaths of the node and push the node back to the stack, this time with the queue of subpaths set. Then push all the children of the node to the stack (in reverse order), passing the queue of subpaths of the node as queue of subpaths of the parent, and the queue of subpaths of the child not set. COMPLEXITY - Each node is pushed to the stack and then processed at most twice (only once for leaves). So the maximum number of items in the stack is 2 * n, where n = number of nodes in the tree. - The total number of paths from root to leaf is equal to the total number of leaves of the tree, which can be at most n (if the root itself is a leaf), n - 1 (if the root is not a leaf and the tree is completely flat) or anything down to 1 (if the tree is as unbalanced as it can be). - Each stack processing iteration does constant time work: stack item deconstruction, check whether the node is a leaf or not, instantiate a queue of subpaths of the node. Children are iterated, however, the total number of children iteration over all the nodes of the tree is equal to the number of edges, which is n - 1. - For each non-leaf node (and there can be O(n) of those), a queue of subpaths is instantiated and populated. Such queue can have O(n) items in it (for a flattish tree), each being a subpath of length O(n). This would suggest a cubic complexity. However, there is at most a total of n root-to-leaf paths, each being at most of length n, so overall Space Complexity is quadratic. - So Time Complexity is O(n) and Space Complexity is O(n^2). Methods | Improve this Doc View Source GetAllNodeToLeafPaths<TEdge, TNode>(TNode) Declaration public IEnumerable<TreePath<TEdge, TNode>> GetAllNodeToLeafPaths<TEdge, TNode>(TNode node) where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Parameters Type Name Description TNode node Returns Type Description IEnumerable < TreePath <TEdge, TNode>> Type Parameters Name Description TEdge TNode Implements INodeToLeafPathsBuilder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Paths.FullyRecursiveNodeToLeafPathsBuilder.html": {
    "href": "api/MoreStructures.RecImmTrees.Paths.FullyRecursiveNodeToLeafPathsBuilder.html",
    "title": "Class FullyRecursiveNodeToLeafPathsBuilder",
    "keywords": "Class FullyRecursiveNodeToLeafPathsBuilder Recursive implementation. Inheritance System.Object FullyRecursiveNodeToLeafPathsBuilder Implements INodeToLeafPathsBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees.Paths Assembly : MoreStructures.dll Syntax public class FullyRecursiveNodeToLeafPathsBuilder : INodeToLeafPathsBuilder Remarks ADVANTAGES AND DISADVANTAGES Implemented fully recursively, so limited by stack depth and usable with tree of a \"reasonable\" height. ALGORITHM - The implementation iterates over the children, getting its node-to-leaf subpaths by calling GetAllNodeToLeafPaths<TEdge, TNode>(TNode) recursively. - Then, it prepends the child and its incoming edge to each subpath of each child. - If the node has no child, a singleton path is returned, containing only the child and its incoming edge. COMPLEXITY - Each node is processed once and the number of node-to-leaf paths returned has an upper bound on n = number of nodes in the tree. The length of each node-to-leaf path is also limited by n. - So, both Time and Space Complexity are O(n). Methods | Improve this Doc View Source GetAllNodeToLeafPaths<TEdge, TNode>(TNode) Declaration public IEnumerable<TreePath<TEdge, TNode>> GetAllNodeToLeafPaths<TEdge, TNode>(TNode node) where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Parameters Type Name Description TNode node Returns Type Description IEnumerable < TreePath <TEdge, TNode>> Type Parameters Name Description TEdge TNode Implements INodeToLeafPathsBuilder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Paths.html": {
    "href": "api/MoreStructures.RecImmTrees.Paths.html",
    "title": "Namespace MoreStructures.RecImmTrees.Paths",
    "keywords": "Namespace MoreStructures.RecImmTrees.Paths Classes FullyIterativeNodeToLeafPathsBuilder Iterative implementation. FullyRecursiveNodeToLeafPathsBuilder Recursive implementation. Interfaces INodeToLeafPathsBuilder An algorithm building all TreePath<TEdge, TNode> from the provided IRecImmDictIndexedTreeNode<TEdge, TNode> to a leaf."
  },
  "api/MoreStructures.RecImmTrees.Paths.INodeToLeafPathsBuilder.html": {
    "href": "api/MoreStructures.RecImmTrees.Paths.INodeToLeafPathsBuilder.html",
    "title": "Interface INodeToLeafPathsBuilder",
    "keywords": "Interface INodeToLeafPathsBuilder An algorithm building all TreePath<TEdge, TNode> from the provided IRecImmDictIndexedTreeNode<TEdge, TNode> to a leaf. Namespace : MoreStructures.RecImmTrees.Paths Assembly : MoreStructures.dll Syntax public interface INodeToLeafPathsBuilder Methods | Improve this Doc View Source GetAllNodeToLeafPaths<TEdge, TNode>(TNode) Returns all TreePath<TEdge, TNode> from the provided node to a leaf. Declaration IEnumerable<TreePath<TEdge, TNode>> GetAllNodeToLeafPaths<TEdge, TNode>(TNode node) where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Parameters Type Name Description TNode node The node, to start the structure traversal from. Returns Type Description IEnumerable < TreePath <TEdge, TNode>> A sequence of TreePath<TEdge, TNode> . Type Parameters Name Description TEdge The type of edges of the specific structure. TNode The type of nodes of the specific structure. Examples Given the following tree structure: 0 |- 0 -> 1 | |- 1 -> 2 | |- 2 -> 3 | | |- 3 -> 4 | |- 4 -> 5 |- 5 -> 6 |- 6 -> 7 |- 7 -> 8 |- 8 -> 9 |- 9 -> 10 The method would return the following node-to-leaf paths: (0 -> 1) => (1 -> 2) (0 -> 1) => (2 -> 3) => (3 -> 4) (0 -> 1) => (4 -> 5) (5 -> 6) (6 -> 7) => (7 -> 8) => (8 -> 9) (6 -> 7) => (7 -> 8) => (9 -> 10) Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.RecImmDictIndexedTreeNodeExtensions.html": {
    "href": "api/MoreStructures.RecImmTrees.RecImmDictIndexedTreeNodeExtensions.html",
    "title": "Class RecImmDictIndexedTreeNodeExtensions",
    "keywords": "Class RecImmDictIndexedTreeNodeExtensions Extension methods for all IRecImmDictIndexedTreeNode<TEdge, TNode> node concretions. Inheritance System.Object RecImmDictIndexedTreeNodeExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees Assembly : MoreStructures.dll Syntax public static class RecImmDictIndexedTreeNodeExtensions Methods | Improve this Doc View Source IsLeaf<TEdge, TNode>(IRecImmDictIndexedTreeNode<TEdge, TNode>) Whether the provided node is a leaf (i.e. has no children), or not. Declaration public static bool IsLeaf<TEdge, TNode>(this IRecImmDictIndexedTreeNode<TEdge, TNode> node) where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Parameters Type Name Description IRecImmDictIndexedTreeNode <TEdge, TNode> node The node whose children have to be checked. Returns Type Description System.Boolean Type Parameters Name Description TEdge TNode"
  },
  "api/MoreStructures.RecImmTrees.TreePath-2.html": {
    "href": "api/MoreStructures.RecImmTrees.TreePath-2.html",
    "title": "Class TreePath<TEdge, TNode>",
    "keywords": "Class TreePath<TEdge, TNode> An immutable sequence of TNode , where each node is child of its predecessor and parent of its successor and where node relationships are stored in TEdge instances. Inheritance System.Object TreePath<TEdge, TNode> Implements System.IEquatable < TreePath <TEdge, TNode>> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.RecImmTrees Assembly : MoreStructures.dll Syntax public class TreePath<TEdge, TNode> : IEquatable<TreePath<TEdge, TNode>> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge The type of edges of the specific structure. TNode The type of nodes of the specific structure. Remarks Immutability is guaranteed by using ValueReadOnlyDictionary<TKey, TValue> . Constructors | Improve this Doc View Source TreePath() Builds an empty path, i.e. an empty sequence of nodes. Declaration public TreePath() | Improve this Doc View Source TreePath(TEdge, TNode) Builds a path composed of a single node with its incoming edge. Declaration public TreePath(TEdge edge, TNode node) Parameters Type Name Description TEdge edge The edge leading to the node. TNode node The node defining the singleton path. | Improve this Doc View Source TreePath(IEnumerable<KeyValuePair<TEdge, TNode>>) An immutable sequence of TNode , where each node is child of its predecessor and parent of its successor and where node relationships are stored in TEdge instances. Declaration public TreePath(IEnumerable<KeyValuePair<TEdge, TNode>> PathNodes) Parameters Type Name Description IEnumerable < KeyValuePair <TEdge, TNode>> PathNodes The sequence of nodes respecting the parent-child relationship. Remarks Immutability is guaranteed by using ValueReadOnlyDictionary<TKey, TValue> . | Improve this Doc View Source TreePath((TEdge edge, TNode node)[]) Builds a path composed of the provided couples of edges and nodes. Declaration public TreePath(params (TEdge edge, TNode node)[] pathNodes) Parameters Type Name Description System.ValueTuple <TEdge, TNode>[] pathNodes An array of couples (edge, node). Properties | Improve this Doc View Source PathNodes A readonly view of the private collection of path TNode instances. Declaration public IEnumerable<KeyValuePair<TEdge, TNode>> PathNodes { get; } Property Value Type Description IEnumerable < KeyValuePair <TEdge, TNode>> Methods | Improve this Doc View Source ToString() Uses a IStringifier<TEdge, TNode> to generate the string. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Implements System.IEquatable<T> Extension Methods TreePathExtensions.Concat<TEdge, TNode>(TreePath<TEdge, TNode>, TreePath<TEdge, TNode>) TreePathExtensions.Append<TEdge, TNode>(TreePath<TEdge, TNode>, TEdge, TNode) SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.TreePathExtensions.html": {
    "href": "api/MoreStructures.RecImmTrees.TreePathExtensions.html",
    "title": "Class TreePathExtensions",
    "keywords": "Class TreePathExtensions Extension methods for TreePath<TEdge, TNode> . Inheritance System.Object TreePathExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees Assembly : MoreStructures.dll Syntax public static class TreePathExtensions Methods | Improve this Doc View Source Append<TEdge, TNode>(TreePath<TEdge, TNode>, TEdge, TNode) Append the provided node with its incoming edge to the provided path, bulding a new path. Declaration public static TreePath<TEdge, TNode> Append<TEdge, TNode>(this TreePath<TEdge, TNode> path, TEdge edge, TNode node) where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Parameters Type Name Description TreePath <TEdge, TNode> path The path, to appended the node and the edge to. TEdge edge The edge, pointing to the node to be appended. TNode node The node to be appended. Returns Type Description TreePath <TEdge, TNode> A new path, whose nodes are the concatenation of the nodes of the provided path and the one appended. Type Parameters Name Description TEdge TNode | Improve this Doc View Source Concat<TEdge, TNode>(TreePath<TEdge, TNode>, TreePath<TEdge, TNode>) Builds a new path of nodes, appending the nodes of the second path to the first path. Declaration public static TreePath<TEdge, TNode> Concat<TEdge, TNode>(this TreePath<TEdge, TNode> first, TreePath<TEdge, TNode> second) where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Parameters Type Name Description TreePath <TEdge, TNode> first The path, to append nodes to. TreePath <TEdge, TNode> second The path, whose nodes have to be appended. Returns Type Description TreePath <TEdge, TNode> A new path, whose nodes are the concatenation of the nodes of the two paths. Type Parameters Name Description TEdge TNode"
  },
  "api/MoreStructures.RecImmTrees.Visitor.BreadthFirstTraversal-2.html": {
    "href": "api/MoreStructures.RecImmTrees.Visitor.BreadthFirstTraversal-2.html",
    "title": "Class BreadthFirstTraversal<TEdge, TNode>",
    "keywords": "Class BreadthFirstTraversal<TEdge, TNode> Base class for all BFT strategies, i.e. all traversing strategies which visit all the nodes at the current depth, along any path of the tree, before going deeper or shallower, exploring nodes with higher or lower depth. Inheritance System.Object TreeTraversal <TEdge, TNode> BreadthFirstTraversal<TEdge, TNode> FullyIterativeBreadthFirstTraversal<TEdge, TNode> FullyRecursiveBreadthFirstTraversal<TEdge, TNode> Implements IVisitStrategy <TNode, TreeTraversalVisit <TEdge, TNode>> Inherited Members TreeTraversal<TEdge, TNode>.TraversalOrder TreeTraversal<TEdge, TNode>.ChildrenSorter TreeTraversal<TEdge, TNode>.Visit(TNode) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees.Visitor Assembly : MoreStructures.dll Syntax public abstract class BreadthFirstTraversal<TEdge, TNode> : TreeTraversal<TEdge, TNode>, IVisitStrategy<TNode, TreeTraversalVisit<TEdge, TNode>> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge TNode Remarks TRAVERSAL VS VISIT The word \"traversal\" in TreeTraversal<TEdge, TNode> and its derivations, is here used with narrower scope than the word \"visit\" in IVisitStrategy<TNode, TVisitContext> . - \"Traversal\" is used here as common class between DFS and BFS, as a visit strategy that starts from the root of the tree and proceeds downwards, following edges and terminating when leafs are reached. - \"Visit\" is used in a more general sense, as any algorithm which \"touches\" 0 or more nodes of the tree, walking the tree in any possible way (up, down, sideways, ...). Examples Given the following tree structure: 0 |- 0 -> 1 | |- 1 -> 2 | |- 2 -> 3 | | |- 3 -> 4 | |- 4 -> 5 |- 5 -> 6 |- 6 -> 7 |- 7 -> 8 |- 8 -> 9 |- 9 -> 10 A BFT visit strategy \"parent first\" would visit nodes and edges in either of the following ways, depending on how children are sorted (lower-id edge first, lower-id edge last, median-id edge first, ...): - { (null, 0), (0, 1), (5, 6), (6, 7), (1, 2), (2, 3), (4, 5), (7, 8), (3, 4), (8, 9), (9, 10) } - { (null, 0), (6, 7), (5, 6), (0, 1), (7, 8), (4, 5), (2, 3), (1, 2), (9, 10), (8, 9), (3, 4) } - { (null, 0), (5, 6), (6, 7), (0, 1), (7, 8), (2, 3), (4, 5), (1, 2), (9, 10), (8, 9), (3, 4) } - ... A BFT visit strategy \"children first\" would visit nodes and edges in either of the following ways, depending on how children are sorted: - { (3, 4), (8, 9), (9, 10), (1, 2), (2, 3), (4, 5), (7, 8), (0, 1), (5, 6), (6, 7), (null, 0) } - { (9, 10), (8, 9), (3, 4), (7, 8), (4, 5), (2, 3), (1, 2), (6, 7), (5, 6), (0, 1), (null, 0) } - ... Implements IVisitStrategy<TNode, TVisitContext> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Visitor.DepthFirstTraversal-2.html": {
    "href": "api/MoreStructures.RecImmTrees.Visitor.DepthFirstTraversal-2.html",
    "title": "Class DepthFirstTraversal<TEdge, TNode>",
    "keywords": "Class DepthFirstTraversal<TEdge, TNode> Base class for all DFS strategies, i.e. all traversing strategies which goes in depth as far as possible along each path of the tree, only backtracking when a leaf is reached. Inheritance System.Object TreeTraversal <TEdge, TNode> DepthFirstTraversal<TEdge, TNode> FullyIterativeDepthFirstTraversal<TEdge, TNode> FullyRecursiveDepthFirstTraversal<TEdge, TNode> Implements IVisitStrategy <TNode, TreeTraversalVisit <TEdge, TNode>> Inherited Members TreeTraversal<TEdge, TNode>.TraversalOrder TreeTraversal<TEdge, TNode>.ChildrenSorter TreeTraversal<TEdge, TNode>.Visit(TNode) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees.Visitor Assembly : MoreStructures.dll Syntax public abstract class DepthFirstTraversal<TEdge, TNode> : TreeTraversal<TEdge, TNode>, IVisitStrategy<TNode, TreeTraversalVisit<TEdge, TNode>> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge TNode Remarks TRAVERSAL VS VISIT The word \"traversal\" in TreeTraversal<TEdge, TNode> and its derivations, is here used with narrower scope than the word \"visit\" in IVisitStrategy<TNode, TVisitContext> . - \"Traversal\" is used here as common class between DFS and BFS, as a visit strategy that starts from the root of the tree and proceeds downwards, following edges and terminating when leafs are reached. - \"Visit\" is used in a more general sense, as any algorithm which \"touches\" 0 or more nodes of the tree, walking the tree in any possible way (up, down, sideways, ...). Examples Given the following tree structure: 0 |- 0 -> 1 | |- 1 -> 2 | |- 2 -> 3 | | |- 3 -> 4 | |- 4 -> 5 |- 5 -> 6 |- 6 -> 7 |- 7 -> 8 |- 8 -> 9 |- 9 -> 10 A DFS visit strategy \"parent first\" would visit nodes and edges in either of the following ways, depending on how children are sorted (lower-id edge first, lower-id edge last, median-id edge first, ...): - { (null, 0), (0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10) } - { (null, 0), (6, 7), (7, 8), (9, 10), (8, 9), (5, 6), (0, 1), (4, 5), (2, 3), (3, 4), (1, 2) } - { (null, 0), (5, 6), (6, 7), (7, 8), (9, 10), (8, 9), (0, 1), (2, 3), (3, 4), (4, 5), (1, 2) } - ... A DFS visit strategy \"children first\" would visit nodes and edges in either of the following ways, depending on how children are sorted: - { (1, 2), (3, 4), (2, 3), (4, 5), (0, 1), (5, 6), (8, 9), (9, 10), (7, 8), (6, 7), (null, 0) } - { (9, 10), (8, 9), (7, 8), (6, 7), (5, 6), (4, 5), (3, 4), (2, 3), (1, 2), (0, 1), (null, 0) } - ... Implements IVisitStrategy<TNode, TVisitContext> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Visitor.FullyIterativeBreadthFirstTraversal-2.html": {
    "href": "api/MoreStructures.RecImmTrees.Visitor.FullyIterativeBreadthFirstTraversal-2.html",
    "title": "Class FullyIterativeBreadthFirstTraversal<TEdge, TNode>",
    "keywords": "Class FullyIterativeBreadthFirstTraversal<TEdge, TNode> A lazy, fully-iterative, breadth-first IVisitStrategy<TNode, TVisitContext> implementation, i.e. a traversing strategy which visits all the nodes at the current depth, along any path of the tree, before going deeper or shallower, exploring nodes with higher or lower depth. Inheritance System.Object TreeTraversal <TEdge, TNode> BreadthFirstTraversal <TEdge, TNode> FullyIterativeBreadthFirstTraversal<TEdge, TNode> Implements IVisitStrategy <TNode, TreeTraversalVisit <TEdge, TNode>> Inherited Members TreeTraversal<TEdge, TNode>.TraversalOrder TreeTraversal<TEdge, TNode>.ChildrenSorter TreeTraversal<TEdge, TNode>.Visit(TNode) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees.Visitor Assembly : MoreStructures.dll Syntax public class FullyIterativeBreadthFirstTraversal<TEdge, TNode> : BreadthFirstTraversal<TEdge, TNode>, IVisitStrategy<TNode, TreeTraversalVisit<TEdge, TNode>> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge TNode Remarks ADVANTAGES AND DISADVANTAGES Methods | Improve this Doc View Source Visit(TNode) Lazily and iteratively visits the structure of the provided node , returning the sequence of IRecImmDictIndexedTreeNode<TEdge, TNode> of the structure, in breadth-first order. Declaration public override IEnumerable<TreeTraversalVisit<TEdge, TNode>> Visit(TNode node) Parameters Type Name Description TNode node The node on where to start visit the structure. Returns Type Description IEnumerable < TreeTraversalVisit <TEdge, TNode>> A sequence emitting (node, visit context) couples, in the visit order defined by the visit strategy. Overrides MoreStructures.RecImmTrees.Visitor.TreeTraversal<TEdge, TNode>.Visit(TNode) Remarks ALGORITHM The algorithm performs a double walk: - The first walk is of the nodes of the tree structure and always proceeds top-down, enqueuing each encountered child for each node into a \"traversal\" , which is used to reproduce the breadth-first order. - The first walk also enqueues each encountered node into a \"visit\" , if the TraversalOrder is ParentFirst , or it pushes it onto a \"visit\" , if it is ChildrenFirst . - The second walk goes through the \"visit\" queue/stack, yielding to the output sequence, so that the client code implementing the visitor can lazily process the nodes. COMPLEXITY Each of the walk goes through all the n nodes and n - 1 edges of the tree. Each walk uses a O(1) insertion and extraction data structure, which contains at most n elements of constant size (reference to the node, reference to its parent, reference to its incoming edge). Time Complexity is O(n) for the first walk, when the visit queue/stack is populated and no actual node visit is performed, and O(n) for the second walk, when the actual visit of all nodes is performed. So O(n) in total. Space Complexity is O(2n) for the first walk, due to the traversal and visit queue/stack being allocated and populated, and O(n) for the second walk, when the actual visit of all nodes is performed. So O(n) in total. Implements IVisitStrategy<TNode, TVisitContext> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Visitor.FullyIterativeDepthFirstTraversal-2.html": {
    "href": "api/MoreStructures.RecImmTrees.Visitor.FullyIterativeDepthFirstTraversal-2.html",
    "title": "Class FullyIterativeDepthFirstTraversal<TEdge, TNode>",
    "keywords": "Class FullyIterativeDepthFirstTraversal<TEdge, TNode> A lazy, fully-iterative, depth-first IVisitStrategy<TNode, TVisitContext> implementation, i.e. a traversing strategy which goes in depth as far as possible along each path of the tree, only backtracking when a leaf is reached. Inheritance System.Object TreeTraversal <TEdge, TNode> DepthFirstTraversal <TEdge, TNode> FullyIterativeDepthFirstTraversal<TEdge, TNode> Implements IVisitStrategy <TNode, TreeTraversalVisit <TEdge, TNode>> Inherited Members TreeTraversal<TEdge, TNode>.TraversalOrder TreeTraversal<TEdge, TNode>.ChildrenSorter TreeTraversal<TEdge, TNode>.Visit(TNode) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees.Visitor Assembly : MoreStructures.dll Syntax public class FullyIterativeDepthFirstTraversal<TEdge, TNode> : DepthFirstTraversal<TEdge, TNode>, IVisitStrategy<TNode, TreeTraversalVisit<TEdge, TNode>> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge TNode Remarks ADVANTAGES AND DISADVANTAGES Methods | Improve this Doc View Source Visit(TNode) Lazily and iteratively visits the structure of the provided node , returning the sequence of IRecImmDictIndexedTreeNode<TEdge, TNode> of the structure, in depth-first order. Declaration public override IEnumerable<TreeTraversalVisit<TEdge, TNode>> Visit(TNode node) Parameters Type Name Description TNode node The node on where to start visit the structure. Returns Type Description IEnumerable < TreeTraversalVisit <TEdge, TNode>> A sequence emitting (node, visit context) couples, in the visit order defined by the visit strategy. Overrides MoreStructures.RecImmTrees.Visitor.TreeTraversal<TEdge, TNode>.Visit(TNode) Remarks ALGORITHM The algorithm uses a : - At the beginning the stack contains only a frame with the root node, no parent node nor incoming edge and with a System.Boolean indicating the children for this node haven't been added to the stack yet; - Then each frame at the top of the stack is popped out and processed, until the stack is empty. - If the node being processed has the \"children stacked\" flag not set, all children are stacked up. The node itself is also stacked up, again, this time with the \"children stacked\" flag set. - If the node being processed has the \"children stacked\" flag set, or is a leaf, it's yielded to the output sequence, so that the client code implementing the visitor can lazily process the nodes. COMPLEXITY - Each of the n nodes and n - 1 edges of the tree is visited at most twice: the first time with the \"children stacked\" flag unset and a second time with the flag set. Leafs are only visited once, since they have no children and don't have to wait for their children to be visited. - ChildrenSorter can also increase time and space complexity, especially if it perform an actual sorting of nodes. For example, if the sorter takes n * log(n) time - The emitted by ChildrenSorter is reversed to be pushed onto the stack in the right order, and that takes additional O(n - 1) total space, since there are n - 1 edges, which are 1-to-1 with nodes in the tree. - Each frame processing of a node with the \"children stacked\" flag set takes constant time (e.g.to check traversal order) and space (e.g. to extract parent node, incoming edge and node itself from the frame and to build a TreeTraversalVisit<TEdge, TNode> object for the visit). - Time Complexity is O(n * Ts) in total, where Ts is the amortized Time Complexity of ChildrenSorter per edge/node. Taking into account the visit of each emitted node, Time Complexity is O(n * Ts * Tv), where Tv is the Time Complexity of the visitor per node. - Space Complexity is O(n * Ss) in total, where Ss is the amortized Space Complexity of ChildrenSorter per edge/node. Taking into account the visit of each emitted node, Space Complexity is O(n * (Ss + Sv)), where Sv is the Space Complexity of the visitor per node. Implements IVisitStrategy<TNode, TVisitContext> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Visitor.FullyRecursiveBreadthFirstTraversal-2.html": {
    "href": "api/MoreStructures.RecImmTrees.Visitor.FullyRecursiveBreadthFirstTraversal-2.html",
    "title": "Class FullyRecursiveBreadthFirstTraversal<TEdge, TNode>",
    "keywords": "Class FullyRecursiveBreadthFirstTraversal<TEdge, TNode> A lazy, fully-recursive, breadth-first IVisitStrategy<TNode, TVisitContext> implementation, i.e. a traversing strategy which visits all the nodes at the current depth, along any path of the tree, before going deeper or shallower, exploring nodes with higher or lower depth. Inheritance System.Object TreeTraversal <TEdge, TNode> BreadthFirstTraversal <TEdge, TNode> FullyRecursiveBreadthFirstTraversal<TEdge, TNode> Implements IVisitStrategy <TNode, TreeTraversalVisit <TEdge, TNode>> Inherited Members TreeTraversal<TEdge, TNode>.TraversalOrder TreeTraversal<TEdge, TNode>.ChildrenSorter TreeTraversal<TEdge, TNode>.Visit(TNode) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees.Visitor Assembly : MoreStructures.dll Syntax public class FullyRecursiveBreadthFirstTraversal<TEdge, TNode> : BreadthFirstTraversal<TEdge, TNode>, IVisitStrategy<TNode, TreeTraversalVisit<TEdge, TNode>> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge TNode Remarks ADVANTAGES AND DISADVANTAGES Implemented fully recursively, so limited by stack depth and usable with tree of a \"reasonable\" height. Methods | Improve this Doc View Source Visit(TNode) Lazily and recursively visits the structure of the provided node , returning the sequence of IRecImmDictIndexedTreeNode<TEdge, TNode> of the structure, in breadth-first order. Declaration public override IEnumerable<TreeTraversalVisit<TEdge, TNode>> Visit(TNode node) Parameters Type Name Description TNode node The node on where to start visit the structure. Returns Type Description IEnumerable < TreeTraversalVisit <TEdge, TNode>> A sequence emitting (node, visit context) couples, in the visit order defined by the visit strategy. Overrides MoreStructures.RecImmTrees.Visitor.TreeTraversal<TEdge, TNode>.Visit(TNode) Remarks ALGORITHM - The algorithm first lazily visits all nodes in structure in natural recursion/depth-first order, returning an instance of all nodes with their level in the structure. - Then, it lazily sort and visit them level by level, according to TraversalOrder , yielding to the output sequence, so that the client code implementing the visitor can lazily process the nodes. COMPLEXITY - Excluding visitor, constant time work is done for each of the n nodes of the tree (such as destructuring of items and construction of the input record for the recursive call). - Recursive traversal, as well as sorting, are lazily executed. Iteration-cost is constant w.r.t. n. ChildrenSorter cost depends on the actual algorithm used. When no sorting, Counting Sort or QuickSort is applied (respectively O(1), O(n), O(n * log(n)), the cost is tipically equalized or exceeded by sorting cost (see below). - So Time Complexity is dominated by the two operations on the generated by the recursive traversal: sorting and visitor. - Sorting done on the of all the n nodes retrieved during recursive traversal via the LINQ functionalities and . - Visitor is client code invoked during iteration of the output sequence, containing each of the n nodes of the sorted . - If the size of alphabet of elements of the tree is a small constant c, sorting could be done in linear time via Counting Sort. Otherwise, a comparison-based sorting takes at best a time proportional to n * log(n). However, LINQ sorting by and is QuickSort based, and has a O(n * log(n)) average runtime, with O(n^2) worst case. In conclusion: - Time Complexity is O(n * (log(n) + Ts)), where Ts is the amortized time cost of ChildrenSorter per node. Taking into account the visit of each emitted node, Time Complexity is O(n * (log(n) + Ts + Tv)), where Tv is the time cost of the visitor per node. - Space Complexity is O(n). Taking into account the visit of each emitted node, Space Complexity is O(n * Sv), where Sv is the space cost of visitor per node. Implements IVisitStrategy<TNode, TVisitContext> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Visitor.FullyRecursiveDepthFirstTraversal-2.html": {
    "href": "api/MoreStructures.RecImmTrees.Visitor.FullyRecursiveDepthFirstTraversal-2.html",
    "title": "Class FullyRecursiveDepthFirstTraversal<TEdge, TNode>",
    "keywords": "Class FullyRecursiveDepthFirstTraversal<TEdge, TNode> A lazy, fully-recursive, depth-first IVisitStrategy<TNode, TVisitContext> implementation, i.e. a traversing strategy which goes in depth as far as possible along each path of the tree, only backtracking when a leaf is reached. Inheritance System.Object TreeTraversal <TEdge, TNode> DepthFirstTraversal <TEdge, TNode> FullyRecursiveDepthFirstTraversal<TEdge, TNode> Implements IVisitStrategy <TNode, TreeTraversalVisit <TEdge, TNode>> Inherited Members TreeTraversal<TEdge, TNode>.TraversalOrder TreeTraversal<TEdge, TNode>.ChildrenSorter TreeTraversal<TEdge, TNode>.Visit(TNode) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees.Visitor Assembly : MoreStructures.dll Syntax public class FullyRecursiveDepthFirstTraversal<TEdge, TNode> : DepthFirstTraversal<TEdge, TNode>, IVisitStrategy<TNode, TreeTraversalVisit<TEdge, TNode>> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge TNode Remarks ADVANTAGES AND DISADVANTAGES Implemented fully recursively, so limited by stack depth and usable with tree of a \"reasonable\" height. Methods | Improve this Doc View Source Visit(TNode) Lazily and recursively visits the structure of the provided node , returning the sequence of IRecImmDictIndexedTreeNode<TEdge, TNode> of the structure, in depth-first order. Declaration public override IEnumerable<TreeTraversalVisit<TEdge, TNode>> Visit(TNode node) Parameters Type Name Description TNode node The node on where to start visit the structure. Returns Type Description IEnumerable < TreeTraversalVisit <TEdge, TNode>> A sequence emitting (node, visit context) couples, in the visit order defined by the visit strategy. Overrides MoreStructures.RecImmTrees.Visitor.TreeTraversal<TEdge, TNode>.Visit(TNode) Remarks ALGORITHM - The algorithm visits all nodes in structure in natural recursion/depth-first order, yielding to the output sequence, so that the client code implementing the visitor can lazily process the nodes. COMPLEXITY - Excluding visitor, constant time work is done for each of the n nodes of the tree (such as construction of the input record for the visitor). - Iteration-cost is constant w.r.t. n. ChildrenSorter cost depends on the actual algorithm used. - So Time Complexity is dominated by ChildrenSorter and visitor. In conclusion: - Time Complexity is O(n * Ts), where Ts is the amortized time cost of ChildrenSorter per node. Taking into account the visit of each emitted node, Time Complexity is O(n * (Ts + Tv)), where Tv is the time cost of the visitor per node. - Space Complexity is O(n). Taking into account the visit of each emitted node, Space Complexity is O(n * Sv), where Sv is the space cost of visitor per node. Implements IVisitStrategy<TNode, TVisitContext> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Visitor.html": {
    "href": "api/MoreStructures.RecImmTrees.Visitor.html",
    "title": "Namespace MoreStructures.RecImmTrees.Visitor",
    "keywords": "Namespace MoreStructures.RecImmTrees.Visitor Classes BreadthFirstTraversal<TEdge, TNode> Base class for all BFT strategies, i.e. all traversing strategies which visit all the nodes at the current depth, along any path of the tree, before going deeper or shallower, exploring nodes with higher or lower depth. DepthFirstTraversal<TEdge, TNode> Base class for all DFS strategies, i.e. all traversing strategies which goes in depth as far as possible along each path of the tree, only backtracking when a leaf is reached. FullyIterativeBreadthFirstTraversal<TEdge, TNode> A lazy, fully-iterative, breadth-first IVisitStrategy<TNode, TVisitContext> implementation, i.e. a traversing strategy which visits all the nodes at the current depth, along any path of the tree, before going deeper or shallower, exploring nodes with higher or lower depth. FullyIterativeDepthFirstTraversal<TEdge, TNode> A lazy, fully-iterative, depth-first IVisitStrategy<TNode, TVisitContext> implementation, i.e. a traversing strategy which goes in depth as far as possible along each path of the tree, only backtracking when a leaf is reached. FullyRecursiveBreadthFirstTraversal<TEdge, TNode> A lazy, fully-recursive, breadth-first IVisitStrategy<TNode, TVisitContext> implementation, i.e. a traversing strategy which visits all the nodes at the current depth, along any path of the tree, before going deeper or shallower, exploring nodes with higher or lower depth. FullyRecursiveDepthFirstTraversal<TEdge, TNode> A lazy, fully-recursive, depth-first IVisitStrategy<TNode, TVisitContext> implementation, i.e. a traversing strategy which goes in depth as far as possible along each path of the tree, only backtracking when a leaf is reached. TreeTraversal<TEdge, TNode> Base class for all tree traversal strategies, such as DepthFirstTraversal<TEdge, TNode> and BreadthFirstTraversal<TEdge, TNode> strategies, which are different strategies of traversing a IRecImmDictIndexedTreeNode<TEdge, TNode> structure top-down. TreeTraversalVisit<TEdge, TNode> The emitted information of a root-to-leaf traversal of a tree composed of nodes and edges. Interfaces IVisitStrategy<TNode, TVisitContext> A visit strategy of IRecImmDictIndexedTreeNode<TEdge, TNode> structures. Can be any way of moving through the structure and touching nodes: partial or exaustive, hierarchical or random, upwards or downwards, etc. Enums TreeTraversalOrder The order of visit of a \"node and its children\" sub-tree."
  },
  "api/MoreStructures.RecImmTrees.Visitor.IVisitStrategy-2.html": {
    "href": "api/MoreStructures.RecImmTrees.Visitor.IVisitStrategy-2.html",
    "title": "Interface IVisitStrategy<TNode, TVisitContext>",
    "keywords": "Interface IVisitStrategy<TNode, TVisitContext> A visit strategy of IRecImmDictIndexedTreeNode<TEdge, TNode> structures. Can be any way of moving through the structure and touching nodes: partial or exaustive, hierarchical or random, upwards or downwards, etc. Namespace : MoreStructures.RecImmTrees.Visitor Assembly : MoreStructures.dll Syntax public interface IVisitStrategy<in TNode, out TVisitContext> Type Parameters Name Description TNode The type of nodes of the specific structure. TVisitContext The type of visit context. Depends on the IVisitStrategy<TNode, TVisitContext> used. Methods | Improve this Doc View Source Visit(TNode) Lazily visits the structure of the provided node , returning an enumerable of the sequence of IRecImmDictIndexedTreeNode<TEdge, TNode> of the structure, in the order defined by this IVisitStrategy<TNode, TVisitContext> . Declaration IEnumerable<TVisitContext> Visit(TNode node) Parameters Type Name Description TNode node The node on where to start visit the structure. Returns Type Description IEnumerable <TVisitContext> A sequence emitting (node, visit context) couples, in the visit order defined by the visit strategy. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Visitor.TreeTraversal-2.html": {
    "href": "api/MoreStructures.RecImmTrees.Visitor.TreeTraversal-2.html",
    "title": "Class TreeTraversal<TEdge, TNode>",
    "keywords": "Class TreeTraversal<TEdge, TNode> Base class for all tree traversal strategies, such as DepthFirstTraversal<TEdge, TNode> and BreadthFirstTraversal<TEdge, TNode> strategies, which are different strategies of traversing a IRecImmDictIndexedTreeNode<TEdge, TNode> structure top-down. Inheritance System.Object TreeTraversal<TEdge, TNode> BreadthFirstTraversal <TEdge, TNode> DepthFirstTraversal <TEdge, TNode> Implements IVisitStrategy <TNode, TreeTraversalVisit <TEdge, TNode>> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees.Visitor Assembly : MoreStructures.dll Syntax public abstract class TreeTraversal<TEdge, TNode> : IVisitStrategy<TNode, TreeTraversalVisit<TEdge, TNode>> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge TNode Remarks TRAVERSAL VS VISIT The word \"traversal\" in TreeTraversal<TEdge, TNode> and its derivations, is here used with narrower scope than the word \"visit\" in IVisitStrategy<TNode, TVisitContext> . - \"Traversal\" is used here as common class between DFS and BFS, as a visit strategy that starts from the root of the tree and proceeds downwards, following edges and terminating when leafs are reached. - \"Visit\" is used in a more general sense, as any algorithm which \"touches\" 0 or more nodes of the tree, walking the tree in any possible way (up, down, sideways, ...). Properties | Improve this Doc View Source ChildrenSorter The order of visit of the children. By default Children is returned as is, and no specific order is imposed to the sequence of (edge, node) couples, during the visit. Declaration public Func<TreeTraversalVisit<TEdge, TNode>, IEnumerable<KeyValuePair<TEdge, TNode>>> ChildrenSorter { get; set; } Property Value Type Description Func < TreeTraversalVisit <TEdge, TNode>, IEnumerable < KeyValuePair <TEdge, TNode>>> Remarks Specifying a well-defined, deterministic order ensures that children are visited in a consistent and reproducible way across executions of the visit. | Improve this Doc View Source TraversalOrder The traversal order between parent and its children, to be applied when visiting the tree. By default ParentFirst is applied, meaning that the parent node is visited before its children. Declaration public TreeTraversalOrder TraversalOrder { get; set; } Property Value Type Description TreeTraversalOrder Methods | Improve this Doc View Source Visit(TNode) Lazily visits the structure of the provided node , returning an enumerable of the sequence of IRecImmDictIndexedTreeNode<TEdge, TNode> of the structure, in the order defined by this IVisitStrategy<TNode, TVisitContext> . Declaration public abstract IEnumerable<TreeTraversalVisit<TEdge, TNode>> Visit(TNode node) Parameters Type Name Description TNode node The node on where to start visit the structure. Returns Type Description IEnumerable < TreeTraversalVisit <TEdge, TNode>> A sequence emitting (node, visit context) couples, in the visit order defined by the visit strategy. Examples Implements IVisitStrategy<TNode, TVisitContext> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Visitor.TreeTraversalOrder.html": {
    "href": "api/MoreStructures.RecImmTrees.Visitor.TreeTraversalOrder.html",
    "title": "Enum TreeTraversalOrder",
    "keywords": "Enum TreeTraversalOrder The order of visit of a \"node and its children\" sub-tree. Namespace : MoreStructures.RecImmTrees.Visitor Assembly : MoreStructures.dll Syntax public enum TreeTraversalOrder Fields Name Description ChildrenFirst First visit all the children nodes, then the parent. ParentFirst First visit the parent node, then its children. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TreeTraversalOrder>(TextWithTerminator)"
  },
  "api/MoreStructures.RecImmTrees.Visitor.TreeTraversalVisit-2.html": {
    "href": "api/MoreStructures.RecImmTrees.Visitor.TreeTraversalVisit-2.html",
    "title": "Class TreeTraversalVisit<TEdge, TNode>",
    "keywords": "Class TreeTraversalVisit<TEdge, TNode> The emitted information of a root-to-leaf traversal of a tree composed of nodes and edges. Inheritance System.Object TreeTraversalVisit<TEdge, TNode> Implements System.IEquatable < TreeTraversalVisit <TEdge, TNode>> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.RecImmTrees.Visitor Assembly : MoreStructures.dll Syntax public class TreeTraversalVisit<TEdge, TNode> : IEquatable<TreeTraversalVisit<TEdge, TNode>> where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode> where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Type Parameters Name Description TEdge The type of edges of the specific structure. TNode The type of nodes of the specific structure. Constructors | Improve this Doc View Source TreeTraversalVisit(TNode, TNode, TEdge, Int32) The emitted information of a root-to-leaf traversal of a tree composed of nodes and edges. Declaration public TreeTraversalVisit(TNode Node, TNode ParentNode, TEdge IncomingEdge, int Level) Parameters Type Name Description TNode Node The visited node. TNode ParentNode The parent of the node being visited. Null when visiting the root node. TEdge IncomingEdge The edge outgoing from the parent, traversed to reach this node. Null when visiting the root node. System.Int32 Level The level of visit: 0 is assigned to the top-level node, 1 to its children, 2 to its grandchildren, etc. Properties | Improve this Doc View Source IncomingEdge Declaration public TEdge IncomingEdge { get; set; } Property Value Type Description TEdge | Improve this Doc View Source Level Declaration public int Level { get; set; } Property Value Type Description System.Int32 | Improve this Doc View Source Node Declaration public TNode Node { get; set; } Property Value Type Description TNode | Improve this Doc View Source ParentNode Declaration public TNode ParentNode { get; set; } Property Value Type Description TNode Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.RotatedTextWithTerminator.html": {
    "href": "api/MoreStructures.RotatedTextWithTerminator.html",
    "title": "Class RotatedTextWithTerminator",
    "keywords": "Class RotatedTextWithTerminator A text string with a terminator character which has been rotated leftwards or rightwards, of a number of positions (0 included). Inheritance System.Object RotatedTextWithTerminator Implements IValueEnumerable < System.Char > IEnumerable < System.Char > System.IEquatable < RotatedTextWithTerminator > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures Assembly : MoreStructures.dll Syntax public class RotatedTextWithTerminator : IValueEnumerable<char>, IEquatable<RotatedTextWithTerminator> Remarks USECASES - A terminator-terminated rotated text is required by Burrows-Wheeler Transform operations, such as inversion. - This object provides type safety, as it allows to tell apart rotated terminator-terminated strings from generic ones. - Consistently using RotatedTextWithTerminator , rather than System.String , in all library functionalities ensures that the invariant of a rotated terminator-terminated string is always respected. - Most string-related functionalities provided by RotatedTextWithTerminator , such as Length and Item[Index] , as well as and System.Collections.IEnumerable support, are delegated to the underlying string. Constructors | Improve this Doc View Source RotatedTextWithTerminator(IEnumerable<Char>, Char, Boolean) A text string with a terminator character which has been rotated leftwards or rightwards, of a number of positions (0 included). Declaration public RotatedTextWithTerminator(IEnumerable<char> RotatedText, char Terminator = '$', bool ValidateInput = true) Parameters Type Name Description System.Collections.IEnumerable < System.Char > RotatedText The text, defined as an of chars and containing the terminator character once, in any position of the text. System.Char Terminator A terminator character, present in the text at most once. If not specified DefaultTerminator is used. System.Boolean ValidateInput Whether the input, and in particular RotatedText should be validated, while this object is created. Validation takes O(n) time, where n = number of chars in RotatedText and can be an heavy operation. Remarks USECASES - A terminator-terminated rotated text is required by Burrows-Wheeler Transform operations, such as inversion. - This object provides type safety, as it allows to tell apart rotated terminator-terminated strings from generic ones. - Consistently using RotatedTextWithTerminator , rather than System.String , in all library functionalities ensures that the invariant of a rotated terminator-terminated string is always respected. - Most string-related functionalities provided by RotatedTextWithTerminator , such as Length and Item[Index] , as well as and System.Collections.IEnumerable support, are delegated to the underlying string. Properties | Improve this Doc View Source Item[Index] Select a part of RotatedText by the provided index (either w.r.t. the start or to the end of the text). Declaration public char this[Index index] { get; } Parameters Type Name Description Index index The index applied to the underlying string. Property Value Type Description System.Char A char containing the selected part. | Improve this Doc View Source Item[TextWithTerminator.ISelector] Select a part of RotatedText by the provided selector. Declaration public string this[TextWithTerminator.ISelector selector] { get; } Parameters Type Name Description TextWithTerminator.ISelector selector Any selector acting on a RotatedTextWithTerminator . Property Value Type Description System.String A string containing the selected part. | Improve this Doc View Source Item[Range] Select a part of RotatedText by the provided range (start index included, end index excluded). Declaration public IEnumerable<char> this[Range range] { get; } Parameters Type Name Description Range range The range applied to the underlying string. Property Value Type Description System.Collections.IEnumerable < System.Char > A sequence of chars containing the selected part. | Improve this Doc View Source Length The total length of RotatedText , including the terminator. Declaration public int Length { get; } Property Value Type Description System.Int32 A positive integer (at least 1). Remarks | Improve this Doc View Source RotatedText Declaration public IEnumerable<char> RotatedText { get; set; } Property Value Type Description System.Collections.IEnumerable < System.Char > A sequence of chars. Remarks Wrapped into a IValueEnumerable<T> to preserve value equality. | Improve this Doc View Source Terminator Declaration public char Terminator { get; set; } Property Value Type Description System.Char A single char. | Improve this Doc View Source ValidateInput Declaration public bool ValidateInput { get; set; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source EndsWith(String) Whether this text ends with suffix . Declaration public bool EndsWith(string suffix) Parameters Type Name Description System.String suffix A terminator-included string. Returns Type Description System.Boolean True if RotatedText ends by suffix . | Improve this Doc View Source GetEnumerator() Returns an enumerator that iterates through the collection of chars of the underlying RotatedText string, including the Terminator char. Declaration public IEnumerator<char> GetEnumerator() Returns Type Description System.Collections.IEnumerator < System.Char > | Improve this Doc View Source StartsWith(String) Whether this text starts with prefix . Declaration public bool StartsWith(string prefix) Parameters Type Name Description System.String prefix A terminator-included string. Returns Type Description System.Boolean True if RotatedText starts by prefix . Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Returns an enumerator that iterates through the collection of chars of the underlying RotatedText string, including the Terminator char. Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description System.Collections.IEnumerator Implements IValueEnumerable<T> IEnumerable<> System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Stacks.ArrayBasedDataStructure-1.html": {
    "href": "api/MoreStructures.Stacks.ArrayBasedDataStructure-1.html",
    "title": "Class ArrayBasedDataStructure<T>",
    "keywords": "Class ArrayBasedDataStructure<T> Exposes properties shared by data structures based on a backing array of items of type T . Inheritance System.Object ArrayBasedDataStructure<T> ArrayListQueue<T> ArrayListStack<T> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Stacks Assembly : MoreStructures.dll Syntax public abstract class ArrayBasedDataStructure<T> Type Parameters Name Description T The type of items, the data structure is composed of. Constructors | Improve this Doc View Source ArrayBasedDataStructure(Int32, Double) Initializes the data structure with an array list of initial capacity equals to the provided capacity . Declaration protected ArrayBasedDataStructure(int capacity = 16, double increasingFactor = 2) Parameters Type Name Description System.Int32 capacity The initial capacity of the backing array. If not specified, DefaultInitialCapacity is used. System.Double increasingFactor Fields | Improve this Doc View Source DefaultIncreasingFactor The default value for IncreasingFactor . Declaration public const double DefaultIncreasingFactor = 2 Field Value Type Description System.Double | Improve this Doc View Source DefaultInitialCapacity The default initial size of the array backing the data structure. Declaration public const int DefaultInitialCapacity = 16 Field Value Type Description System.Int32 Remarks In an array initialized with capacity x, up to x insertions can be done in constant time, with no need for array resizing. Properties | Improve this Doc View Source IncreasingFactor The multiplicative factor used to resize the underlying array, every time it gets full. Declaration public double IncreasingFactor { get; } Property Value Type Description System.Double Remarks Required to be bigger than 1.0. | Improve this Doc View Source Items The array of items, backing this data structure. Declaration protected T[] Items { get; set; } Property Value Type Description T[] Methods | Improve this Doc View Source ResizeItems(Double) Resizes the Items array, applying the provided factor to its length. Declaration protected virtual void ResizeItems(double factor) Parameters Type Name Description System.Double factor The multiplicative factor to be applied to the length of the array. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Stacks.ArrayListStack-1.html": {
    "href": "api/MoreStructures.Stacks.ArrayListStack-1.html",
    "title": "Class ArrayListStack<T>",
    "keywords": "Class ArrayListStack<T> A IStack<T> implementation based on an array list of items. Inheritance System.Object ArrayBasedDataStructure <T> ArrayListStack<T> Implements IStack <T> Inherited Members ArrayBasedDataStructure<T>.DefaultInitialCapacity ArrayBasedDataStructure<T>.DefaultIncreasingFactor ArrayBasedDataStructure<T>.Items ArrayBasedDataStructure<T>.IncreasingFactor ArrayBasedDataStructure<T>.ResizeItems(Double) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Stacks Assembly : MoreStructures.dll Syntax public class ArrayListStack<T> : ArrayBasedDataStructure<T>, IStack<T> Type Parameters Name Description T Remarks ADVANTAGES AND DISADVANTAGES - Compared to an implementation based on a linked list, such as LinkedListStack<T> , it has a lower memory footprint and a lower cost of memory management, due to the fact that a single object made of a contiguous area in memory is used, to store all items. - In particular, no need for per-item additional space is required, as it happens for \"next\" references and objects overhead in linked list-based solutions. - On the flip side, the requirement for a potentially large contiguous chunk of memory in the heap may produce when trying to instantiate or resize stacks of large capacity, especially when the memory is heavily fragmented. - Moreover, each insert which happens when the underlying array has been fully occupied requires work proportional to the current size of the stack, since the underlying array cannot be extended without instantiating a larger array and performing a full copy from the old to the new one. - That means that insertion cost won't be O(1) all the time, but only in average, as amortized complexity over n operations (assuming that IncreasingFactor is left to its default value DefaultIncreasingFactor , or chosen sensibly). - That can be a significant drawback in realtime systems where insertion cost has to be highly predictable and also very low. Constructors | Improve this Doc View Source ArrayListStack(Int32, Double) Declaration public ArrayListStack(int capacity = 16, double increasingFactor = 2) Parameters Type Name Description System.Int32 capacity System.Double increasingFactor Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description System.Int32 Remarks Stored and updated in constant time at each Push(T) and Pop() . Time and Space Complexity are O(1). Methods | Improve this Doc View Source Peek() Declaration public T Peek() Returns Type Description T Remarks Checks and returns the item of the underlying array list at the last index set (which is Count - 1), if it exists. Throws a if the underlying array is empty. Time and Space Complexity are O(1). | Improve this Doc View Source Pop() Declaration public T Pop() Returns Type Description T Remarks First, it retrieves the last item set into the underlying array list (which is the one at index Count - 1). Then, it reset the value of the last item and decreases the Count by 1. Then, if the new Count is smaller than the current capacity by more than twice the IncreasingFactor compoundly (i.e. capacity * increasingFactor^2), the underlying array list is resized to have a new capacity equal to the old capacity times the increasing factor. Finally, it returns the retrieved item as result. Raises an if the array list is empty. Time and Space Complexity are O(1). | Improve this Doc View Source Push(T) Declaration public void Push(T item) Parameters Type Name Description T item Remarks If there is available room in the underlying array, the new item is stored in the first available location and the Count is increased by 1. Otherwise the underlying array is resized by the IncreasingFactor , to accomodate the new item . Time and Space Complexity are O(1) if Count before insertion is strictly smaller than the current capacity. Time and Space Complexity are O(n) if Count before insertion is equal to the current capacity. If the IncreasingFactor is set to a sensible value (e.g. 2.0), the amortized cost over n insertions becomes O(1). Implements IStack<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Stacks.html": {
    "href": "api/MoreStructures.Stacks.html",
    "title": "Namespace MoreStructures.Stacks",
    "keywords": "Namespace MoreStructures.Stacks Classes ArrayBasedDataStructure<T> Exposes properties shared by data structures based on a backing array of items of type T . ArrayListStack<T> A IStack<T> implementation based on an array list of items. LinkedListStack<T> A IStack<T> implementation based on a singly-linked linked list of items. Interfaces IStack<T> Defines the interface common to all Stack implementations for items of type T ."
  },
  "api/MoreStructures.Stacks.IStack-1.html": {
    "href": "api/MoreStructures.Stacks.IStack-1.html",
    "title": "Interface IStack<T>",
    "keywords": "Interface IStack<T> Defines the interface common to all Stack implementations for items of type T . Namespace : MoreStructures.Stacks Assembly : MoreStructures.dll Syntax public interface IStack<T> Type Parameters Name Description T The type of items, the stack is composed of. Remarks DEFINITION - A Stack is a data structure storing items of a generic type T in a LIFO (Last In First Out) fashion. - Items are both inserted and extracted at the top (or begin) of the stack. - Unlike array lists, general random access doesn't come as a easy, performant operation. - Because data insertion and extraction at a single specific spot is priviledged over any other position in the data structure, O(1) non amortized cost of insertion and extraction can be provided in some implementations. - However, arrays and array lists can be used as a backing structure for a stack, and still have O(1) amortized cost within array boundaries and O(1) amortized cost to remove array boundaries constraints. - Items are in a total order relationship and duplicates are supported. Properties | Improve this Doc View Source Count The number of items currently in the stack. Declaration int Count { get; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source Peek() Returns the item on top of the stack, without popping it out from the stack. Declaration T Peek() Returns Type Description T The item of type T currently on top of the stack. | Improve this Doc View Source Pop() Pops the item out from the top of the stack and returns it as a result. Declaration T Pop() Returns Type Description T The item of type T which was on top of the stack. Remarks The item which was on second position at the top of the stack goes on the top after the item on top is popped out. | Improve this Doc View Source Push(T) Push the provided item onto the top of the stack. Declaration void Push(T item) Parameters Type Name Description T item The item of type T to be pushed. Remarks The item which was on top of the stack before this push is pushed down onto second position. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Stacks.LinkedListStack-1.html": {
    "href": "api/MoreStructures.Stacks.LinkedListStack-1.html",
    "title": "Class LinkedListStack<T>",
    "keywords": "Class LinkedListStack<T> A IStack<T> implementation based on a singly-linked linked list of items. Inheritance System.Object LinkedListStack<T> Implements IStack <T> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Stacks Assembly : MoreStructures.dll Syntax public class LinkedListStack<T> : IStack<T> Type Parameters Name Description T Remarks ADVANTAGES AND DISADVANTAGES - Compared to an implementation based on an array list, such as ArrayListStack<T> , it has the advantage of not requiring contiguous memory, for the backing structure storing the items to be allocated. - Items of the linked list are allocated on the heap on demand, one by one, each on requiring only the space to store the value of the item (whose size depends on the definition of the type T ), and the reference to the next node in the list (whose size depends on the bit parallelism of the architecture: typically either 32 or 64 bits). - That minimizes the risk of , due to memory fragmentation, when dealing with large queues. Moreover, it makes the work required for insertion constant and independent from the size of the stack. - The downside is the number of object allocations, which is constant on an array-based implementation, and as high as the number of items when using a linked list. - This introduces more stress on the Garbage Collector and also uses way more memory than an array-based implementation, since each object on the heap has a space overhead required for its memory management. - Moreover the non-contiguous memory layout requires as many \"next\" references as the number of items in the queue, which can be higher than the amount of memory used for the items: e.g. a queue of n System.Int32 requires n * 4 bytes for the actual data and double that amount on a 64 bit architecture to store next references. Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description System.Int32 Remarks Stored and updated in constant time at each Push(T) and Pop() . Time and Space Complexity are O(1). Methods | Improve this Doc View Source Peek() Declaration public T Peek() Returns Type Description T Remarks Checks the front of the underlying linked list. Time and Space Complexity are O(1). | Improve this Doc View Source Pop() Declaration public T Pop() Returns Type Description T Remarks First, it retrieves the item referenced by the head of the underlying linked list. Then, it updates the reference to the head of the linked list, to point to its \"next\". Raises an if the linked list is empty. Time and Space Complexity are O(1). | Improve this Doc View Source Push(T) Declaration public void Push(T item) Parameters Type Name Description T item Remarks Creates a new node wrapping the provided item and sets it as new head of the linked list of items, making it point to the previous head. Time and Space Complexity are O(1). Implements IStack<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Strings.Matching.html": {
    "href": "api/MoreStructures.Strings.Matching.html",
    "title": "Namespace MoreStructures.Strings.Matching",
    "keywords": "Namespace MoreStructures.Strings.Matching Classes Match<TPath> The result of matching a System.String text against a System.String pattern."
  },
  "api/MoreStructures.Strings.Matching.Match-1.html": {
    "href": "api/MoreStructures.Strings.Matching.Match-1.html",
    "title": "Class Match<TPath>",
    "keywords": "Class Match<TPath> The result of matching a System.String text against a System.String pattern. Inheritance System.Object Match<TPath> Implements System.IEquatable < Match <TPath>> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Strings.Matching Assembly : MoreStructures.dll Syntax public sealed class Match<TPath> : IEquatable<Match<TPath>> Type Parameters Name Description TPath The type of path. Depends on the algorithm and the data structure used for pattern matching. Constructors | Improve this Doc View Source Match(Boolean, Int32, Int32, TPath) The result of matching a System.String text against a System.String pattern. Declaration public Match(bool Success, int Begin, int MatchedChars, TPath Path) Parameters Type Name Description System.Boolean Success Whether the text has been completely matched or not. System.Int32 Begin The index in text of the best match. System.Int32 MatchedChars The number of chars matched from the text. TPath Path The path of nodes visited by the matching algorithm. Properties | Improve this Doc View Source Begin Declaration public int Begin { get; set; } Property Value Type Description System.Int32 | Improve this Doc View Source MatchedChars Declaration public int MatchedChars { get; set; } Property Value Type Description System.Int32 | Improve this Doc View Source Path Declaration public TPath Path { get; set; } Property Value Type Description TPath | Improve this Doc View Source Success Declaration public bool Success { get; set; } Property Value Type Description System.Boolean Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Strings.Sorting.CountingSortCharsSorter.html": {
    "href": "api/MoreStructures.Strings.Sorting.CountingSortCharsSorter.html",
    "title": "Class CountingSortCharsSorter",
    "keywords": "Class CountingSortCharsSorter An implementation of ICharsSorter which uses Counting Sort to sort the input. Inheritance System.Object CountingSortCharsSorter Implements ICharsSorter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Strings.Sorting Assembly : MoreStructures.dll Syntax public class CountingSortCharsSorter : ICharsSorter Remarks ADVANTAGES - The algorithm is a Counting Sort adaptation and specialization to strings, seen as lists of chars. - It leverages a runtime linear in the size of the input and its alphabet, which is better than any worst-case scenario of a comparison-based algorithm, such as QuickSort or MergeSort. - However, because its runtime depends not only on the size of the input, but also on the size of the alphabet, it is suitable for scenarios of small alphabets only, or at least when there is an upper bound on the number of distinct chars in the input (and they are somehow known in advance), which is small enough to fit the histogram of occurrences in memory. - For example: genome sequences can be mapped to 4-chars strings; English lower-case sentences are limited to 26 chars plus space, punctuation, etc; digit sequences consist of an alphabet of 10 chars only etc. - It is not a good fit for scenarios where the number of distinct values can be very high, such as an unconstrained Unicode string. ALGORITHM - First, a histogram of the occurrences in the input of all the chars in the alphabet is created, going through each char of the input and incrementing the counter of the char in the histogram. - Then the histogram is made cumulative, by going through each item of the histogram array, starting from the second item, and cumulating the previous sum into the value at the current position. - Finally, all chars of the input are iterated once again, in reverse order, to build the order list, i.e. the list of positions. COMPLEXITY - Building the histogram requires iterating over all the n chars of the input. - The histogram has a size equal to the size of the alphabet, sigma, of the input. - Making the histogram cumulative requires going through each item of it, and there are sigma items. - Finally, the second pass of the string means n more iterations, each one doing constant-time work. - The second pass builds the order list, which is a new array of n items (one per index of the input). - Therefore, Time Complexity is O(n + sigma) and Space Complexity is O(n + sigma). Constructors | Improve this Doc View Source CountingSortCharsSorter(IDictionary<Char, Int32>) Declaration public CountingSortCharsSorter(IDictionary<char, int> alphabet) Parameters Type Name Description IDictionary < System.Char , System.Int32 > alphabet Remarks Properties | Improve this Doc View Source Alphabet The alphabet of the input, i.e. the list of all System.Char potentially appearing in the input string, mapped to an alphabet index. Declaration public IDictionary<char, int> Alphabet { get; } Property Value Type Description IDictionary < System.Char , System.Int32 > Remarks Required by the Counting Sort algorithm, which builds the histogram of occurrences in the input, of all chars of the alphabet of the input. Methods | Improve this Doc View Source Sort(String) Declaration public IList<int> Sort(string input) Parameters Type Name Description System.String input Returns Type Description IList < System.Int32 > Remarks Implements ICharsSorter Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Strings.Sorting.html": {
    "href": "api/MoreStructures.Strings.Sorting.html",
    "title": "Namespace MoreStructures.Strings.Sorting",
    "keywords": "Namespace MoreStructures.Strings.Sorting Classes CountingSortCharsSorter An implementation of ICharsSorter which uses Counting Sort to sort the input. QuickSortCharsSorter An implementation of ICharsSorter which uses QuickSort to sort the input. Interfaces ICharsSorter An algorithm sorting the chars of the provided string."
  },
  "api/MoreStructures.Strings.Sorting.ICharsSorter.html": {
    "href": "api/MoreStructures.Strings.Sorting.ICharsSorter.html",
    "title": "Interface ICharsSorter",
    "keywords": "Interface ICharsSorter An algorithm sorting the chars of the provided string. Namespace : MoreStructures.Strings.Sorting Assembly : MoreStructures.dll Syntax public interface ICharsSorter Methods | Improve this Doc View Source Sort(String) Sorts the chars of input , returning the list of positions of each of the chars in input (i.e. the System.Int32 value item of the order list O at index i, O[i], is the position in the input string, of the System.Char in the sorted string at index i). Declaration IList<int> Sort(string input) Parameters Type Name Description System.String input The string whose System.Char items have to be sorted. Returns Type Description IList < System.Int32 > A list of position in the sorted string: 0 being the first in the order, 1 the second, etc. Examples Sorting the input string \"cabcba\" gives the position list { 1, 5, 2, 4, 0, 5 } , because: the sorted string is \"aabbcc\" ; the System.Char in the sorted string at index 0 is 'a' and the position in the input string of the first 'a' is 1 ; the System.Char in the sorted string at index 1 is 'a' and the position in the input string of the second 'a' is 5 ; the System.Char in the sorted string at index 2 is 'b' and the position in the input string of the first 'b' is 2 ; etc. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Strings.Sorting.QuickSortCharsSorter.html": {
    "href": "api/MoreStructures.Strings.Sorting.QuickSortCharsSorter.html",
    "title": "Class QuickSortCharsSorter",
    "keywords": "Class QuickSortCharsSorter An implementation of ICharsSorter which uses QuickSort to sort the input. Inheritance System.Object QuickSortCharsSorter Implements ICharsSorter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Strings.Sorting Assembly : MoreStructures.dll Syntax public class QuickSortCharsSorter : ICharsSorter Remarks ADVANTAGES The algorithm uses the QuickSort implementation of LINQ to sort strings, seen as lists of chars. Being based on a comparison-based sorting algorithm, unlike the Counting Sort implementation, it doesn't leverage a linear runtime. However, its runtime only depends on the size of the input, and it doesn't depend on the size of the alphabet. Because of that, it is suitable for scenarios of large alphabets, or where there is no upper bound on the number of distinct chars in the input, other than the size of the alphabet. For example: when the input string to be sorted is an unconstrained Unicode string. ALGORITHM - It uses the LINQ-provided QuickSort, to sort the couples defined by (index, char), for each char of the text, in ascending order. - Then, it selects the indexes from the sorted sequence of instances, building and returning the position list. COMPLEXITY - The execution of the QuickSort has a runtime of O(n * log(n)). - Output is not produced in-place, but a new list of n items is created. - Therefore, Time Complexity is O(n * log(n)) and Space Complexity is O(n). Constructors | Improve this Doc View Source QuickSortCharsSorter(Nullable<Char>) Declaration public QuickSortCharsSorter(char? maybeTerminator) Parameters Type Name Description System.Nullable < System.Char > maybeTerminator The char, if any, to be treated as terminator char when comparing chars of the input. If not specified, for System.Char will be used for char comparison. Remarks Methods | Improve this Doc View Source Sort(String) Declaration public IList<int> Sort(string input) Parameters Type Name Description System.String input Returns Type Description IList < System.Int32 > Remarks Implements ICharsSorter Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays..html": {
    "href": "api/MoreStructures.SuffixArrays..html",
    "title": "Class",
    "keywords": "Class A Partial MoreStructures.SuffixArrays.SuffixArray which only contains the indexes of the Suffix Array which are multiple of a given constant (0, k, 2k, ...), indexed by their position in the complete Suffix Array. Inheritance System.Object Implements System.IEquatable < MoreStructures.SuffixArrays. > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays Assembly : MoreStructures.dll Syntax public class : IEquatable<> Remarks MoreStructures.SuffixArrays.SuffixArray is a space-efficient alternative to SuffixTreeNode structures, due to their (n) with c=1 space used, when the size of an index can be considered constant w.r.t. the size of the input strings. There are, however, cases where even the linear Space Complexity of a MoreStructures.SuffixArrays.SuffixArray is considered still too high, and a smaller data structure has to be stored, potentially at the cost of the algorithm runtime. These are the scenarios where a Partial Suffix Array is used. Text pattern matching with Suffix Arrays can also be done with partial structures, for example by using the Last-First property of the Burrows-Wheeler Transform and its sorted version. Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.Builders.html": {
    "href": "api/MoreStructures.SuffixArrays.Builders.html",
    "title": "Namespace MoreStructures.SuffixArrays.Builders",
    "keywords": "Namespace MoreStructures.SuffixArrays.Builders Classes NaiveSuffixArrayBuilder An algorithm for building the MoreStructures.SuffixArrays.SuffixArray directly from a TextWithTerminator , listing and sorting all suffixes of Text . PcsBasedSuffixArrayBuilder An algorithm for building the MoreStructures.SuffixArrays.SuffixArray based on fast PCS comparison. SuffixStructureBasedSuffixArrayBuilder<TEdge, TNode> An algorithm for building the MoreStructures.SuffixArrays.SuffixArray from an already built ISuffixStructureNode<TEdge, TNode> structure for the provided TextWithTerminator . Interfaces ISuffixArrayBuilder An algorithm for building the MoreStructures.SuffixArrays.SuffixArray of a text."
  },
  "api/MoreStructures.SuffixArrays.Builders.ISuffixArrayBuilder.html": {
    "href": "api/MoreStructures.SuffixArrays.Builders.ISuffixArrayBuilder.html",
    "title": "Interface ISuffixArrayBuilder",
    "keywords": "Interface ISuffixArrayBuilder An algorithm for building the MoreStructures.SuffixArrays.SuffixArray of a text. Namespace : MoreStructures.SuffixArrays.Builders Assembly : MoreStructures.dll Syntax public interface ISuffixArrayBuilder Examples TextWithTerminator text = new(\"mississippi\"); ISuffixArrayBuilder suffixArrayBuilder = ... // Some implementation of ISuffixArrayBuilder var suffixArray = suffixArrayBuilder.Build().ToList(); // ToList necessary if Build is lazy // suffixArray is new List<int> { 11, 10, 7, 4, ... } Methods | Improve this Doc View Source Build() Builds the MoreStructures.SuffixArrays.SuffixArray . Declaration SuffixArray Build() Returns Type Description MoreStructures.SuffixArrays.SuffixArray A MoreStructures.SuffixArrays.SuffixArray , wrapping the indexes of the suffixes in a of System.Int32 . Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.Builders.NaiveSuffixArrayBuilder.html": {
    "href": "api/MoreStructures.SuffixArrays.Builders.NaiveSuffixArrayBuilder.html",
    "title": "Class NaiveSuffixArrayBuilder",
    "keywords": "Class NaiveSuffixArrayBuilder An algorithm for building the MoreStructures.SuffixArrays.SuffixArray directly from a TextWithTerminator , listing and sorting all suffixes of Text . Inheritance System.Object NaiveSuffixArrayBuilder Implements ISuffixArrayBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays.Builders Assembly : MoreStructures.dll Syntax public class NaiveSuffixArrayBuilder : ISuffixArrayBuilder Remarks ALGORITHM The following steps are performed, lazily. - First all suffixes of the input TextWithTerminator are generated. - Then the suffixes are sorted in ascending order. - Finally, the 1st char of each suffix is taken. COMPLEXITY - There are n suffixes, where n is the length of the input text (including the terminator). - Sorting n strings requires n * log(n) comparisons, each comparing at most n chars. - Taking the first char of each of the suffixes takes O(1) time, and there are n of them. - Therefore, Time Complexity is O(n^2 * log(n)) and Space Complexity is O(n). Constructors | Improve this Doc View Source NaiveSuffixArrayBuilder(TextWithTerminator) Declaration public NaiveSuffixArrayBuilder(TextWithTerminator text) Parameters Type Name Description TextWithTerminator text Properties | Improve this Doc View Source Text The TextWithTerminator , to build the MoreStructures.SuffixArrays.SuffixArray of. Declaration public TextWithTerminator Text { get; } Property Value Type Description TextWithTerminator Methods | Improve this Doc View Source Build() Declaration public SuffixArray Build() Returns Type Description MoreStructures.SuffixArrays.SuffixArray Implements ISuffixArrayBuilder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.Builders.PcsBasedSuffixArrayBuilder.html": {
    "href": "api/MoreStructures.SuffixArrays.Builders.PcsBasedSuffixArrayBuilder.html",
    "title": "Class PcsBasedSuffixArrayBuilder",
    "keywords": "Class PcsBasedSuffixArrayBuilder An algorithm for building the MoreStructures.SuffixArrays.SuffixArray based on fast PCS comparison. Inheritance System.Object PcsBasedSuffixArrayBuilder Implements ISuffixArrayBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays.Builders Assembly : MoreStructures.dll Syntax public class PcsBasedSuffixArrayBuilder : ISuffixArrayBuilder Remarks Remark: the following analysis is based on the default implementations used for each of the four steps of the Suffix Array building algorithm, as set by PcsBasedSuffixArrayBuilder(TextWithTerminator, IDictionary<Char, Int32>) . Using a builder different from the default for any of the step would result into a different runtime and complexity. ALGORITHM The algorithm is based on two lists, position list and equivalence class list, which are iteratively recalculated, over and over again, for longer and longer PCS of Text , until the full content of Text is covered by the PCS. More in detail: - Position and equivalence class lists are first calculated for 1-char PCS, i.e. for single chars, using CountingSortCharsSorter and OrderBasedSingleCharPcsClassifier respectively. - Position and equivalence class lists are then calculated for PCS of length double than the current one, using CountingSortDoubleLengthPcsSorter and EqClassesBasedDoubleLengthPcsClassifier respectively. - The operation is repeated until the current PCS length becomes bigger or equal than the length of Text . - At this point, the last calculated order is the order of PCS which are at least as long as the full Text . - Because all such strings include a full suffixes of Text terminated by a terminator, which is a unique char, the resulting order is the order of all suffixes of Text , which is by definition the Suffix Array of Text . COMPLEXITY - The algorithm has a bootstrap part (1-char PCS) and an iterative part (doubling length PCS). - It first calculates position and equivalence lists for 1-char PCS, which are respectively O(n + sigma) and O(n) operations, both in Time and Space Complexity, where n is the length of Text and sigma is the size of the alphabet of Text . - Then the iterative part is executed. The number of top-level iterations is logarithmic with n, because the PCS length doubles at every iteration and the termination condition is that the PCS length is at least as big as the length of Text . - The two operations done in the iteration loop both have linear Time and Space Complexity. - Therefore, both Time and Space Complexity are O(n * log(n) + sigma). - If sigma is O(n), Time and Space Complexity are O(n * log(n)). Constructors | Improve this Doc View Source PcsBasedSuffixArrayBuilder(TextWithTerminator, Func<String, ICharsSorter>, Func<String, IList<Int32>, ISingleCharPcsClassifier>, Func<Int32, IList<Int32>, IList<Int32>, IDoubleLengthPcsSorter>, Func<Int32, IList<Int32>, IList<Int32>, IDoubleLengthPcsClassifier>) Declaration public PcsBasedSuffixArrayBuilder(TextWithTerminator text, Func<string, ICharsSorter> singleCharPcsSorterBuilder, Func<string, IList<int>, ISingleCharPcsClassifier> singleCharPcsClassifierBuilder, Func<int, IList<int>, IList<int>, IDoubleLengthPcsSorter> doubleLengthPcsSorterBuilder, Func<int, IList<int>, IList<int>, IDoubleLengthPcsClassifier> doubleLengthPcsClassifierBuilder) Parameters Type Name Description TextWithTerminator text Func < System.String , ICharsSorter > singleCharPcsSorterBuilder Func < System.String , IList < System.Int32 >, ISingleCharPcsClassifier > singleCharPcsClassifierBuilder Func < System.Int32 , IList < System.Int32 >, IList < System.Int32 >, IDoubleLengthPcsSorter > doubleLengthPcsSorterBuilder Func < System.Int32 , IList < System.Int32 >, IList < System.Int32 >, IDoubleLengthPcsClassifier > doubleLengthPcsClassifierBuilder Remarks Allows to specify the algorithm to be used for each of the four steps of the Suffix Array building algorithm, each one via a dedicated builder. | Improve this Doc View Source PcsBasedSuffixArrayBuilder(TextWithTerminator, IDictionary<Char, Int32>) Declaration public PcsBasedSuffixArrayBuilder(TextWithTerminator text, IDictionary<char, int> alphabet) Parameters Type Name Description TextWithTerminator text IDictionary < System.Char , System.Int32 > alphabet The alphabet of Text , i.e. the list of all System.Char potentially appearing in Text , mapped to an alphabet index. Required by the Counting Sort algorithm, which builds the histogram of occurrences in the input, of all chars of the alphabet of the input. Remarks Uses the best implementations for each of the four steps of the Suffix Array building algorithm, resulting in an overall linear Time and Space Complexity. Properties | Improve this Doc View Source DoubleLengthPcsClassifierBuilder The builder of the IDoubleLengthPcsClassifier implementation used in the Suffix Array building algorithm, to classify PCS of length 2 * L, once PCS of length L have been sorted and classified and PCS of length 2 * L have been sorted. Declaration public Func<int, IList<int>, IList<int>, IDoubleLengthPcsClassifier> DoubleLengthPcsClassifierBuilder { get; } Property Value Type Description Func < System.Int32 , IList < System.Int32 >, IList < System.Int32 >, IDoubleLengthPcsClassifier > Remarks Takes as first input parameter a System.Int32 , containing the length L of the PCS. Takes as second input parameter a of System.Int32 , containing the equivalence classes of the PCS of length L, previously calculated and potentially needed to calculate the equivalence classes of PCS of length 2 * L. Takes as third input parameter a of System.Int32 , containing the order of the PCS of length L, previously calculated and potentially needed to calculate the equivalence classes of PCS of length 2 * L. Returns a suitable IDoubleLengthPcsClassifier implementation. | Improve this Doc View Source DoubleLengthPcsSorterBuilder The builder of the IDoubleLengthPcsSorter implementation used in the Suffix Array building algorithm, to sort PCS of length 2 * L, once PCS of length L have been sorted and classified. Declaration public Func<int, IList<int>, IList<int>, IDoubleLengthPcsSorter> DoubleLengthPcsSorterBuilder { get; } Property Value Type Description Func < System.Int32 , IList < System.Int32 >, IList < System.Int32 >, IDoubleLengthPcsSorter > Remarks Takes as first input parameter a System.Int32 , containing the length L of the PCS. Takes as second input parameter a of System.Int32 , containing the order of the PCS of length L, previously calculated and potentially needed to calculate the order of PCS of length 2 * L. Takes as third input parameter a of System.Int32 , containing the equivalence classes of the PCS of length L, previously calculated and potentially needed to calculate the order of PCS of length 2 * L. Returns a suitable IDoubleLengthPcsSorter implementation. | Improve this Doc View Source SingleCharPcsClassifierBuilder The builder of the ISingleCharPcsClassifier implementation used to find equivalence classes of 1-char PCS in the Suffix Array building algorithm. Declaration public Func<string, IList<int>, ISingleCharPcsClassifier> SingleCharPcsClassifierBuilder { get; } Property Value Type Description Func < System.String , IList < System.Int32 >, ISingleCharPcsClassifier > Remarks Takes as first input parameter a System.String , containing the input text, whose chars have to be classified. Takes as second input parameter a of System.Int32 , containing the order of the 1-char PCS, previously calculated. Returns a suitable ISingleCharPcsClassifier implementation. | Improve this Doc View Source SingleCharPcsSorterBuilder The builder of the ICharsSorter implementation used to sort 1-char PCS in the Suffix Array building algorithm. Declaration public Func<string, ICharsSorter> SingleCharPcsSorterBuilder { get; } Property Value Type Description Func < System.String , ICharsSorter > Remarks Takes as input a single System.String parameter, containing the input text, whose chars have to be sorted. Returns a suitable ICharsSorter implementation. | Improve this Doc View Source Text The TextWithTerminator , to build the MoreStructures.SuffixArrays.SuffixArray of. Declaration public TextWithTerminator Text { get; } Property Value Type Description TextWithTerminator Methods | Improve this Doc View Source Build() Declaration public SuffixArray Build() Returns Type Description MoreStructures.SuffixArrays.SuffixArray Implements ISuffixArrayBuilder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.Builders.SuffixStructureBasedSuffixArrayBuilder-2.html": {
    "href": "api/MoreStructures.SuffixArrays.Builders.SuffixStructureBasedSuffixArrayBuilder-2.html",
    "title": "Class SuffixStructureBasedSuffixArrayBuilder<TEdge, TNode>",
    "keywords": "Class SuffixStructureBasedSuffixArrayBuilder<TEdge, TNode> An algorithm for building the MoreStructures.SuffixArrays.SuffixArray from an already built ISuffixStructureNode<TEdge, TNode> structure for the provided TextWithTerminator . Inheritance System.Object SuffixStructureBasedSuffixArrayBuilder<TEdge, TNode> Implements ISuffixArrayBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays.Builders Assembly : MoreStructures.dll Syntax public class SuffixStructureBasedSuffixArrayBuilder<TEdge, TNode> : ISuffixArrayBuilder where TEdge : ISuffixStructureEdge<TEdge, TNode> where TNode : ISuffixStructureNode<TEdge, TNode> Type Parameters Name Description TEdge The type of edges of the specific structure. TNode The type of nodes of the specific structure. Remarks The Suffix Tree for the text \"mississippi$\" is: R - $ (11) - i - $ (10) - ssi - p..$ (7) - s..$ (4) - m..$ - ... A DFS visit of the leaves of the tree, navigating edges in lexicographic order, gives { 11, 10, 7, 4, ... }, which is the MoreStructures.SuffixArrays.SuffixArray of \"mississippi$\". - The Suffix Tree of the text is provided as input, and the complexity of building or keeping it in memoery is not considered here. - The DFS of the Tree is linear in m, where m is the number of nodes in the Suffix Tree. m is O(n) for Suffix Trees and O(n^2) for Suffix Tries, where n is the length of the text. - While DFS itself is linear in m, edges have to be sorted in lexicographic order, which is done via the LINQ method. - There are O(m) edges in the tree, so sorting can be O(m * log(m)) if the alphabet of the text is O(n), using QuickSort or similar, and O(m) if the alphabet is constant w.r.t. to n, using Counting Sort or similar. - For each visited node, constant work is done: checking whether the node is a leaf and potentially returning it. - Therefore Time Complexity is O(n^2 * log(n)) for a Suffix Trie with a non-constant alphabet, O(n^2) for a Suffix Trie with a constant alphabet, O(n * log(n)) for a Suffix Tree with a non-constant alphabet and O(n) for a Suffix Tree with a constant alphabet. - Space Complexity is dominated by the space required to sort edges in lexicographic order, before visiting them in DFS: O(n^2) for a Suffix Trie and O(n) for a Suffix Tree. Constructors | Improve this Doc View Source SuffixStructureBasedSuffixArrayBuilder(TextWithTerminator, TNode) Declaration public SuffixStructureBasedSuffixArrayBuilder(TextWithTerminator text, TNode node) Parameters Type Name Description TextWithTerminator text TNode node Properties | Improve this Doc View Source Node The root node of the ISuffixStructureNode<TEdge, TNode> structure, to build the MoreStructures.SuffixArrays.SuffixArray of. Declaration public TNode Node { get; } Property Value Type Description TNode | Improve this Doc View Source Text The TextWithTerminator , to build the MoreStructures.SuffixArrays.SuffixArray of. Declaration public TextWithTerminator Text { get; } Property Value Type Description TextWithTerminator Methods | Improve this Doc View Source Build() Builds the MoreStructures.SuffixArrays.SuffixArray for . Declaration public SuffixArray Build() Returns Type Description MoreStructures.SuffixArrays.SuffixArray Implements ISuffixArrayBuilder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.CyclicShifts.CountingSortDoubleLengthPcsSorter.html": {
    "href": "api/MoreStructures.SuffixArrays.CyclicShifts.CountingSortDoubleLengthPcsSorter.html",
    "title": "Class CountingSortDoubleLengthPcsSorter",
    "keywords": "Class CountingSortDoubleLengthPcsSorter An implementation of IDoubleLengthPcsSorter using Counting Sort, to perform sorting of partial cyclic shifts (PCS) of length 2 * L of a string, given the order and the equivalence classes of the PCS of length L. Inheritance System.Object CountingSortDoubleLengthPcsSorter Implements IDoubleLengthPcsSorter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays.CyclicShifts Assembly : MoreStructures.dll Syntax public class CountingSortDoubleLengthPcsSorter : IDoubleLengthPcsSorter Remarks ADVANTAGES AND DISADVANTAGES - Compared to NaiveDoubleLengthPcsSorter , this implementation has way better runtime (linear instead of cubic). - Unlike NaiveDoubleLengthPcsSorter , this implementation requires specific data structures to be provided, in alternative to the input, to calculate the position list. - However, unlike NaiveDoubleLengthPcsSorter , it does not require to know whether input contains a terminator or not. - This is because such piece of information would only be needed when running comparisons between PCS. - This sorter, on the other hand, uses externally provided lists precisely in order to avoid the need for costly PCS comparisons, which are \"embedded\" in the externally provided data structures. ALGORITHM - The algorithm takes advantage of the fact that PCS of length L have been already ordered, and their order from the smallest to the biggest, is defined in the provided position list O, of the PCS of the input string of length L. - The PCS of length 2 * L which the algorithm sorts are the ones starting at index i - L, for each i in O. Let's call O' this extension of O to the the L chars preceding each index of O. - PCS of length 2 * L starting at index i - L are made of two halves: the first, from index i - L to index i excluded, which is unsorted; and the second, from index i to i + L excluded, which is already sorted and whose order is the one defined in O. - The algorithm uses a stable implementation of the Counting Sort to sort in linear time O', under Counting Sort assumption of a small alphabet. - Moreover, the algorithm only looks at the first half of each PCS of length 2 * L, because the second half is already sorted in O, hence in O', and the implementation of the sorting is stable, i.e. it preserves order of suffixes, as they appear in the input being sorted, to the output, among the strings sharing the same prefix. - Counting Sort is adapted in the following way: instead of directly building an histogram of occurrences of the first halves (PCS of length L), it builds an histogram of their equivalence classes, which are integer simple to use as a key in Counting Sort and limited in number by the number of chars in the input string. - The order list of the PCS of length 2 * L is calculated by iterating in reverse order over the equivalence classes of the second halves, which are sorted in lexicographic ascending order in the provided position list. COMPLEXITY - The algorithm is just a variation of the Counting Sort, where, instead of sorting by PCS (which would require comparing O(n) strings, or having a much larger alphabet), a sorting by equivalence classes is done. - Direct access to the position list, as well as to the list of equivalence class is done in constant time. - Therefore, Time and Space Complexity are both O(n + sigma), where n is the length of the input string, and also of the position and equivalence classes lists and sigma is the length of the alphabet, i.e. the number of distinct equivalence classes of PCS of length L. - Because there are n PCS of length L in the input string, there are at most n distinct equivalent classes. - Therefore, Time and Space Complexity are actually O(n). Constructors | Improve this Doc View Source CountingSortDoubleLengthPcsSorter(Int32, IList<Int32>, IList<Int32>) Declaration public CountingSortDoubleLengthPcsSorter(int pcsLength, IList<int> order, IList<int> eqClasses) Parameters Type Name Description System.Int32 pcsLength IList < System.Int32 > order IList < System.Int32 > eqClasses Properties | Improve this Doc View Source EqClasses The equivalence classes of the already sorted PCS of length . Declaration public IList<int> EqClasses { get; } Property Value Type Description IList < System.Int32 > | Improve this Doc View Source Order The position list of the already sorted PCS of length . Declaration public IList<int> Order { get; } Property Value Type Description IList < System.Int32 > | Improve this Doc View Source PcsLength The length L of the PCS. Remark: sorting is done of PCS of length 2 * L, not L. Declaration public int PcsLength { get; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source Sort() Declaration public IList<int> Sort() Returns Type Description IList < System.Int32 > Remarks Implements IDoubleLengthPcsSorter Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.CyclicShifts.EqClassesBasedDoubleLengthPcsClassifier.html": {
    "href": "api/MoreStructures.SuffixArrays.CyclicShifts.EqClassesBasedDoubleLengthPcsClassifier.html",
    "title": "Class EqClassesBasedDoubleLengthPcsClassifier",
    "keywords": "Class EqClassesBasedDoubleLengthPcsClassifier An implementation of IDoubleLengthPcsClassifier which uses the externally provided list of equivalence classes EqClassesPcsHalfLength , of the PCS of length PcsLength / 2, as well as the position list of the PCS of length PcsLength , and doesn't require the input string, to generate equivalence classes of the PCS of length PcsLength . Inheritance System.Object EqClassesBasedDoubleLengthPcsClassifier Implements IDoubleLengthPcsClassifier Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays.CyclicShifts Assembly : MoreStructures.dll Syntax public class EqClassesBasedDoubleLengthPcsClassifier : IDoubleLengthPcsClassifier Remarks ADVANTAGES AND DISADVANTAGES - Compared to NaiveDoubleLengthPcsClassifier , it has way better runtime (linear time, instead of cubic). - Compared OrderBasedDoubleLengthPcsClassifier , it still has better runtime (linear time, instead of quadratic). - However, it requires both the position list Order and the equivalence class list EqClassesPcsHalfLength , to be externally provided. - Compared to other implementations, this algorithm requires PcsLength to be even. - Unlike NaiveDoubleLengthPcsClassifier , this implementation requires specific data structures to be provided, in alternative to the input, to calculate equivalence classes. - However, unlike NaiveDoubleLengthPcsClassifier , it does not require to know whether input contains a terminator or not. - This is because such piece of information would only be needed when running comparisons between PCS. - This classifier, on the other hand, uses an externally provided lists precisely in order to avoid the need for costly PCS comparisons, which are \"embedded\" in the externally provided data structures. ALGORITHM - The externally provided ordered sequence of PCS Order is iterated over. - A new equivalence class is generated (increasing the current counter) every time a PCS differs from the previous one. The equivalence class is assigned to the output at the index of the PCS being checked. - The comparison between a PCS and the previous one (both of length PcsLength ), is not done by comparing chars, rather by comparing equivalence classes of the PCS of length PcsLength / 2, defined in the externally provided EqClassesPcsHalfLength . - More in detail: to compare the PCS of even length L = PcsLength at index j1 = Order [i] with the one at index j2 = Order [i - 1], the following two comparisons are done: EqClassesPcsHalfLength [j1] == EqClassesPcsHalfLength [j2] and EqClassesPcsHalfLength [j1 + L / 2] == EqClassesPcsHalfLength [j2 + L / 2] . - Finally, the equivalence class list is returned. COMPLEXITY - Iterating over the n PCS of length L is an O(n) operation. Each iteration does O(1) work, since direct access to the equivalence class list of PCS of half length is done in constant time and comparison between the current PCS and the previous one is a comparison of the equivalence classes of the first and second halves of both PCS, and requires two pairs of integers to be compared. - Instantiating the equivalence class list of output is also an O(n) operation. - Therefore, Time and Space Complexity are O(n). Constructors | Improve this Doc View Source EqClassesBasedDoubleLengthPcsClassifier(Int32, IList<Int32>, IList<Int32>) Declaration public EqClassesBasedDoubleLengthPcsClassifier(int pcsLength, IList<int> eqClassesPcsHalfLength, IList<int> order) Parameters Type Name Description System.Int32 pcsLength IList < System.Int32 > eqClassesPcsHalfLength IList < System.Int32 > order Properties | Improve this Doc View Source EqClassesPcsHalfLength The list of equivalence classes of the PCS of length PcsLength / 2, to be used to calculate the equivalence classes of the PCS of double the length ( PcsLength ). Declaration public IList<int> EqClassesPcsHalfLength { get; } Property Value Type Description IList < System.Int32 > | Improve this Doc View Source Order The position list of the PCS of length PcsLength , to be used, in addition to the EqClassesPcsHalfLength , to calculate the equivalence classes of length PcsLength . Declaration public IList<int> Order { get; } Property Value Type Description IList < System.Int32 > | Improve this Doc View Source PcsLength The length the PCS of input string to be classified. Declaration public int PcsLength { get; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source Classify() Declaration public IList<int> Classify() Returns Type Description IList < System.Int32 > Remarks Implements IDoubleLengthPcsClassifier Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.CyclicShifts.html": {
    "href": "api/MoreStructures.SuffixArrays.CyclicShifts.html",
    "title": "Namespace MoreStructures.SuffixArrays.CyclicShifts",
    "keywords": "Namespace MoreStructures.SuffixArrays.CyclicShifts Classes CountingSortDoubleLengthPcsSorter An implementation of IDoubleLengthPcsSorter using Counting Sort, to perform sorting of partial cyclic shifts (PCS) of length 2 * L of a string, given the order and the equivalence classes of the PCS of length L. EqClassesBasedDoubleLengthPcsClassifier An implementation of IDoubleLengthPcsClassifier which uses the externally provided list of equivalence classes EqClassesPcsHalfLength , of the PCS of length PcsLength / 2, as well as the position list of the PCS of length PcsLength , and doesn't require the input string, to generate equivalence classes of the PCS of length PcsLength . NaiveDoubleLengthPcsClassifier An implementation of IDoubleLengthPcsClassifier which solely depends on the input string, to generate equivalence classes. NaiveDoubleLengthPcsSorter An implementation of IDoubleLengthPcsSorter sorting of partial cyclic shifts (PCS) of length 2 * L of a string by generating them and sorting with the LINQ-provided QuickSort. Ignores the provided order and equivalence classes of the PCS of length L. NaiveSingleCharPcsClassifier A ISingleCharPcsClassifier implementation which calculate equivalence classes using the definition. OrderBasedDoubleLengthPcsClassifier An implementation of IDoubleLengthPcsClassifier which uses the externally provided position list of the PCS of length PcsLength , in addition to the input string, to generate equivalence classes. OrderBasedSingleCharPcsClassifier A ISingleCharPcsClassifier implementation which uses an externally provided position list Order of the 1-char PCS of the Input , to calculate equivalence classes. PcsUtils Static class of utilities for partial cyclic shifts (PCS) of input strings. Interfaces IDoubleLengthPcsClassifier An algorithm defining equivalence classes for partial cyclic shifts (PCS) of length 2 * L in the input string. IDoubleLengthPcsSorter An algorithm sorting in lexicographic order all the partial cyclic shifts (PCS) of length 2 * L of a string. ISingleCharPcsClassifier An algorithm definining equivalence classes for partial cyclic shifts (PCS) of length 1 (i.e. single chars) of a string."
  },
  "api/MoreStructures.SuffixArrays.CyclicShifts.IDoubleLengthPcsClassifier.html": {
    "href": "api/MoreStructures.SuffixArrays.CyclicShifts.IDoubleLengthPcsClassifier.html",
    "title": "Interface IDoubleLengthPcsClassifier",
    "keywords": "Interface IDoubleLengthPcsClassifier An algorithm defining equivalence classes for partial cyclic shifts (PCS) of length 2 * L in the input string. Namespace : MoreStructures.SuffixArrays.CyclicShifts Assembly : MoreStructures.dll Syntax public interface IDoubleLengthPcsClassifier Remarks The method Classify() has no input parameters because the input of the algorithm depends on the specific implementation. Methods | Improve this Doc View Source Classify() Runs the algorithm, calculating the equivalence classes of all PCS of length L in the input string. Declaration IList<int> Classify() Returns Type Description IList < System.Int32 > A list of equivalence classes, with as many items as PCS of length L in the input string. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.CyclicShifts.IDoubleLengthPcsSorter.html": {
    "href": "api/MoreStructures.SuffixArrays.CyclicShifts.IDoubleLengthPcsSorter.html",
    "title": "Interface IDoubleLengthPcsSorter",
    "keywords": "Interface IDoubleLengthPcsSorter An algorithm sorting in lexicographic order all the partial cyclic shifts (PCS) of length 2 * L of a string. Namespace : MoreStructures.SuffixArrays.CyclicShifts Assembly : MoreStructures.dll Syntax public interface IDoubleLengthPcsSorter Properties | Improve this Doc View Source PcsLength The length L of the PCS. Remark: sorting is done of PCS of length 2 * L, not L. Declaration int PcsLength { get; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source Sort() Sorts in lexicographic order all the partial cyclic shifts (PCS) of the input string of length 2 * L. Declaration IList<int> Sort() Returns Type Description IList < System.Int32 > The position list of PCS of length 2 * L. Remarks The bootstrap of this process requires sorting PCS of length 1, i.e. single chars of the input string. This can be done by any implementation of ICharsSorter , such as CountingSortCharsSorter , which sorts single chars of the input in linear time, in scenarios of small alphabets. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.CyclicShifts.ISingleCharPcsClassifier.html": {
    "href": "api/MoreStructures.SuffixArrays.CyclicShifts.ISingleCharPcsClassifier.html",
    "title": "Interface ISingleCharPcsClassifier",
    "keywords": "Interface ISingleCharPcsClassifier An algorithm definining equivalence classes for partial cyclic shifts (PCS) of length 1 (i.e. single chars) of a string. Namespace : MoreStructures.SuffixArrays.CyclicShifts Assembly : MoreStructures.dll Syntax public interface ISingleCharPcsClassifier Remarks DEFINITION The equivalence class of a n-char partial cyclic shift c of the string T is the number of distinct n-char partial cyclic shift of T which strictly precedes c in lexicographic order (i.e. all distinct chars strictly smaller than c). That means that two partial cyclic shifts which are the same share the same equivalence class. The minimum value the equivalence class can have is 0, for the smallest partial cyclic shift, which is preceded by no other partial cyclic shift. The maximum value is the number of distinct chars in the string. Properties | Improve this Doc View Source Input The input text, whose 1-char PCS have to be classified. Declaration string Input { get; } Property Value Type Description System.String Methods | Improve this Doc View Source Classify() Runs the algorithm, calculating the equivalence classes of each 1-char PCS of the Input . Declaration IList<int> Classify() Returns Type Description IList < System.Int32 > A list of equivalence classes, with as many items as chars in the Input . Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.CyclicShifts.NaiveDoubleLengthPcsClassifier.html": {
    "href": "api/MoreStructures.SuffixArrays.CyclicShifts.NaiveDoubleLengthPcsClassifier.html",
    "title": "Class NaiveDoubleLengthPcsClassifier",
    "keywords": "Class NaiveDoubleLengthPcsClassifier An implementation of IDoubleLengthPcsClassifier which solely depends on the input string, to generate equivalence classes. Inheritance System.Object NaiveDoubleLengthPcsClassifier Implements IDoubleLengthPcsClassifier Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays.CyclicShifts Assembly : MoreStructures.dll Syntax public class NaiveDoubleLengthPcsClassifier : IDoubleLengthPcsClassifier Remarks ADVANTAGES AND DISADVANTAGES - Unlike other implementations, such as OrderBasedDoubleLengthPcsClassifier or EqClassesBasedDoubleLengthPcsClassifier , this classifier needs to know whether the input being provided includes a terminator (i.e. its last char is \"special\" as it uniquely identify the end of the string) or not. - This information is required since this classifier performs classification by actually sorting PCS, and sorting PCS requires knowing whether a terminator is present or not (and which one it is). - Other implementations don't require such information, since they never compare PCS against each other: they either use an externally provided position list or compare via the equivalence class list. ALGORITHM - PCS of length L are generated as actual strings from the input string, then sorted in lexicographic order via the method. - The ordered sequence of PCS with corresponding starting index in the input string is then iterated over. - A new equivalence class is generated (increasing the current counter) every time a PCS differs from the previous one. The equivalence class is assigned to the output at the index of the PCS. - Finally, the equivalence class list is returned. COMPLEXITY - Extracting the n PCS of length L from the input string has O(n * L) Time and Space Complexity. - Sorting the n PCS of length L via the LINQ-provided QuickSort has O(n^2 * L) Time Complexity and O(n) Space Complexity. - Iterating over the n PCS of length L is an O(n) operation. Each iteration does O(L) work, since, while direct access to the equivalence class list is done in constant time, comparison between the current PCS and the previous one is a comparison of two strings of length L, and requires all L chars to be comparerd in the worst case. - Instantiating the equivalence class list of output is also an O(n) operation. - Therefore, Time Complexity, as driven by sorting, is O(n^2 * L) and Space Complexity, as driven by the PCS generating and iteration, is O(n * L). Constructors | Improve this Doc View Source NaiveDoubleLengthPcsClassifier(String, Int32, Boolean) Declaration public NaiveDoubleLengthPcsClassifier(string input, int pcsLength, bool inputWithTerminator) Parameters Type Name Description System.String input System.Int32 pcsLength System.Boolean inputWithTerminator Whether input is terminated by a terminator char. If so, the last char of input will be treated as a terminator char when comparing PCS of the input. Otherwise, for System.String will be used. Properties | Improve this Doc View Source Input The input text, whose PCS of length PcsLength have to be classified. Declaration public string Input { get; } Property Value Type Description System.String | Improve this Doc View Source PcsLength The length of the PCS of Input to be classified. Declaration public int PcsLength { get; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source Classify() Declaration public IList<int> Classify() Returns Type Description IList < System.Int32 > Remarks Implements IDoubleLengthPcsClassifier Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.CyclicShifts.NaiveDoubleLengthPcsSorter.html": {
    "href": "api/MoreStructures.SuffixArrays.CyclicShifts.NaiveDoubleLengthPcsSorter.html",
    "title": "Class NaiveDoubleLengthPcsSorter",
    "keywords": "Class NaiveDoubleLengthPcsSorter An implementation of IDoubleLengthPcsSorter sorting of partial cyclic shifts (PCS) of length 2 * L of a string by generating them and sorting with the LINQ-provided QuickSort. Ignores the provided order and equivalence classes of the PCS of length L. Inheritance System.Object NaiveDoubleLengthPcsSorter Implements IDoubleLengthPcsSorter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays.CyclicShifts Assembly : MoreStructures.dll Syntax public class NaiveDoubleLengthPcsSorter : IDoubleLengthPcsSorter Remarks ADVANTAGES AND DISADVANTAGES - Unlike other implementations, such as CountingSortDoubleLengthPcsSorter , this sorter needs to know whether the input being provided includes a terminator (i.e. its last char is \"special\" as it uniquely identify the end of the string) or not. - This information is required since this sorter performs sorting by actually comparing PCS. - Other implementations don't require such information, since they never compare PCS against each other: they use externally provided data structures, from which they infer the order. ALGORITHM - For each index i of the input string, a cyclic shift starting at i and of length 2 * L is generated. - Cyclic shifts are sorted in ascending lexicographic order, using . - Indexes i, corresponding to the sorted cyclic shifts, are returned as a list. COMPLEXITY - There are always n cyclic shifts, where n is the length of the input string. - Each cyclic shift has length 2 * L: building it takes O(L) time and space. - Sorting the cyclic shifts via QuickSort takes O(n * log(n)) comparisons, between strings of length L. - Generating the output takes O(n * L) space. - Therefore, Time Complexity is O(n * log(n) * L) and Space Complexity is O(n * L) space. - If L is not constant, but rather O(n), Time Complexity is O(n^2 * log(n)) and Space Complexity is O(n^2). Constructors | Improve this Doc View Source NaiveDoubleLengthPcsSorter(String, Int32, Boolean) Declaration public NaiveDoubleLengthPcsSorter(string input, int pcsLength, bool inputWithTerminator) Parameters Type Name Description System.String input System.Int32 pcsLength System.Boolean inputWithTerminator Whether input is terminated by a terminator char. If so, the last char of input will be treated as a terminator char when comparing PCS of the input. Otherwise, for System.String will be used. Properties | Improve this Doc View Source Input The input string, whose PCS have to be sorted. Declaration public string Input { get; } Property Value Type Description System.String | Improve this Doc View Source PcsLength The length L of the PCS. Remark: sorting is done of PCS of length 2 * L, not L. Declaration public int PcsLength { get; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source Sort() Declaration public IList<int> Sort() Returns Type Description IList < System.Int32 > Remarks Implements IDoubleLengthPcsSorter Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.CyclicShifts.NaiveSingleCharPcsClassifier.html": {
    "href": "api/MoreStructures.SuffixArrays.CyclicShifts.NaiveSingleCharPcsClassifier.html",
    "title": "Class NaiveSingleCharPcsClassifier",
    "keywords": "Class NaiveSingleCharPcsClassifier A ISingleCharPcsClassifier implementation which calculate equivalence classes using the definition. Inheritance System.Object NaiveSingleCharPcsClassifier Implements ISingleCharPcsClassifier Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays.CyclicShifts Assembly : MoreStructures.dll Syntax public class NaiveSingleCharPcsClassifier : ISingleCharPcsClassifier Remarks ADVANTAGES AND DISADVANTAGES - Compared to more advanced implementations, such as OrderBasedSingleCharPcsClassifier , it only requires the Input , to calculate equivalence classes. - However, its runtime is worse, both in Time and Space Complexity, than a solution based on position list, where the effort of sorting the chars has been already done previously. ALGORITHM - Go though each char of the Input . - For each char, count the distinct chars of Input which are strictly smaller. - Build an output list of the result. COMPLEXITY - For each of the n chars of the Input , a pass of all n chars of Input is done, to count to keep the ones which are strictly smaller. - Count the distinct occurrences is a O(n) operation in time and space, done via the LINQ method , which uses an internal lightweight implementation of a set. - The output is a list of n items. - Therefore, Time Complexity is O(n^2) and Space Complexity is O(n). Constructors | Improve this Doc View Source NaiveSingleCharPcsClassifier(String, Boolean) Declaration public NaiveSingleCharPcsClassifier(string input, bool inputWithTerminator) Parameters Type Name Description System.String input System.Boolean inputWithTerminator Whether input is terminated by a terminator char. If so, the last char of input will be treated as a terminator char when comparing chars of the input. Otherwise, for System.Char will be used. Properties | Improve this Doc View Source Input The input text, whose 1-char PCS have to be classified. Declaration public string Input { get; } Property Value Type Description System.String Methods | Improve this Doc View Source Classify() Runs the algorithm, calculating the equivalence classes of each 1-char PCS of the Input . Declaration public IList<int> Classify() Returns Type Description IList < System.Int32 > A list of equivalence classes, with as many items as chars in the Input . Implements ISingleCharPcsClassifier Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.CyclicShifts.OrderBasedDoubleLengthPcsClassifier.html": {
    "href": "api/MoreStructures.SuffixArrays.CyclicShifts.OrderBasedDoubleLengthPcsClassifier.html",
    "title": "Class OrderBasedDoubleLengthPcsClassifier",
    "keywords": "Class OrderBasedDoubleLengthPcsClassifier An implementation of IDoubleLengthPcsClassifier which uses the externally provided position list of the PCS of length PcsLength , in addition to the input string, to generate equivalence classes. Inheritance System.Object OrderBasedDoubleLengthPcsClassifier Implements IDoubleLengthPcsClassifier Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays.CyclicShifts Assembly : MoreStructures.dll Syntax public class OrderBasedDoubleLengthPcsClassifier : IDoubleLengthPcsClassifier Remarks ADVANTAGES AND DISADVANTAGES - Unlike NaiveDoubleLengthPcsClassifier , this implementation requires additional data structures to be provided, in addition to the Input , to calculate equivalence classes. - However, unlike NaiveDoubleLengthPcsClassifier , it does not require to know whether Input contains a terminator or not. - This is because such piece of information would only be needed when running comparisons between PCS. - This classifier, on the other hand, uses an externally provided position list precisely in order to avoid the need for costly PCS comparisons, which are \"embedded\" in the externally provided position list. - PCS are actually still compared for equality. However, comparison for equality, unlike comparison for sorting, doesn't require to know whether a char is terminator or not, since a terminator is a char, it is only equal to itself and different from any other char. ALGORITHM - The externally provided ordered sequence of PCS Order is iterated over. - A new equivalence class is generated (increasing the current counter) every time a PCS differs from the previous one. The equivalence class is assigned to the output at the index of the PCS being checked. - The comparison between a PCS and the previous one (both of length PcsLength ), is done comparing the PcsLength chars of the two strings. - Finally, the equivalence class list is returned. COMPLEXITY - Iterating over the n PCS of length L is an O(n) operation. Each iteration does O(L) work, since, while direct access to the equivalence class list is done in constant time, comparison between the current PCS and the previous one is a comparison of two strings of length L, and requires all L chars to be comparerd in the worst case. - Instantiating the equivalence class list of output is also an O(n) operation. - Therefore, Time Complexity, as driven by the iteration over Order , is O(n * L). Space Complexity, driven as well by iteration over Order storing the previous PCS, is O(n + L). Constructors | Improve this Doc View Source OrderBasedDoubleLengthPcsClassifier(String, Int32, IList<Int32>) Declaration public OrderBasedDoubleLengthPcsClassifier(string input, int pcsLength, IList<int> order) Parameters Type Name Description System.String input System.Int32 pcsLength IList < System.Int32 > order Properties | Improve this Doc View Source Input The input text, whose PCS of length PcsLength have to be classified. Declaration public string Input { get; } Property Value Type Description System.String | Improve this Doc View Source Order The position list of the PCS of length PcsLength , to be used, in addition to the Input , to calculate the equivalence classes. Declaration public IList<int> Order { get; } Property Value Type Description IList < System.Int32 > | Improve this Doc View Source PcsLength The length the PCS of Input to be classified. Declaration public int PcsLength { get; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source Classify() Declaration public IList<int> Classify() Returns Type Description IList < System.Int32 > Remarks Implements IDoubleLengthPcsClassifier Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.CyclicShifts.OrderBasedSingleCharPcsClassifier.html": {
    "href": "api/MoreStructures.SuffixArrays.CyclicShifts.OrderBasedSingleCharPcsClassifier.html",
    "title": "Class OrderBasedSingleCharPcsClassifier",
    "keywords": "Class OrderBasedSingleCharPcsClassifier A ISingleCharPcsClassifier implementation which uses an externally provided position list Order of the 1-char PCS of the Input , to calculate equivalence classes. Inheritance System.Object OrderBasedSingleCharPcsClassifier Implements ISingleCharPcsClassifier Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays.CyclicShifts Assembly : MoreStructures.dll Syntax public class OrderBasedSingleCharPcsClassifier : ISingleCharPcsClassifier Remarks ADVANTAGES - Compared to the naive implementation of NaiveSingleCharPcsClassifier , it has better runtime and only allocates an array of n elements, where n is the length of the Input . - However, it requires the position list of the Input to be provided to the classifier at construction time. - Calculating the position list is a linear time operation only when some assumptions can be made on the input, such as an alphabet of limited size (which is the main scenario for CountingSortCharsSorter ). In all other cases, the runtime has a worst case of O(n * log(n)). ALGORITHM - An array of n elements EC, to accomodate the equivalence classes of the result, is allocated upfront. - The item of EC with index P[0] , where P is the list of positions, is set to 0. This is because P[0] is the index in the Input T, of the smallest char in T. Therefore, there are no smaller chars in T and the equivalence class of T[P[0]] is hence the smallest, i.e. 0. - EC[O[i + 1]] can be calculated from EC[O[i]] : two scenarios are possible. - If T[O[i + 1]] == T[O[i]] , it means that the two chars T[O[i + 1]] and T[O[i]] , which come one after the other one in the position list, are the same and should have the same equivalence class. Therefore, the equivalence class of T[O[i + 1]] , EC[O[i + 1]] can be set to the equivalence class of T[O[i]] , EQ[O[i]] . - If, on the other hand, T[O[i + 1]] != T[O[i]] , it means that the two chars T[O[i + 1]] and T[O[i]] , which come one after the other one in the position list, are different and should have different equivalence classes. Therefore, the equivalence class of T[O[i + 1]] , EC[O[i + 1]] can be set to the successor of the equivalence class of T[O[i]] , EQ[O[i]] . COMPLEXITY - There are as many iterations as items of the position list. - Within each iteration, direct accesses to items of Input and Order by index are done in constant time. - Therefore, Time and Space Complexity are O(n), excluding the cost of calculating the position list, which is externally provided. Check ICharsSorter implementations for the complexity of the algorithms calculating the position list of a string. Constructors | Improve this Doc View Source OrderBasedSingleCharPcsClassifier(String, IList<Int32>) Declaration public OrderBasedSingleCharPcsClassifier(string input, IList<int> order) Parameters Type Name Description System.String input IList < System.Int32 > order Properties | Improve this Doc View Source Input The input text, whose 1-char PCS have to be classified. Declaration public string Input { get; } Property Value Type Description System.String | Improve this Doc View Source Order The position list of the 1-char PCS of the Input . Declaration public IList<int> Order { get; } Property Value Type Description IList < System.Int32 > Remarks Has as many items as chars in the Input . It is specifically required by this implementation of the algorithm and has to be externally provided. It can be calculated with any implementation of Sort(String) . Methods | Improve this Doc View Source Classify() Declaration public IList<int> Classify() Returns Type Description IList < System.Int32 > A list of equivalence classes, with as many items as chars in the Input . Remarks Implements ISingleCharPcsClassifier Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.CyclicShifts.PcsUtils.html": {
    "href": "api/MoreStructures.SuffixArrays.CyclicShifts.PcsUtils.html",
    "title": "Class PcsUtils",
    "keywords": "Class PcsUtils Static class of utilities for partial cyclic shifts (PCS) of input strings. Inheritance System.Object PcsUtils Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays.CyclicShifts Assembly : MoreStructures.dll Syntax public static class PcsUtils Methods | Improve this Doc View Source ExtractPcsOf(String, Int32) Extracts the PCS of length pcsLength from the provided input string, together with their starting index in input . Declaration public static IEnumerable<(string pcs, int index)> ExtractPcsOf(string input, int pcsLength) Parameters Type Name Description System.String input The input string, to extract the PCS of length pcsLength of. System.Int32 pcsLength The length of PCS to extract. Returns Type Description IEnumerable < System.ValueTuple < System.String , System.Int32 >> A sequence of strings, each one being a PCS. As many as the number of chars in the input . Remarks COMPLEXITY Time and Space Complexity is O(n * L). | Improve this Doc View Source ExtractPcsOf(String, Int32, Int32) Extract the PCS of length pcsLength from the provided input string, starting at index index . Declaration public static string ExtractPcsOf(string input, int index, int pcsLength) Parameters Type Name Description System.String input The input string, to extract the PCS of length pcsLength of. System.Int32 index The starting index of the PCS to extract. System.Int32 pcsLength The length of the PCS to extract. Returns Type Description System.String The string containing the PCS. Remarks COMPLEXITY Time and Space Complexity is O(L)."
  },
  "api/MoreStructures.SuffixArrays.html": {
    "href": "api/MoreStructures.SuffixArrays.html",
    "title": "Namespace MoreStructures.SuffixArrays",
    "keywords": "Namespace MoreStructures.SuffixArrays Classes MoreStructures.SuffixArrays. A Partial MoreStructures.SuffixArrays.SuffixArray which only contains the indexes of the Suffix Array which are multiple of a given constant (0, k, 2k, ...), indexed by their position in the complete Suffix Array."
  },
  "api/MoreStructures.SuffixArrays.LongestCommonPrefix..html": {
    "href": "api/MoreStructures.SuffixArrays.LongestCommonPrefix..html",
    "title": "Class",
    "keywords": "Class The LCP Array of a string S of length n is defined as an array LCP of length n - 1 such that LCP[i] is the length of the prefix in common between the suffixes starting at SA[i] and SA[i + 1], where SA is the Suffix Array of S, for each i from 0 to n - 1 excluded. Inheritance System.Object Implements System.IEquatable < MoreStructures.SuffixArrays.LongestCommonPrefix. > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays.LongestCommonPrefix Assembly : MoreStructures.dll Syntax public class : IEquatable<> Remarks The LCP Array of a string of length n has n - 1 items. Examples Given the string S = \"mississippi$\" with terminator char '$' , S has Suffix Array SA = { 11, 10, 7, 4, ... } . The 1-st item of the LCP Array of S is the length of the prefix in common between the suffix starting at SA[0], \"$\" , and the one starting at SA[1], \"i$\" . Such prefix is the empty string, therefore LCP[0] = 0 . The 2-nd item of the LCP Array of S is the length of the prefix in common between the suffix starting at SA[1], \"i$\" , and the one starting at SA[2], \"ippi$\" . Such prefix is the string \"i\" , therefore LCP[1] = 1 . The 3-rd item of the LCP Array of S is the length of the prefix in common between the suffix starting at SA[2], \"ippi$\" , and the one starting at SA[3], \"issippi$\" . Such prefix is again the string \"i\" , therefore LCP[2] = 1 . etc... Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.LongestCommonPrefix.html": {
    "href": "api/MoreStructures.SuffixArrays.LongestCommonPrefix.html",
    "title": "Namespace MoreStructures.SuffixArrays.LongestCommonPrefix",
    "keywords": "Namespace MoreStructures.SuffixArrays.LongestCommonPrefix Classes MoreStructures.SuffixArrays.LongestCommonPrefix. The LCP Array of a string S of length n is defined as an array LCP of length n - 1 such that LCP[i] is the length of the prefix in common between the suffixes starting at SA[i] and SA[i + 1], where SA is the Suffix Array of S, for each i from 0 to n - 1 excluded. KasaiLcpArrayBuilder An ILcpArrayBuilder implementation which uses the Kasai's algorithm (2001) to compute the LCP Array in linear time. NaiveLcpArrayBuilder An implementation of ILcpArrayBuilder which calculates the LCP Array using the definition. Interfaces ILcpArrayBuilder An algorithm finding the Longest Common Prefix (LCP) Array of a string."
  },
  "api/MoreStructures.SuffixArrays.LongestCommonPrefix.ILcpArrayBuilder.html": {
    "href": "api/MoreStructures.SuffixArrays.LongestCommonPrefix.ILcpArrayBuilder.html",
    "title": "Interface ILcpArrayBuilder",
    "keywords": "Interface ILcpArrayBuilder An algorithm finding the Longest Common Prefix (LCP) Array of a string. Namespace : MoreStructures.SuffixArrays.LongestCommonPrefix Assembly : MoreStructures.dll Syntax public interface ILcpArrayBuilder Remarks Check MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray for further information about LCP Arrays. Examples TextWithTerminator text = new(\"mississippi\"); ILcpArrayBuilder lcpArrayBuilder = ... // Some implementation of ILcpArrayBuilder var lcpArray = lcpArrayBuilder.Build().ToList(); // ToList necessary if Build is lazy lcpArray is new List<int> { 0, 1, 1, ... } Methods | Improve this Doc View Source Build() Builds the MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray . Declaration LcpArray Build() Returns Type Description MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray A MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray , wrapping the length of prefixes in common in a of System.Int32 . Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.LongestCommonPrefix.KasaiLcpArrayBuilder.html": {
    "href": "api/MoreStructures.SuffixArrays.LongestCommonPrefix.KasaiLcpArrayBuilder.html",
    "title": "Class KasaiLcpArrayBuilder",
    "keywords": "Class KasaiLcpArrayBuilder An ILcpArrayBuilder implementation which uses the Kasai's algorithm (2001) to compute the LCP Array in linear time. Inheritance System.Object NaiveLcpArrayBuilder KasaiLcpArrayBuilder Implements ILcpArrayBuilder Inherited Members NaiveLcpArrayBuilder.Text NaiveLcpArrayBuilder.SuffixArray System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays.LongestCommonPrefix Assembly : MoreStructures.dll Syntax public class KasaiLcpArrayBuilder : NaiveLcpArrayBuilder, ILcpArrayBuilder Remarks ADVANTAGES AND DISADVANTAGES - Compared to the naive implementation following the definition of LCP Array, implemented by NaiveLcpArrayBuilder , this algorithm has better runtime and equal Space Complexity. - The better runtime comes at the cost of the complexity of the algorithm itself, which is harder to analyze. - Moreover, unlike in the naive implementation, the construction of the array doesn't proceed in order, i.e. it doesn't proceed from the first element to the last element of the array. - That is, the Kasai's algorithm is not online and, in its base form, cannot be easily made lazy. ALGORITHM - The algorithm requires 3 data structures to operate: the text T, its Suffix Array SA and the Inverted Suffix Array ISA. The three data structures have n items (chars or integers). - T and SA are externally provided, whereas ISA is calculated scanning linearly SA and populating a dictionary of positions of SA: ISA[v] = i such that SA[i] = v . Because there is no better general algorithm than a single linear scan of the input, ISA is internally calculated, rather than externally provided. - The current LCP length, named here CLCP, is initialized to 0, and the index of the current suffix in T, named here CS, is initialized to the first item of SA: CLCP = 0; CS = SA[0] . This is the setup before the main loop. - Then n iterations are performed, filling in the resulting LPC array, named here LCPA, initialized to an empty array of length n - 1. - At each iteration the index in SA of the current suffix (starting in T at index CS), is calculated via ISA: k = ISA[CS] . - Then, the next suffix in T, named here NS, is calculated as the successor of k in SA: NS = SA[k + 1] . - Important: if ISA[CS] is the last index of SA (i.e. n - 1), then CLCP is reset and the current iteration skipped. - A new value of CLCP is calculated as the longest common prefix between T[CS..] and T[NS..], skipping the first CLCP - 1 chars, which are equal by construction. - Such new value of CLCP is then assigned to LCPA at index - Finally, the index of the current suffix in T, CS, is incremented modulo n and the current iteration terminates. - After the loop, LCPA is fully populated and can be returned as result. COMPLEXITY - Text and Suffix Array evaluation (required to have direct access by index) are O(n) operations, both in time and space. - Inversion of the Suffix Array is also a O(n) operation. - Initialization of the current LCP and the current prefix are constant-time operations. - The main loop of the algorithm runs n iterations. - The only operation which doesn't take constant time in the body of the loop is the LCP between the current suffix, initialized at the first item of the Suffix Array and then incremented by 1 modulo n at every iteration, and the next suffix, calculated via Suffix Array and its inverted version. - While the above is true, it should be noted that the current LCP is increased once per match and decreased once per iteration. Because the current LCP cannot be bigger than n (that's the biggest number of chars a prefix can have, hence the bigger number of chars in common between two prefixes), the total number of comparisons across all iterations is O(n). - Therefore, Time and Space Complexity are O(n). Constructors | Improve this Doc View Source KasaiLcpArrayBuilder(TextWithTerminator, SuffixArray) Declaration public KasaiLcpArrayBuilder(TextWithTerminator text, SuffixArray suffixArray) Parameters Type Name Description TextWithTerminator text MoreStructures.SuffixArrays.SuffixArray suffixArray Remarks Methods | Improve this Doc View Source Build() Declaration public override LcpArray Build() Returns Type Description MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray Overrides NaiveLcpArrayBuilder.Build() Remarks Implements ILcpArrayBuilder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixArrays.LongestCommonPrefix.NaiveLcpArrayBuilder.html": {
    "href": "api/MoreStructures.SuffixArrays.LongestCommonPrefix.NaiveLcpArrayBuilder.html",
    "title": "Class NaiveLcpArrayBuilder",
    "keywords": "Class NaiveLcpArrayBuilder An implementation of ILcpArrayBuilder which calculates the LCP Array using the definition. Inheritance System.Object NaiveLcpArrayBuilder KasaiLcpArrayBuilder Implements ILcpArrayBuilder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixArrays.LongestCommonPrefix Assembly : MoreStructures.dll Syntax public class NaiveLcpArrayBuilder : ILcpArrayBuilder Remarks ADVANTAGES AND DISADVANTAGES - This implementation is the most straightforward, as the algorithm closely follows the definition. - As such it is easy to implement and analyze, at the cost of worse Time and Space complexity than smarter implementations, using, for example, specific properties of subsequent LCP items of suffixes from the Suffix Array. - The algorithm is also online. Therefore, values can be lazily computed. ALGORITHM - The implementation uses the externally provided SuffixArray , in combination with the Text . - It iterates over the first n - 1 items of the SuffixArray SA, using LongestCommonPrefix(IEnumerable<Char>, IEnumerable<Char>) to calculate the length of the LCP between SA[i] and its successor, SA[i + 1]. - That represents the i-th element of the LCP Array. COMPLEXITY - The SuffixArray is externally provided, so it's building cost is not included in this analysis. - The algorithm runs n - 1 iterations, each one building two strings (the prefix starting at SA[i] and the one starting at SA[i + 1]), then comparing them char by char, to find the LCP. - Prefixes have in general O(n) length, and LongestCommonPrefix(IEnumerable<Char>, IEnumerable<Char>) has Time Complexity linear in the input, and constant Space Complexity. - Therefore, Time Complexity is O(n^2) and Space Complexity is O(n). Constructors | Improve this Doc View Source NaiveLcpArrayBuilder(TextWithTerminator, SuffixArray) Declaration public NaiveLcpArrayBuilder(TextWithTerminator text, SuffixArray suffixArray) Parameters Type Name Description TextWithTerminator text MoreStructures.SuffixArrays.SuffixArray suffixArray Remarks Properties | Improve this Doc View Source SuffixArray The Suffix Array of the Text , required to calculate the MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray . Declaration public SuffixArray SuffixArray { get; } Property Value Type Description MoreStructures.SuffixArrays.SuffixArray | Improve this Doc View Source Text The terminator-terminated string, to calculate the MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray of. Declaration public TextWithTerminator Text { get; } Property Value Type Description TextWithTerminator Methods | Improve this Doc View Source Build() Declaration public virtual LcpArray Build() Returns Type Description MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray Remarks Implements ILcpArrayBuilder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixStructures.AdjacencyOrders.html": {
    "href": "api/MoreStructures.SuffixStructures.AdjacencyOrders.html",
    "title": "Enum AdjacencyOrders",
    "keywords": "Enum AdjacencyOrders The possible adjacency order relationships between two edges by the parts they refer to in the text. Namespace : MoreStructures.SuffixStructures Assembly : MoreStructures.dll Syntax public enum AdjacencyOrders Fields Name Description After Adjacent in a specific order: the first comes after the second. Before Adjacent in a specific order: the first comes before the second. BeforeOrAfter Adjacent in any order. None Non-adjacent (overlapping on more than an extreme or not at all). Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, AdjacencyOrders>(TextWithTerminator)"
  },
  "api/MoreStructures.SuffixStructures.Builders.BuilderExtensions.html": {
    "href": "api/MoreStructures.SuffixStructures.Builders.BuilderExtensions.html",
    "title": "Class BuilderExtensions",
    "keywords": "Class BuilderExtensions Extension methods for all IBuilder<TEdge, TNode> concretions. Inheritance System.Object BuilderExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixStructures.Builders Assembly : MoreStructures.dll Syntax public static class BuilderExtensions Methods | Improve this Doc View Source BuildTree<TEdge, TNode>(IBuilder<TEdge, TNode>, String) Text is provided as a plain string. Declaration public static TNode BuildTree<TEdge, TNode>(this IBuilder<TEdge, TNode> builder, string text) where TEdge : ISuffixStructureEdge<TEdge, TNode> where TNode : ISuffixStructureNode<TEdge, TNode> Parameters Type Name Description IBuilder <TEdge, TNode> builder The builder to be used, to build the structure. System.String text The text to build the structure of, without any terminator (automatically added). Returns Type Description TNode Type Parameters Name Description TEdge TNode"
  },
  "api/MoreStructures.SuffixStructures.Builders.html": {
    "href": "api/MoreStructures.SuffixStructures.Builders.html",
    "title": "Namespace MoreStructures.SuffixStructures.Builders",
    "keywords": "Namespace MoreStructures.SuffixStructures.Builders Classes BuilderExtensions Extension methods for all IBuilder<TEdge, TNode> concretions. Interfaces IBuilder<TEdge, TNode> Builds objects, such as edges and nodes, for the ISuffixStructureNode<TEdge, TNode> concretion it is the builder of."
  },
  "api/MoreStructures.SuffixStructures.Builders.IBuilder-2.html": {
    "href": "api/MoreStructures.SuffixStructures.Builders.IBuilder-2.html",
    "title": "Interface IBuilder<TEdge, TNode>",
    "keywords": "Interface IBuilder<TEdge, TNode> Builds objects, such as edges and nodes, for the ISuffixStructureNode<TEdge, TNode> concretion it is the builder of. Namespace : MoreStructures.SuffixStructures.Builders Assembly : MoreStructures.dll Syntax public interface IBuilder<TEdge, TNode> where TEdge : ISuffixStructureEdge<TEdge, TNode> where TNode : ISuffixStructureNode<TEdge, TNode> Type Parameters Name Description TEdge TNode Remarks This interface allows to have a shared construction interface for objects among all structures. Object construction is externalized into a Builder object as a workaround to the limitation of not having constructor signatures directly in interfaces. See https://codeblog.jonskeet.uk/2008/08/29/lessons-learned-from-protocol-buffers-part-4-static-interfaces/ Methods | Improve this Doc View Source BuildTree(TextWithTerminator[]) Build a ISuffixStructureEdge<TEdge, TNode> of the provided text(s), which is a n-ary search tree in which edges coming out of a node are substrings of at least one of the texts and nodes are not directly labeled instead. Declaration TNode BuildTree(params TextWithTerminator[] texts) Parameters Type Name Description TextWithTerminator [] texts The text(s) to build the Suffix Structure of, each one with its own unique terminator (required for traversal). Returns Type Description TNode The root node of the Suffix Structure. Remarks TERMINATORS Terminators have to be unique characters, not just on the single TextWithTerminator they are appended to, but to all TextWithTerminator items in texts . That means that if texts is (T1, ..., Tn), where each TextWithTerminator Ti has ti as Terminator , ti should not be in any of the Text of Tj, for any j. GENERALIZED SUFFIX STRUCTURES When multiple TextWithTerminator instances are passed into texts , the Suffix Structure built is known as Generalized Suffix Structure (e.g. Generalized Suffix Tree or Trie). It differs from a normal Suffix Structure built for the concatenation of items in texts by the fact that it doesn't contain any root-to-leaf path identifying a suffix which spans multiple texts. When a Suffix Structure is built for a single TextWithTerminator which a concatenation of multiple texts, each with its own terminator T1 || t1 || ... || Tn || tn , the resulting structure has branches which span over multiple texts, such as suffixOf[Ti] || ti || prefixOf[T(i+1)] or suffixOf[Ti] || ti || T(i+1) || t(i+1) || prefixOf[T(i+2)] . A Generalized Suffix Structure trims those branches in construction, so that each node-to-leaf branch ends with any of the terminator t1, ..., tn (not always tn) and doesn't contain any other terminator except the ending one. EDGES Substrings of a text are identified by their start position in text and their length, rather than by a copy of the substring itself. The technique, known as Edge Compression allows to store edges information in constant space, and the entire tree in linear space w.r.t. the number of nodes in the tree (which can be linear or not in the input, depending on the type of suffix structure). The sequence of edges in root-to-node paths in the tree identify prefixes in common to multiple suffixes of the text(s). Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) BuilderExtensions.BuildTree<TEdge, TNode>(IBuilder<TEdge, TNode>, String)"
  },
  "api/MoreStructures.SuffixStructures.Conversions.FullyIterativeConverter.html": {
    "href": "api/MoreStructures.SuffixStructures.Conversions.FullyIterativeConverter.html",
    "title": "Class FullyIterativeConverter",
    "keywords": "Class FullyIterativeConverter Inheritance System.Object FullyIterativeConverter Implements IConverter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixStructures.Conversions Assembly : MoreStructures.dll Syntax public class FullyIterativeConverter : IConverter Remarks ADVANTAGES AND DISADVANTAGES Conversion is done iteratively both for branching and no-branching paths (i.e. on nodes having a single child) of the input SuffixTrieNode , with occasional mutation of internal state of the conversion and the use of a stack to store nodes to process. Not limited by call stack depth. Convenient with deep trees (i.e. trees having a height > ~1K nodes). Methods | Improve this Doc View Source TreeToTrie(SuffixTreeNode) Declaration public SuffixTrieNode TreeToTrie(SuffixTreeNode treeNode) Parameters Type Name Description SuffixTreeNode treeNode Returns Type Description SuffixTrieNode Remarks | Improve this Doc View Source TrieToTree(SuffixTrieNode) Declaration public SuffixTreeNode TrieToTree(SuffixTrieNode trieNode) Parameters Type Name Description SuffixTrieNode trieNode Returns Type Description SuffixTreeNode Remarks Implements IConverter Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixStructures.Conversions.FullyRecursiveConverter.html": {
    "href": "api/MoreStructures.SuffixStructures.Conversions.FullyRecursiveConverter.html",
    "title": "Class FullyRecursiveConverter",
    "keywords": "Class FullyRecursiveConverter Inheritance System.Object FullyRecursiveConverter Implements IConverter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixStructures.Conversions Assembly : MoreStructures.dll Syntax public class FullyRecursiveConverter : IConverter Remarks Implemented fully recursively, with one level of recursion per level of the input SuffixTrieNode . Limited by call stack depth and usable with input trees of a \"reasonable\" height (i.e. trees having a height < ~1K nodes). Methods | Improve this Doc View Source TreeToTrie(SuffixTreeNode) Declaration public SuffixTrieNode TreeToTrie(SuffixTreeNode treeNode) Parameters Type Name Description SuffixTreeNode treeNode Returns Type Description SuffixTrieNode Remarks | Improve this Doc View Source TrieToTree(SuffixTrieNode) Declaration public SuffixTreeNode TrieToTree(SuffixTrieNode trieNode) Parameters Type Name Description SuffixTrieNode trieNode Returns Type Description SuffixTreeNode Remarks Implements IConverter Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixStructures.Conversions.html": {
    "href": "api/MoreStructures.SuffixStructures.Conversions.html",
    "title": "Namespace MoreStructures.SuffixStructures.Conversions",
    "keywords": "Namespace MoreStructures.SuffixStructures.Conversions Classes FullyIterativeConverter FullyRecursiveConverter PartiallyIterativeConverter Interfaces IConverter A converter between different ISuffixStructureNode<TEdge, TNode> structures, such as SuffixTrieNode and SuffixTreeNode ."
  },
  "api/MoreStructures.SuffixStructures.Conversions.IConverter.html": {
    "href": "api/MoreStructures.SuffixStructures.Conversions.IConverter.html",
    "title": "Interface IConverter",
    "keywords": "Interface IConverter A converter between different ISuffixStructureNode<TEdge, TNode> structures, such as SuffixTrieNode and SuffixTreeNode . Namespace : MoreStructures.SuffixStructures.Conversions Assembly : MoreStructures.dll Syntax public interface IConverter Methods | Improve this Doc View Source TreeToTrie(SuffixTreeNode) Converts the provided SuffixTreeNode instance into an equivalent instance of SuffixTrieNode , building its entire structure. Declaration SuffixTrieNode TreeToTrie(SuffixTreeNode treeNode) Parameters Type Name Description SuffixTreeNode treeNode The node identifying the trie structure to be converted. Returns Type Description SuffixTrieNode A trie, equivalent to the provided tree. Remarks COMPLEXITY Time Complexity = O(n^2) and Space Complexity = O(n^2) where n = number of nodes in the input structure. Each node of the input tree is visited at most twice. However, expansion increase the number of nodes, in the worst case to the number of characters in all suffixes of the text which has generated the tree. | Improve this Doc View Source TrieToTree(SuffixTrieNode) Converts the provided SuffixTrieNode instance into an equivalent instance of SuffixTreeNode , building its entire structure. Declaration SuffixTreeNode TrieToTree(SuffixTrieNode trieNode) Parameters Type Name Description SuffixTrieNode trieNode The node identifying the trie structure to be converted. Returns Type Description SuffixTreeNode A tree, equivalent to the provided trie. Remarks COMPLEXITY Time Complexity = O(n) and Space Complexity = O(n) where n = number of nodes in the input structure. Each node of the input trie is visited at most twice and coalescing reduces the number of nodes. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixStructures.Conversions.PartiallyIterativeConverter.html": {
    "href": "api/MoreStructures.SuffixStructures.Conversions.PartiallyIterativeConverter.html",
    "title": "Class PartiallyIterativeConverter",
    "keywords": "Class PartiallyIterativeConverter Inheritance System.Object PartiallyIterativeConverter Implements IConverter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixStructures.Conversions Assembly : MoreStructures.dll Syntax public class PartiallyIterativeConverter : IConverter Remarks Conversion is iteratively for no-branching paths (i.e. on nodes having a single child) and recursively on branching of the input SuffixTrieNode , with occasional mutation of internal state of the conversion. Limited by stack depth (but less than FullyRecursiveConverter ) and usable with output trees of a \"reasonable\" height (i.e. trees having a height < ~1K nodes). Methods | Improve this Doc View Source TreeToTrie(SuffixTreeNode) Declaration public SuffixTrieNode TreeToTrie(SuffixTreeNode treeNode) Parameters Type Name Description SuffixTreeNode treeNode Returns Type Description SuffixTrieNode Remarks | Improve this Doc View Source TrieToTree(SuffixTrieNode) Declaration public SuffixTreeNode TrieToTree(SuffixTrieNode trieNode) Parameters Type Name Description SuffixTrieNode trieNode Returns Type Description SuffixTreeNode Remarks Implements IConverter Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixStructures.html": {
    "href": "api/MoreStructures.SuffixStructures.html",
    "title": "Namespace MoreStructures.SuffixStructures",
    "keywords": "Namespace MoreStructures.SuffixStructures Classes SuffixStructureEdgeExtensions Extension methods for all ISuffixStructureEdge<TEdge, TNode> edge concretions. SuffixStructureNodeExtensions Extension methods for all ISuffixStructureNode<TEdge, TNode> node concretions. SuffixStructureTreePathExtensions Extension methods for all TreePath<TEdge, TNode> used in ISuffixStructureNode<TEdge, TNode> structures. Interfaces ISuffixStructureEdge<TEdge, TNode> An edge of a ISuffixStructureEdge<TEdge, TNode> , directionally linking two nodes and forming a path hop. Represents prefix matching. ISuffixStructureNode<TEdge, TNode> The node of a Suffix Structure, linked by edges and forming paths. Represents pattern matching state. Enums AdjacencyOrders The possible adjacency order relationships between two edges by the parts they refer to in the text."
  },
  "api/MoreStructures.SuffixStructures.ISuffixStructureEdge-2.html": {
    "href": "api/MoreStructures.SuffixStructures.ISuffixStructureEdge-2.html",
    "title": "Interface ISuffixStructureEdge<TEdge, TNode>",
    "keywords": "Interface ISuffixStructureEdge<TEdge, TNode> An edge of a ISuffixStructureEdge<TEdge, TNode> , directionally linking two nodes and forming a path hop. Represents prefix matching. Inherited Members TextWithTerminator.ISelector.Of(TextWithTerminator) TextWithTerminator.ISelector.OfRotated(RotatedTextWithTerminator) Namespace : MoreStructures.SuffixStructures Assembly : MoreStructures.dll Syntax public interface ISuffixStructureEdge<TEdge, TNode> : TextWithTerminator.ISelector, IRecImmDictIndexedTreeEdge<TEdge, TNode> where TEdge : ISuffixStructureEdge<TEdge, TNode> where TNode : ISuffixStructureNode<TEdge, TNode> Type Parameters Name Description TEdge TNode Properties | Improve this Doc View Source Length The length of the edge string. Declaration int Length { get; } Property Value Type Description System.Int32 | Improve this Doc View Source Start The index of the first character of the edge string in the text. Declaration int Start { get; } Property Value Type Description System.Int32 Extension Methods SuffixStructureEdgeExtensions.IsAdjacentTo<TEdge, TNode>(ISuffixStructureEdge<TEdge, TNode>, TEdge, AdjacencyOrders) SuffixStructureEdgeExtensions.ContainsIndex<TEdge, TNode>(ISuffixStructureEdge<TEdge, TNode>, Int32) SuffixStructureEdgeExtensions.ContainsIndexesNonBiggerThan<TEdge, TNode>(ISuffixStructureEdge<TEdge, TNode>, Int32) SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixStructures.ISuffixStructureNode-2.html": {
    "href": "api/MoreStructures.SuffixStructures.ISuffixStructureNode-2.html",
    "title": "Interface ISuffixStructureNode<TEdge, TNode>",
    "keywords": "Interface ISuffixStructureNode<TEdge, TNode> The node of a Suffix Structure, linked by edges and forming paths. Represents pattern matching state. Inherited Members IRecImmDictIndexedTreeNode<TEdge, TNode>.Children Namespace : MoreStructures.SuffixStructures Assembly : MoreStructures.dll Syntax public interface ISuffixStructureNode<TEdge, TNode> : IRecImmDictIndexedTreeNode<TEdge, TNode> where TEdge : ISuffixStructureEdge<TEdge, TNode> where TNode : ISuffixStructureNode<TEdge, TNode> Type Parameters Name Description TEdge TNode Properties | Improve this Doc View Source Start The index of the character, the path from the root leading to this leaf starts with. Non-null for leaves only. Declaration int? Start { get; } Property Value Type Description System.Nullable < System.Int32 > Extension Methods RecImmDictIndexedTreeNodeExtensions.IsLeaf<TEdge, TNode>(IRecImmDictIndexedTreeNode<TEdge, TNode>) SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) Matcher.Match<TEdge, TNode>(ISuffixStructureNode<TEdge, TNode>, TextWithTerminator, String)"
  },
  "api/MoreStructures.SuffixStructures.Matching.html": {
    "href": "api/MoreStructures.SuffixStructures.Matching.html",
    "title": "Namespace MoreStructures.SuffixStructures.Matching",
    "keywords": "Namespace MoreStructures.SuffixStructures.Matching Classes Matcher Exposes utility methods to match a TextWithTerminator against a ISuffixStructureNode<TEdge, TNode> concretion. NaiveSnssFinder A ISnssFinder implementation which checks for the presence of each substring of the first text in the second text, from the longest to the shortest. SuffixStructureBasedSnssFinder Base class for all ISnssFinder concretions which implement Find(IEnumerable<Char>, IEnumerable<Char>) using a suffix structure (a concretions of ISuffixStructureNode<TEdge, TNode> , implementing IRecImmDictIndexedTreeNode<TEdge, TNode> ), such as SuffixTreeNode or SuffixTrieNode ). SuffixTreeBasedSnssFinder A ISnssFinder implementation and SuffixStructureBasedSnssFinder concretion which uses a SuffixTreeNode structure to implement Find(IEnumerable<Char>, IEnumerable<Char>) . SuffixTrieBasedSnssFinder A ISnssFinder implementation and SuffixStructureBasedSnssFinder concretion which uses a SuffixTrieNode structure to implement Find(IEnumerable<Char>, IEnumerable<Char>) . Interfaces ISnssFinder Any algorithm finding the Shortest Non-shared Substring (Snss) between two strings."
  },
  "api/MoreStructures.SuffixStructures.Matching.ISnssFinder.html": {
    "href": "api/MoreStructures.SuffixStructures.Matching.ISnssFinder.html",
    "title": "Interface ISnssFinder",
    "keywords": "Interface ISnssFinder Any algorithm finding the Shortest Non-shared Substring (Snss) between two strings. Namespace : MoreStructures.SuffixStructures.Matching Assembly : MoreStructures.dll Syntax public interface ISnssFinder Methods | Improve this Doc View Source Find(IEnumerable<Char>, IEnumerable<Char>) Returns any substring of text1 which is not present in text2 and has minimal length. Returns null if there is no substring of text1 which is not a substring of text2 , i.e. if the two string coincide. Declaration IEnumerable<string> Find(IEnumerable<char> text1, IEnumerable<char> text2) Parameters Type Name Description IEnumerable < System.Char > text1 The sequence of chars of the first text. IEnumerable < System.Char > text2 The sequence of chars of the second text. Returns Type Description IEnumerable < System.String > A sequence of strings, each being a substring of text1 not in text2 , of minimal length. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixStructures.Matching.Matcher.html": {
    "href": "api/MoreStructures.SuffixStructures.Matching.Matcher.html",
    "title": "Class Matcher",
    "keywords": "Class Matcher Exposes utility methods to match a TextWithTerminator against a ISuffixStructureNode<TEdge, TNode> concretion. Inheritance System.Object Matcher Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixStructures.Matching Assembly : MoreStructures.dll Syntax public static class Matcher Methods | Improve this Doc View Source Match<TEdge, TNode>(ISuffixStructureNode<TEdge, TNode>, TextWithTerminator, String) Tries to match a pattern against a ISuffixStructureNode<TEdge, TNode> built on a text. Declaration public static Match<TreePath<TEdge, TNode>> Match<TEdge, TNode>(this ISuffixStructureNode<TEdge, TNode> node, TextWithTerminator text, string pattern) where TEdge : ISuffixStructureEdge<TEdge, TNode> where TNode : ISuffixStructureNode<TEdge, TNode> Parameters Type Name Description ISuffixStructureNode <TEdge, TNode> node The root of the Suffix Tree, to match the suffix of text against. TextWithTerminator text The text whose Suffix Tree has to be matched against the pattern. System.String pattern The pattern to match. Unlike text, is a string without terminator. Returns Type Description Match < TreePath <TEdge, TNode>> A successful or non-successful match. Type Parameters Name Description TEdge TNode Remarks COMPLEXITY Time Complexity = O(t * as) and Space Complexity = O(t * as) where t = length of the text to match and as = size of the alphabet of the text. If the alphabet is of constant size, complexity is linear."
  },
  "api/MoreStructures.SuffixStructures.Matching.NaiveSnssFinder.html": {
    "href": "api/MoreStructures.SuffixStructures.Matching.NaiveSnssFinder.html",
    "title": "Class NaiveSnssFinder",
    "keywords": "Class NaiveSnssFinder A ISnssFinder implementation which checks for the presence of each substring of the first text in the second text, from the longest to the shortest. Inheritance System.Object NaiveSnssFinder Implements ISnssFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixStructures.Matching Assembly : MoreStructures.dll Syntax public class NaiveSnssFinder : ISnssFinder Remarks ADVANTAGES AND DISADVANTAGES - Unlike SuffixStructureBasedSnssFinder derivations, this implementation doesn't require terminators, since it does not build any auxialiary structure. - It also doesn't require additional space, except for iterations and index variables. So, it's a good solution for small input, when space is a hard constraint, much more than time. ALGORITHM - Lazily iterates over all substrings of text1, from the shortest (length 1) to the longest (length - 1). - As soon as it finds one which is not contained in text2, it yield returns it. COMPLEXITY - Checking all substrings of text1 of variable length, from 1 to length - 1, is a quadratic with the length of text1. It doesn't require more than constant space (for iterators and index variables) when using string ranges (which are views of larger strings, optimized thanks to immutability. - Each check of a substring of text1 in text2 takes O(sl) time, where sl is the length of the substring. Since the average length of the substring depends linearly on the length of text1 n, the check takes O(n). - So overall Time Complexity is O(n^3) and Space Complexity is O(1). Methods | Improve this Doc View Source Find(IEnumerable<Char>, IEnumerable<Char>) Declaration public IEnumerable<string> Find(IEnumerable<char> text1, IEnumerable<char> text2) Parameters Type Name Description IEnumerable < System.Char > text1 IEnumerable < System.Char > text2 Returns Type Description IEnumerable < System.String > Remarks Implements ISnssFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixStructures.Matching.SuffixStructureBasedSnssFinder.html": {
    "href": "api/MoreStructures.SuffixStructures.Matching.SuffixStructureBasedSnssFinder.html",
    "title": "Class SuffixStructureBasedSnssFinder",
    "keywords": "Class SuffixStructureBasedSnssFinder Base class for all ISnssFinder concretions which implement Find(IEnumerable<Char>, IEnumerable<Char>) using a suffix structure (a concretions of ISuffixStructureNode<TEdge, TNode> , implementing IRecImmDictIndexedTreeNode<TEdge, TNode> ), such as SuffixTreeNode or SuffixTrieNode ). Inheritance System.Object SuffixStructureBasedSnssFinder SuffixTreeBasedSnssFinder SuffixTrieBasedSnssFinder Implements ISnssFinder Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixStructures.Matching Assembly : MoreStructures.dll Syntax public abstract class SuffixStructureBasedSnssFinder : ISnssFinder Constructors | Improve this Doc View Source SuffixStructureBasedSnssFinder(Char, Char) Builds an instance with the provided terminators, validating the input by default. All text passed to Find(IEnumerable<Char>, IEnumerable<Char>) must conform with these two terminators. Declaration protected SuffixStructureBasedSnssFinder(char terminator1, char terminator2) Parameters Type Name Description System.Char terminator1 System.Char terminator2 Properties | Improve this Doc View Source Terminator1 A special char to be used as end delimiter for the first text, used for building the suffix structure. Should not occur in first text, nor in the second, since a single suffix structure is built, embedding both texts (a.k.a. generalized suffix structure). Declaration public char Terminator1 { get; } Property Value Type Description System.Char | Improve this Doc View Source Terminator2 A special char to be used as end delimiter for the second text, used for building the suffix structure. Should not occur in first text, nor in the second, since a single suffix structure is built, embedding both texts (a.k.a. generalized suffix structure). Declaration public char Terminator2 { get; } Property Value Type Description System.Char | Improve this Doc View Source ValidateInput Whether the two sequences of chars (first and second text) should be evaluated, in order to make sure that are valid, i.e. they don't contain Terminator1 nor Terminator2 . By default set to true . Declaration public bool ValidateInput { get; set; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source CollectPrefixChars<TEdge, TNode>(TextWithTerminator, TNode, IDictionary<TNode, TreeTraversalVisit<TEdge, TNode>>) Rebuilds the root-to-node prefix, from initialNode up to the root of the Suffix Tree (node with no parent), using the provided cache of visited nodes, cachedVisits , to navigate the Suffix Tree upwards. Declaration protected static IEnumerable<string> CollectPrefixChars<TEdge, TNode>(TextWithTerminator text, TNode initialNode, IDictionary<TNode, TreeTraversalVisit<TEdge, TNode>> cachedVisits) where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode>, TextWithTerminator.ISelector where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Parameters Type Name Description TextWithTerminator text The text used to generate the Suffix Tree, and to be used to rebuild the prefix. TNode initialNode The node, to start navigating from. IDictionary <TNode, TreeTraversalVisit <TEdge, TNode>> cachedVisits A dictionary of visits by node, to jump from a node to its parent. Returns Type Description IEnumerable < System.String > A lazily generated sequence of strings, corresponding to the edges from initialNode up to the root of the Suffix Tree. Empty if initialNode is the root of the tree. Type Parameters Name Description TEdge TNode | Improve this Doc View Source Find(IEnumerable<Char>, IEnumerable<Char>) Returns any substring of text1 which is not present in text2 and has minimal length. Returns null if there is no substring of text1 which is not a substring of text2 , i.e. if the two string coincide. Declaration public abstract IEnumerable<string> Find(IEnumerable<char> text1, IEnumerable<char> text2) Parameters Type Name Description IEnumerable < System.Char > text1 The sequence of chars of the first text. IEnumerable < System.Char > text2 The sequence of chars of the second text. Returns Type Description IEnumerable < System.String > A sequence of strings, each being a substring of text1 not in text2 , of minimal length. | Improve this Doc View Source ValidateTexts(IEnumerable<Char>, IEnumerable<Char>) Validates the provided texts against this finder, checking that they are compatible with Terminator1 and Terminator2 . Declaration protected void ValidateTexts(IEnumerable<char> text1, IEnumerable<char> text2) Parameters Type Name Description IEnumerable < System.Char > text1 The first text to validate. IEnumerable < System.Char > text2 The second text to validate. Implements ISnssFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixStructures.Matching.SuffixTreeBasedSnssFinder.html": {
    "href": "api/MoreStructures.SuffixStructures.Matching.SuffixTreeBasedSnssFinder.html",
    "title": "Class SuffixTreeBasedSnssFinder",
    "keywords": "Class SuffixTreeBasedSnssFinder A ISnssFinder implementation and SuffixStructureBasedSnssFinder concretion which uses a SuffixTreeNode structure to implement Find(IEnumerable<Char>, IEnumerable<Char>) . Inheritance System.Object SuffixStructureBasedSnssFinder SuffixTreeBasedSnssFinder Implements ISnssFinder Inherited Members SuffixStructureBasedSnssFinder.Terminator1 SuffixStructureBasedSnssFinder.Terminator2 SuffixStructureBasedSnssFinder.ValidateInput SuffixStructureBasedSnssFinder.ValidateTexts(IEnumerable<Char>, IEnumerable<Char>) SuffixStructureBasedSnssFinder.CollectPrefixChars<TEdge, TNode>(TextWithTerminator, TNode, IDictionary<TNode, TreeTraversalVisit<TEdge, TNode>>) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixStructures.Matching Assembly : MoreStructures.dll Syntax public class SuffixTreeBasedSnssFinder : SuffixStructureBasedSnssFinder, ISnssFinder Remarks ADVANTAGES AND DISADVANTAGES - Compared to the naive implementation of NaiveSnssFinder , has both average and worst case better runtime, at the cost of space used (which is O(1) for the naive implementation). - Compared to SuffixTrieBasedSnssFinder , it has better Time and Space Complexity, due to Branches Coaleascing combined with Path Compression. It's, however, more complex to implement, visualize and debug step-by-step. ALGORITHM - First uses the UkkonenSuffixTreeBuilder to build a suffix tree of the concatenation of first text, Terminator1 , second text and Terminator2 , stopping branches at the first terminator encountered. This structure is also known as Generalized Suffix Tree. - Visit the suffix tree breadth-first, stopping at the first node such that the root-to-node prefix is substring of text1 but not of text2. - The root-to-node prefix is a substring of text1 when there is a path-to-leaf which contains an edge including Terminator1 . - The root-to-node prefix is NOT a substring of text2 when there is no path-to-leaf which doesn't contain Terminator1 . - Such substring of text1 is guaranteed to be the shortest in number of edges by the visit order imposed by the breadth-first search. However, unlike for Suffix Tries, in Suffix Trees the number of chars per edges varies. - Therefore, all pontential results have to be collected, then sorted by actual prefix length. COMPLEXITY - Validating the input requires going through text1 and text2, and takes linear time in the the number of chars n of the concatenated text \"text1 ## separator1 ## text2 ## separator2\", and constant space. - Building the Generalized Suffix Tree via the Ukkonen algorithm takes time and space at least proportional to the number of nodes of the tree, which is linear with n. - For each level of the breadth-first traversal of the trie, all node-to-leaf paths are checked (in the worst case). - There are at most n levels in the tree, since there can't be a path longer than a suffix of the concatenated text. The higher is the level, the shorter are node-to-leaf paths. However, their number is always the same or lower. - For each node there are as many node-to-leaf paths as leaves, and there are at most n leaves in the tree (since each suffix can add at most a single intermediate node and a single leaf, having terminator 1 or terminator2 as incoming edge). - Checking whether a path contains terminator1 takes constant space and a time proportional to the number of nodes in the path, which is O(n). - The following optimization is implemented: if a path P1 starting from a node N1 identifies a prefix p1 which is a potential SNSS, all paths starting from nodes Pi which are descendants of N1 would identify prefixes pi which would be longer than p1, so they can be excluded. - Rebuilding the string from each identified path takes O(n) time and space. Sorting would take time O(m * log(m) * n) where m is the number of potential SNSS (which is in average much smaller than n). - So in conclusion, Time Complexity is O(n^2) and Space Complexity is O(n). Constructors | Improve this Doc View Source SuffixTreeBasedSnssFinder(Char, Char) Builds an instance with the provided terminators, validating the input by default. All text passed to Find(IEnumerable<Char>, IEnumerable<Char>) must conform with these two terminators. Declaration public SuffixTreeBasedSnssFinder(char terminator1, char terminator2) Parameters Type Name Description System.Char terminator1 System.Char terminator2 Methods | Improve this Doc View Source Find(IEnumerable<Char>, IEnumerable<Char>) This implementation builds and uses a SuffixTreeNode structure to perform the search. Declaration public override IEnumerable<string> Find(IEnumerable<char> text1, IEnumerable<char> text2) Parameters Type Name Description IEnumerable < System.Char > text1 IEnumerable < System.Char > text2 Returns Type Description IEnumerable < System.String > Overrides SuffixStructureBasedSnssFinder.Find(IEnumerable<Char>, IEnumerable<Char>) Remarks Implements ISnssFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixStructures.Matching.SuffixTrieBasedSnssFinder.html": {
    "href": "api/MoreStructures.SuffixStructures.Matching.SuffixTrieBasedSnssFinder.html",
    "title": "Class SuffixTrieBasedSnssFinder",
    "keywords": "Class SuffixTrieBasedSnssFinder A ISnssFinder implementation and SuffixStructureBasedSnssFinder concretion which uses a SuffixTrieNode structure to implement Find(IEnumerable<Char>, IEnumerable<Char>) . Inheritance System.Object SuffixStructureBasedSnssFinder SuffixTrieBasedSnssFinder Implements ISnssFinder Inherited Members SuffixStructureBasedSnssFinder.Terminator1 SuffixStructureBasedSnssFinder.Terminator2 SuffixStructureBasedSnssFinder.ValidateInput SuffixStructureBasedSnssFinder.ValidateTexts(IEnumerable<Char>, IEnumerable<Char>) SuffixStructureBasedSnssFinder.CollectPrefixChars<TEdge, TNode>(TextWithTerminator, TNode, IDictionary<TNode, TreeTraversalVisit<TEdge, TNode>>) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixStructures.Matching Assembly : MoreStructures.dll Syntax public class SuffixTrieBasedSnssFinder : SuffixStructureBasedSnssFinder, ISnssFinder Remarks ADVANTAGES AND DISADVANTAGES - Compared to the naive implementation of NaiveSnssFinder , has better aberage runtime, at the cost of space used (which is O(1) for the naive implementation and at least quadratic here). - Compared to the SuffixTree-based implementation, it has way worse Time and Space Complexity, but it's easier to implement, visualize and debug step-by-step. ALGORITHM - First uses the NaivePartiallyRecursiveSuffixTrieBuilder to build a suffix trie of the concatenation of first text, Terminator1 , second text and Terminator2 , a.k.a. generalized suffix trie. - Visit the suffix trie breadth-first, stopping at the first node such that the root-to-node prefix is substring of text1 but not of text2. - The root-to-node prefix is a substring of text1 when there is a path-to-leaf which contains an edge including Terminator1 . - The root-to-node prefix is NOT a substring of text2 when there is no path-to-leaf which doesn't contain Terminator1 . - Such substring of text1 is guaranteed to be the shortest by the visit order imposed by the breadth-first search. This is true because trie edges are labelled by a single chars, so root-to-node paths which are longer by the number of edges correspond to longer prefixes. This is not true in general for Suffix Trees, where edge labels can vary in length, and a path which is composed of less edges may be longer in chars than a path with more edges but shorter labels in average. COMPLEXITY - Validating the input requires going through text1 and text2, and takes linear time in the the number of chars n of the concatenated text \"text1 ## separator1 ## text2 ## separator2\", and constant space. - Building the Generalized Suffix Trie takes time and space at least proportional to the number of nodes of the trie, which is quadratic with n (unlike for Suffix Trees). - For each level of the breadth-first traversal of the trie, all node-to-leaf paths are checked (in the worst case). - There are at most n levels in the trie, since there can't be a path longer than a suffix of the concatenated text, and all suffixes should be covered by the trie. The higher is the level, the shorter are node-to-leaf paths. However, their number is always the same or lower. - For each node there are as many node-to-leaf paths as leaves, and there are at most n leaves in the trie (since each suffix can add potentially multiple intermediate nodes, but always a single leaf, having terminator2 as incoming edge). - Checking whether a path contains terminator1 takes constant space and a time proportional to the number of nodes in the path, which is O(n). - Rebuilding the string from the identified path takes O(n) time and space. - So in conclusion, Time Complexity is O(n^3) and Space Complexity is O(n^2). Constructors | Improve this Doc View Source SuffixTrieBasedSnssFinder(Char, Char) Builds an instance with the provided terminators, validating the input by default. All text passed to Find(IEnumerable<Char>, IEnumerable<Char>) must conform with these two terminators. Declaration public SuffixTrieBasedSnssFinder(char terminator1, char terminator2) Parameters Type Name Description System.Char terminator1 System.Char terminator2 Methods | Improve this Doc View Source Find(IEnumerable<Char>, IEnumerable<Char>) This implementation builds and uses a SuffixTrieNode structure to perform the search. Declaration public override IEnumerable<string> Find(IEnumerable<char> text1, IEnumerable<char> text2) Parameters Type Name Description IEnumerable < System.Char > text1 IEnumerable < System.Char > text2 Returns Type Description IEnumerable < System.String > Overrides SuffixStructureBasedSnssFinder.Find(IEnumerable<Char>, IEnumerable<Char>) Remarks Implements ISnssFinder Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixStructures.SuffixStructureEdgeExtensions.html": {
    "href": "api/MoreStructures.SuffixStructures.SuffixStructureEdgeExtensions.html",
    "title": "Class SuffixStructureEdgeExtensions",
    "keywords": "Class SuffixStructureEdgeExtensions Extension methods for all ISuffixStructureEdge<TEdge, TNode> edge concretions. Inheritance System.Object SuffixStructureEdgeExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixStructures Assembly : MoreStructures.dll Syntax public static class SuffixStructureEdgeExtensions Methods | Improve this Doc View Source ContainsIndex<TEdge, TNode>(ISuffixStructureEdge<TEdge, TNode>, Int32) Whether the provided edge contains the provided index . Declaration public static bool ContainsIndex<TEdge, TNode>(this ISuffixStructureEdge<TEdge, TNode> edge, int index) where TEdge : ISuffixStructureEdge<TEdge, TNode> where TNode : ISuffixStructureNode<TEdge, TNode> Parameters Type Name Description ISuffixStructureEdge <TEdge, TNode> edge The edge to check. System.Int32 index The index of the char of the text, to look for. Must be non-negative. Returns Type Description System.Boolean A boolean. Type Parameters Name Description TEdge TNode | Improve this Doc View Source ContainsIndexesNonBiggerThan<TEdge, TNode>(ISuffixStructureEdge<TEdge, TNode>, Int32) Whether the provided edge has a Start lower or equal than the provided index . Declaration public static bool ContainsIndexesNonBiggerThan<TEdge, TNode>(this ISuffixStructureEdge<TEdge, TNode> edge, int index) where TEdge : ISuffixStructureEdge<TEdge, TNode> where TNode : ISuffixStructureNode<TEdge, TNode> Parameters Type Name Description ISuffixStructureEdge <TEdge, TNode> edge The edge to check. System.Int32 index The index of the char of the text, to look for. Must be non-negative. Returns Type Description System.Boolean A boolean. Type Parameters Name Description TEdge TNode | Improve this Doc View Source IsAdjacentTo<TEdge, TNode>(ISuffixStructureEdge<TEdge, TNode>, TEdge, AdjacencyOrders) Whether first is in adjacency order w.r.t. second , acoording to the provided order . Declaration public static bool IsAdjacentTo<TEdge, TNode>(this ISuffixStructureEdge<TEdge, TNode> first, TEdge second, AdjacencyOrders order = AdjacencyOrders.BeforeOrAfter) where TEdge : ISuffixStructureEdge<TEdge, TNode> where TNode : ISuffixStructureNode<TEdge, TNode> Parameters Type Name Description ISuffixStructureEdge <TEdge, TNode> first The edge to be compared for adjacency. TEdge second The edge to compare the first edge against. AdjacencyOrders order The adjacency relationship order to use for comparison. Returns Type Description System.Boolean True if the specified adjacency relationship is respected. Type Parameters Name Description TEdge TNode"
  },
  "api/MoreStructures.SuffixStructures.SuffixStructureNodeExtensions.html": {
    "href": "api/MoreStructures.SuffixStructures.SuffixStructureNodeExtensions.html",
    "title": "Class SuffixStructureNodeExtensions",
    "keywords": "Class SuffixStructureNodeExtensions Extension methods for all ISuffixStructureNode<TEdge, TNode> node concretions. Inheritance System.Object SuffixStructureNodeExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixStructures Assembly : MoreStructures.dll Syntax public static class SuffixStructureNodeExtensions Methods | Improve this Doc View Source GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) Returns all suffixes for the provided text from the node down the ISuffixStructureNode<TEdge, TNode> , up to leaves. Declaration public static IEnumerable<IEnumerable<char>> GetAllSuffixesFor<TEdge, TNode>(this TNode node, TextWithTerminator text) where TEdge : ISuffixStructureEdge<TEdge, TNode> where TNode : ISuffixStructureNode<TEdge, TNode> Parameters Type Name Description TNode node The node, to start the structure traversal from. TextWithTerminator text The text with terminator, whose suffixes have to be extracted. Returns Type Description IEnumerable < IEnumerable < System.Char >> A sequence of IValueEnumerable<T> , each one being a suffix. Type Parameters Name Description TEdge TNode"
  },
  "api/MoreStructures.SuffixStructures.SuffixStructureTreePathExtensions.html": {
    "href": "api/MoreStructures.SuffixStructures.SuffixStructureTreePathExtensions.html",
    "title": "Class SuffixStructureTreePathExtensions",
    "keywords": "Class SuffixStructureTreePathExtensions Extension methods for all TreePath<TEdge, TNode> used in ISuffixStructureNode<TEdge, TNode> structures. Inheritance System.Object SuffixStructureTreePathExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixStructures Assembly : MoreStructures.dll Syntax public static class SuffixStructureTreePathExtensions Methods | Improve this Doc View Source ContainsIndex<TEdge, TNode>(TreePath<TEdge, TNode>, Int32) Whether the provided path includes at least once, on any node of the path, the provided index . Declaration public static bool ContainsIndex<TEdge, TNode>(this TreePath<TEdge, TNode> path, int index) where TEdge : ISuffixStructureEdge<TEdge, TNode> where TNode : ISuffixStructureNode<TEdge, TNode> Parameters Type Name Description TreePath <TEdge, TNode> path The path to walk, looking for index . System.Int32 index The index of the char of the text, to look for. Must be non-negative. Returns Type Description System.Boolean A boolean. Type Parameters Name Description TEdge TNode | Improve this Doc View Source ContainsIndexesNonBiggerThan<TEdge, TNode>(TreePath<TEdge, TNode>, Int32) Whether the provided path has at least a node starting at a index lower or equal than the provided index . Declaration public static bool ContainsIndexesNonBiggerThan<TEdge, TNode>(this TreePath<TEdge, TNode> path, int index) where TEdge : ISuffixStructureEdge<TEdge, TNode> where TNode : ISuffixStructureNode<TEdge, TNode> Parameters Type Name Description TreePath <TEdge, TNode> path The path to walk, looking for index . System.Int32 index The index of the char of the text, to look for. Must be non-negative. Returns Type Description System.Boolean A boolean. Type Parameters Name Description TEdge TNode | Improve this Doc View Source IsSuffixOf<TEdge, TNode>(TreePath<TEdge, TNode>, TextWithTerminator) Whether this path identifies a suffix of the provided text. Declaration public static bool IsSuffixOf<TEdge, TNode>(this TreePath<TEdge, TNode> path, TextWithTerminator text) where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode>, TextWithTerminator.ISelector where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Parameters Type Name Description TreePath <TEdge, TNode> path The path, identifying a segment of the provided text. TextWithTerminator text The text, including the terminator character. Returns Type Description System.Boolean True if the segment of text is also a suffix the text. Type Parameters Name Description TEdge TNode | Improve this Doc View Source SuffixFor<TEdge, TNode>(TreePath<TEdge, TNode>, TextWithTerminator) Calculate the suffix corresponding to this path on the provided terminator-including text. Declaration public static IValueEnumerable<char> SuffixFor<TEdge, TNode>(this TreePath<TEdge, TNode> path, TextWithTerminator text) where TEdge : IRecImmDictIndexedTreeEdge<TEdge, TNode>, TextWithTerminator.ISelector where TNode : IRecImmDictIndexedTreeNode<TEdge, TNode> Parameters Type Name Description TreePath <TEdge, TNode> path The path to traverse to build the suffix. TextWithTerminator text The text, including the terminator character. Returns Type Description IValueEnumerable < System.Char > A IValueEnumerable<T> sequence of System.Char containing the suffix. Type Parameters Name Description TEdge TNode"
  },
  "api/MoreStructures.SuffixTrees.Builders.html": {
    "href": "api/MoreStructures.SuffixTrees.Builders.html",
    "title": "Namespace MoreStructures.SuffixTrees.Builders",
    "keywords": "Namespace MoreStructures.SuffixTrees.Builders Classes NaivePartiallyRecursiveSuffixTreeBuilder Builds objects, such as edges and nodes, for SuffixTreeNode structures. SuffixAndLcpArraysBasedSuffixTreeBuilder A IBuilder<TEdge, TNode> implementation of SuffixTreeNode structures, using the MoreStructures.SuffixArrays.SuffixArray and the MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray of the full text, to build the tree efficiently. UkkonenSuffixTreeBuilder Builds objects, such as edges and nodes, for SuffixTreeNode structures, using the Ukkonen algorithm."
  },
  "api/MoreStructures.SuffixTrees.Builders.NaivePartiallyRecursiveSuffixTreeBuilder.html": {
    "href": "api/MoreStructures.SuffixTrees.Builders.NaivePartiallyRecursiveSuffixTreeBuilder.html",
    "title": "Class NaivePartiallyRecursiveSuffixTreeBuilder",
    "keywords": "Class NaivePartiallyRecursiveSuffixTreeBuilder Builds objects, such as edges and nodes, for SuffixTreeNode structures. Inheritance System.Object NaivePartiallyRecursiveSuffixTreeBuilder Implements IBuilder < SuffixTreeEdge , SuffixTreeNode > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixTrees.Builders Assembly : MoreStructures.dll Syntax public class NaivePartiallyRecursiveSuffixTreeBuilder : IBuilder<SuffixTreeEdge, SuffixTreeNode> Remarks ADVANTAGES AND DISADVANTAGES - Implemented as an iteration of recursive visit of the tree being built, with as many iterations as the number of suffixes of the input (where the longest suffix is the text itself) and one level of recursion per char of each suffix. - Limited by call stack depth and usable with input text of a \"reasonable\" length (i.e. string having a length < ~1K chars). ALGORITHM - For each suffix S of the input T, start from the root node N of the tree, initialized as a mutable tree made of a simple leaf. - Compare the first char of S with the first char of each of the edges coming from N. - If there is no edge e such that label(e)[0] == S[0] , it means that there is no descendant of N sharing a path with S. So, create a new leaf under N, attached by an edge with a label equal to S. - Otherwise, it means that there is a path to be shared between the new leaf and at least one of the descendants of N. - In this case, compare the current suffix and the label of such edge e, for the LCP. - If the prefix in common is shorter than the length of the label of the edge e, create an intermediate node, push down the child pointed by the edge in the current node and add a new node for the reminder of the suffix (up to next terminator) as second child of the intermediate. - Otherwise, eat prefixLength chars from the edge, move to the child pointed by the edge entirely matching the beginning of the current suffix and repeat the same operation. - Finally, after all iterations have been executed and all suffixes of the text have been included in the mutable tree, build the final SuffixTreeNode structure from the mutable tree, using a MoreStructures.MutableTrees.Conversions.FullyIterativeConversion . COMPLEXITY - The generation of the full text, done by GenerateFullText(TextWithTerminator[]) , is a O(n) operation, where n is the sum of the length of each TextWithTerminator in the input (terminators included). - The initial tree, just a root-leaf, is created in constant time. - The top level loop is executed n times, once per char of the full text. - Finding the edge with the same first char is O(avgEdges), where avgEdges is the average number of edges coming out of a node of the tree. This operation is done for all cases (leaf creation alone or leaf + intermediate node). - Over all the n nodes of the tree, taking into account the worst case where avgEdges is O(n), Time Complexity would become O(n^2). However, the total number of edges in a tree is O(n), so the overall cost of these operations for the entire tree is O(n), and not O(n^2). - Finding the LCP between the suffix and the label of the current edge are O(n) operations, since the length of a generic suffix of the text is O(n) and they require iterating over all the chars. - Such operations are only done when an intermediate node is required. However, in the worst case there are as many intermediate as leaves in the tree (i.e. each iteration adds an intermediate node and a leaf). Therefore, the number of intermediate nodes is O(n), and the two O(n) operations above are to be repeated O(n) times. - Final step is building the final tree from the mutable tree, which requires the traversal of the O(n) nodes of the tree. MoreStructures.MutableTrees.Conversions.FullyIterativeConversion does that in O(n) time and space, via a stack and a precomputed data structure to find the number of terminators per edge in O(1) time. - In conclusion, Time Complexity = O(n^2) and Space Complexity = O(n) where n = length of the text to match. - Compared to tries, trees are more compact due to edge coalescing and edge label compression (i.e. edge strings stored as pair (start, length), rather than as a substring of length chars). Each recursion add a leaf and at most one intermediate node, so Space Complexity ~ 2 * n = O(n). Methods | Improve this Doc View Source BuildTree(TextWithTerminator[]) Declaration public SuffixTreeNode BuildTree(params TextWithTerminator[] texts) Parameters Type Name Description TextWithTerminator [] texts Returns Type Description SuffixTreeNode Remarks Implements IBuilder<TEdge, TNode> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) BuilderExtensions.BuildTree<TEdge, TNode>(IBuilder<TEdge, TNode>, String)"
  },
  "api/MoreStructures.SuffixTrees.Builders.SuffixAndLcpArraysBasedSuffixTreeBuilder.html": {
    "href": "api/MoreStructures.SuffixTrees.Builders.SuffixAndLcpArraysBasedSuffixTreeBuilder.html",
    "title": "Class SuffixAndLcpArraysBasedSuffixTreeBuilder",
    "keywords": "Class SuffixAndLcpArraysBasedSuffixTreeBuilder A IBuilder<TEdge, TNode> implementation of SuffixTreeNode structures, using the MoreStructures.SuffixArrays.SuffixArray and the MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray of the full text, to build the tree efficiently. Inheritance System.Object SuffixAndLcpArraysBasedSuffixTreeBuilder Implements IBuilder < SuffixTreeEdge , SuffixTreeNode > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixTrees.Builders Assembly : MoreStructures.dll Syntax public class SuffixAndLcpArraysBasedSuffixTreeBuilder : IBuilder<SuffixTreeEdge, SuffixTreeNode> Remarks ADVANTAGES AND DISADVANTAGES - Like NaivePartiallyRecursiveSuffixTreeBuilder and UkkonenSuffixTreeBuilder , it builds the tree one suffix of the text at a time, adding at least a leaf and potentially an intermediate node at every iteration. - Unlike them, the suffixes are not added to the tree in the order in which they appear in the text, i.e. they are not processed from the longest to the shortest, rather from the smallest to the biggest in lexicographic ascending order. - It also requires the construction of the MoreStructures.SuffixArrays.SuffixArray and the MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray of the input, whereas the naive and the Ukkonen implementations don't require any auxiliary structure. - Compared to the naive implementation, it has better runtime, even including the cost of building auxiliary structures: all-round performance is less than the quadratic performance of the naive approach, but worse than the linear performance of the Ukkonen algorithm. ALGORITHM - First, build full text, from the provided TextWithTerminator instances, and the corresponding MoreStructures.SuffixArrays.SuffixArray SA and MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray LCPA, which are both fully enumerated in order to be able to direct access them by index. - Then, build the initial mutable tree: just the root node with a single leaf linked by an edge labelled with the 1st suffix in the MoreStructures.SuffixArrays.SuffixArray : SA[0] . - This represents the initial state of the mutable tree, which will be modified iteration by iteration going through the Suffix Array from the 2nd to the last suffix (in lexicographic ascending order). - The item of the LCP Array in position i - 1, gives the LCP of such suffix with the previous suffix: LCPA[i - 1] = LCP(SA[i - 1], SA[i]) . Such LCP value is compared with the LCP value calculated at the previous iteration. - Different insertion strategies are applied, depending on the result of the comparison. At each iteration the reference to the last inserted leaf and to the previous LCP value are kept. - Case 1 : if the current LCP is smaller than the previous, the root-to-leaf path of the leaf about to be added shares a shorter path with the previous leaf. So move up in the tree from the last inserted leaf, up until the first node which makes current LCP value non smaller than the previous LCP value. Then check whether it's fallbacking to Case 2 or 3. - Case 2 : if the current LCP is the same as the previous, the root-to-leaf path of the leaf about to be added shares exactly the same path with the previous leaf. Therefore the new leaf can be attached directly to the parent of the previous leaf, which becomes a sibling of the new leaf. No new intermediate node. - Case 3 : if the current LCP is bigger than the previous, a part of the previous edge is in common between the previous leaf and the leaf about to be created in this iteration. Therefore, build new intermediate, detach old edge going to previous leaf, attach new intermediate edge. - Finally, after all iterations have been executed and all suffixes of the text have been included in the mutable tree, build the final SuffixTreeNode structure from the mutable tree, using a MoreStructures.MutableTrees.Conversions.FullyIterativeConversion . COMPLEXITY - The complexity of building the MoreStructures.SuffixArrays.SuffixArray and the MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray , via the provided SuffixAndLcpArraysBuilder is not included in this cost analysis. This has to be taken into account when comparing this implementation of IBuilder<TEdge, TNode> of SuffixTreeNode structures with other implementations, such as NaivePartiallyRecursiveSuffixTreeBuilder or UkkonenSuffixTreeBuilder . - Building the initial mutable tree requires building two nodes and an edge, which can both be done in constant time. - Then, n - 1 iterations are performed, where n is the length of the input, executing optionally Case 1 and then either Case 2 or 3. - Cases 2 and 3 perform the insertion of a leaf and potentially of an intermediate node, both O(1) operations. Case 1 may seem an O(n) operation. However, due to LCP Array property, moving up in the tree will happen at most once per iteration. - Final step is building the final tree from the mutable tree, which requires the traversal of the O(n) nodes of the tree. MoreStructures.MutableTrees.Conversions.FullyIterativeConversion does that in O(n) time and space, via a stack and a precomputed data structure to find the number of terminators per edge in O(1) time. - In conclusion, both Time and Space Complexity are O(n). Constructors | Improve this Doc View Source SuffixAndLcpArraysBasedSuffixTreeBuilder(Func<TextWithTerminator, (SuffixArray, LcpArray)>) Declaration public SuffixAndLcpArraysBasedSuffixTreeBuilder(Func<TextWithTerminator, (SuffixArray, LcpArray)> suffixAndLcpArraysBuilder) Parameters Type Name Description Func < TextWithTerminator , System.ValueTuple < MoreStructures.SuffixArrays.SuffixArray , MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray >> suffixAndLcpArraysBuilder Remarks Properties | Improve this Doc View Source SuffixAndLcpArraysBuilder The builder to be used to construct the MoreStructures.SuffixArrays.SuffixArray and the MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray of the full text, both required by this algorithm to build the SuffixTreeNode structure. Declaration public Func<TextWithTerminator, (SuffixArray, LcpArray)> SuffixAndLcpArraysBuilder { get; } Property Value Type Description Func < TextWithTerminator , System.ValueTuple < MoreStructures.SuffixArrays.SuffixArray , MoreStructures.SuffixArrays.LongestCommonPrefix.LcpArray >> Methods | Improve this Doc View Source BuildTree(TextWithTerminator[]) Declaration public SuffixTreeNode BuildTree(params TextWithTerminator[] texts) Parameters Type Name Description TextWithTerminator [] texts Returns Type Description SuffixTreeNode Remarks Implements IBuilder<TEdge, TNode> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) BuilderExtensions.BuildTree<TEdge, TNode>(IBuilder<TEdge, TNode>, String)"
  },
  "api/MoreStructures.SuffixTrees.Builders.UkkonenSuffixTreeBuilder.html": {
    "href": "api/MoreStructures.SuffixTrees.Builders.UkkonenSuffixTreeBuilder.html",
    "title": "Class UkkonenSuffixTreeBuilder",
    "keywords": "Class UkkonenSuffixTreeBuilder Builds objects, such as edges and nodes, for SuffixTreeNode structures, using the Ukkonen algorithm. Inheritance System.Object UkkonenSuffixTreeBuilder Implements IBuilder < SuffixTreeEdge , SuffixTreeNode > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixTrees.Builders Assembly : MoreStructures.dll Syntax public class UkkonenSuffixTreeBuilder : IBuilder<SuffixTreeEdge, SuffixTreeNode> Remarks Iterative implementation of the Ukkonen algorithm: see https://en.wikipedia.org/wiki/Ukkonen%27s_algorithm for an introduction and https://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf for the original paper. ALGORITHM OPTIMIZATIONS The algorithm applies some optimizations to achieve linear complexity: - Edge Labels compression : strings on edges are stored as (start, end) indexes. This makes the space used by a single edge constant, i.e. O(1), because it always consists of two integers, regardless of how many chars of the text it represents. - Global End : all leafs have a dynamic end index, autoincremented every new phase. This makes the time used to apply Rule 1 Extension constant, i.e. O(1), because incrementing the global end also increments all leaf implicitely. - Suffix Links : all internal nodes point to another internal node sharing the suffix. This makes more efficient traversal, because storing and jumping the suffix link when needed means traversal doesn't have to be done again. - Terminators Index Map : a function is used, mapping each index i of the full input text (consolidated TextWithTerminator including all TextWithTerminator instances passed in the input) to the index of the next terminator appearing in the full text not before i. Such function is used to perform edge trimming of the mutable tree structure built by the Ukkonen algorithm in linear time. ALGORITHM The algorithm is structured in phases, as many as the number of chars in the text. At the beginning of a new phase, both the number of remaining suffixes to take care of, and the global end pointer are both increased by 1. Each phase is composed of at least 1 iteration, each one taking care of remaining suffixes. At the beginning USECASES Not limited by call stack depth. Convenient with long input text (i.e. string having a length < ~1K chars). COMPLEXITY - The Time Complexity of the Ukkonen algorithm, building the mutable tree from the input texts, is O(t). Space Complexity is O(2 * t) where t = length of the text to match. - While there are as many phases as number of chars in text (t), and there can be multiple iterations per phase (as many as the number of remaining suffixes to process), the complexity is still linear, ~ 2t. - Each node of the resulting mutable tree (there are O(n) of them, and at most 2 * n), is processed by the mutable tree conversion method at most twice: once for leaves and twice for intermediate nodes, which are re-pushed onto the stack before its children, so that they can be processed after all their children have already been converted. - Each stack frame processing by the mutable tree conversion method performs constant-time operations only: SuffixTreeNode and SuffixTreeEdge instances creation, children dictionary instantiation and edge trimming (trimming the label of edges in generalized Suffix Trees, to the first terminator appearing in the label, when multiple are present - i.e. when the label spans multiple concatenated texts). - Edge trimming is a constant-time operation once the cost of calculating the Terminators Index Map is paid, which is a linear cost in time and space (linear in t). - Therefore, mutable tree conversion, and the overall algorithm, is linear in time and space over t. Methods | Improve this Doc View Source BuildTree(TextWithTerminator[]) Declaration public SuffixTreeNode BuildTree(params TextWithTerminator[] texts) Parameters Type Name Description TextWithTerminator [] texts Returns Type Description SuffixTreeNode Remarks Implements IBuilder<TEdge, TNode> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) BuilderExtensions.BuildTree<TEdge, TNode>(IBuilder<TEdge, TNode>, String)"
  },
  "api/MoreStructures.SuffixTrees.html": {
    "href": "api/MoreStructures.SuffixTrees.html",
    "title": "Namespace MoreStructures.SuffixTrees",
    "keywords": "Namespace MoreStructures.SuffixTrees Classes SuffixTreeEdge The index key of the collection of children of a SuffixTreeNode , which identifies a non-empty substring in text used as a selector to navigate the SuffixTreeNode in text pattern matching. SuffixTreeNode An immutable node of an immutable Suffix Tree, recursively pointing to its children nodes via SuffixTreeEdge instances, associated with selector strings. SuffixTreeNode.Intermediate Builds an intermediate node, i.e. a node with children and their corresponding incoming edges. SuffixTreeNode.Leaf Builds a leaf, i.e. a node with no children and the start index of the suffix in the text."
  },
  "api/MoreStructures.SuffixTrees.SuffixTreeEdge.html": {
    "href": "api/MoreStructures.SuffixTrees.SuffixTreeEdge.html",
    "title": "Class SuffixTreeEdge",
    "keywords": "Class SuffixTreeEdge The index key of the collection of children of a SuffixTreeNode , which identifies a non-empty substring in text used as a selector to navigate the SuffixTreeNode in text pattern matching. Inheritance System.Object SuffixTreeEdge SuffixTrieEdge Implements ISuffixStructureEdge < SuffixTreeEdge , SuffixTreeNode > TextWithTerminator.ISelector IRecImmDictIndexedTreeEdge < SuffixTreeEdge , SuffixTreeNode > IComparable < SuffixTreeEdge > System.IEquatable < SuffixTreeEdge > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.SuffixTrees Assembly : MoreStructures.dll Syntax public class SuffixTreeEdge : ISuffixStructureEdge<SuffixTreeEdge, SuffixTreeNode>, TextWithTerminator.ISelector, IRecImmDictIndexedTreeEdge<SuffixTreeEdge, SuffixTreeNode>, IEquatable<SuffixTreeEdge> Remarks Supports , by Start and Length , in this order. Constructors | Improve this Doc View Source SuffixTreeEdge(Int32, Int32) The index key of the collection of children of a SuffixTreeNode , which identifies a non-empty substring in text used as a selector to navigate the SuffixTreeNode in text pattern matching. Declaration public SuffixTreeEdge(int Start, int Length) Parameters Type Name Description System.Int32 Start System.Int32 Length Remarks Supports , by Start and Length , in this order. Properties | Improve this Doc View Source Length The length of the edge string. Declaration public int Length { get; set; } Property Value Type Description System.Int32 | Improve this Doc View Source Start The index of the first character of the edge string in the text. Declaration public int Start { get; set; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source CompareTo(SuffixTreeEdge) Comparison is done by Start first, then Length : lower is smaller, higher is bigger. Declaration public int CompareTo(SuffixTreeEdge other) Parameters Type Name Description SuffixTreeEdge other Returns Type Description System.Int32 | Improve this Doc View Source Of(TextWithTerminator) Extract the substring identified by this selector, out of the provided TextWithTerminator . Declaration public virtual string Of(TextWithTerminator text) Parameters Type Name Description TextWithTerminator text The text with terminator, to extract a substring of. Returns Type Description System.String A substring, whose length depends on the selector. | Improve this Doc View Source OfRotated(RotatedTextWithTerminator) Extract the substring identified by this selector, out of the provided RotatedTextWithTerminator . Declaration public virtual string OfRotated(RotatedTextWithTerminator text) Parameters Type Name Description RotatedTextWithTerminator text The text with terminator, to extract a substring of. Returns Type Description System.String A substring, whose length depends on the selector. | Improve this Doc View Source ToString() Generates a string in the form \"( Start , Length )\". Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Implements ISuffixStructureEdge<TEdge, TNode> TextWithTerminator.ISelector IRecImmDictIndexedTreeEdge<TEdge, TNode> IComparable<> System.IEquatable<T> Extension Methods SuffixStructureEdgeExtensions.IsAdjacentTo<TEdge, TNode>(ISuffixStructureEdge<TEdge, TNode>, TEdge, AdjacencyOrders) SuffixStructureEdgeExtensions.ContainsIndex<TEdge, TNode>(ISuffixStructureEdge<TEdge, TNode>, Int32) SuffixStructureEdgeExtensions.ContainsIndexesNonBiggerThan<TEdge, TNode>(ISuffixStructureEdge<TEdge, TNode>, Int32) SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixTrees.SuffixTreeNode.html": {
    "href": "api/MoreStructures.SuffixTrees.SuffixTreeNode.html",
    "title": "Class SuffixTreeNode",
    "keywords": "Class SuffixTreeNode An immutable node of an immutable Suffix Tree, recursively pointing to its children nodes via SuffixTreeEdge instances, associated with selector strings. Inheritance System.Object SuffixTreeNode SuffixTreeNode.Intermediate SuffixTreeNode.Leaf Implements ISuffixStructureNode < SuffixTreeEdge , SuffixTreeNode > IRecImmDictIndexedTreeNode < SuffixTreeEdge , SuffixTreeNode > System.IEquatable < SuffixTreeNode > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.SuffixTrees Assembly : MoreStructures.dll Syntax public abstract class SuffixTreeNode : ISuffixStructureNode<SuffixTreeEdge, SuffixTreeNode>, IRecImmDictIndexedTreeNode<SuffixTreeEdge, SuffixTreeNode>, IEquatable<SuffixTreeNode> Remarks ADVANTAGES AND DISADVANTAGES Suffix Trees are more space-efficient than Suffix Tries due to the reduced number of SuffixTreeEdge and their SuffixTreeNode , compare to the corresponding SuffixTrieEdge and their SuffixTrieNode , due to entire paths of single chains of chars in Suffix Tries being coalesced into a single selector string, which is stored on the edge with path label compression, i.e. using two fixed sized numbers ( Start and Length ) instead of a variable-length string of characters. Furthermore, suffix trees, unlike suffix tries, can be constructed in linear time, for example via the UkkonenSuffixTreeBuilder . IMMUTABILITY Immutability is guaranteed by using ValueReadOnlyCollection<T> . Constructors | Improve this Doc View Source SuffixTreeNode(IDictionary<SuffixTreeEdge, SuffixTreeNode>, Nullable<Int32>) An immutable node of an immutable Suffix Tree, recursively pointing to its children nodes via SuffixTreeEdge instances, associated with selector strings. Declaration protected SuffixTreeNode(IDictionary<SuffixTreeEdge, SuffixTreeNode> Children, int? Start) Parameters Type Name Description IDictionary < SuffixTreeEdge , SuffixTreeNode > Children The collection of children for the node, indexed by string edges. System.Nullable < System.Int32 > Start Remarks ADVANTAGES AND DISADVANTAGES Suffix Trees are more space-efficient than Suffix Tries due to the reduced number of SuffixTreeEdge and their SuffixTreeNode , compare to the corresponding SuffixTrieEdge and their SuffixTrieNode , due to entire paths of single chains of chars in Suffix Tries being coalesced into a single selector string, which is stored on the edge with path label compression, i.e. using two fixed sized numbers ( Start and Length ) instead of a variable-length string of characters. Furthermore, suffix trees, unlike suffix tries, can be constructed in linear time, for example via the UkkonenSuffixTreeBuilder . IMMUTABILITY Immutability is guaranteed by using ValueReadOnlyCollection<T> . Properties | Improve this Doc View Source Children A readonly view of the children private collection of this node. Empty for leaves. Declaration public IDictionary<SuffixTreeEdge, SuffixTreeNode> Children { get; } Property Value Type Description IDictionary < SuffixTreeEdge , SuffixTreeNode > | Improve this Doc View Source Item[SuffixTreeEdge] Indexes into the children of this node, by edge. Declaration public SuffixTreeNode this[SuffixTreeEdge edge] { get; } Parameters Type Name Description SuffixTreeEdge edge Property Value Type Description SuffixTreeNode | Improve this Doc View Source Start The index of the character, the path from the root leading to this leaf starts with. Non-null for leaves only. Declaration public int? Start { get; } Property Value Type Description System.Nullable < System.Int32 > Methods | Improve this Doc View Source IsEquivalentTo(SuffixTreeNode, TextWithTerminator[]) Determines whether this SuffixTreeNode structure is equivalent to the provided other structure, w.r.t. the provided texts . Declaration public abstract bool IsEquivalentTo(SuffixTreeNode other, params TextWithTerminator[] texts) Parameters Type Name Description SuffixTreeNode other The other tree, to compare this tree against. TextWithTerminator [] texts The text, based on which to evaluate the tree equivalence. Returns Type Description System.Boolean True if the two trees are equivalent for the provided text, false otherwise. Remarks DEFINITION The definition of SuffixTreeNode structures equivalence depends on (a list of) TextWithTerminator : two trees can be equivalent for some texts, and not equivalent for others. This is because of the Edge Compression technique used by SuffixTreeEdge , to store edges in O(1) space, instead of O(n). Moreover, equivalence is based on the equivalence of edges and of the specific type of node. - Two SuffixTreeEdge E1 and E2 are equivalent w.r.t. a TextWithTerminator T, if the string identified by each edge is the same: T[E1] == T[E2] . - Two SuffixTreeNode.Leaf L1 and L2 are equivalent if their LeafStart is the same: L1.LeafStart == L2.LeafStart . - Two SuffixTreeNode.Intermediate I1 and I2 are equivalent if there is a 1-to-1 correspondence between children edges and child nodes pointed by such edges are equivalent: for each edge e1 of I1.Children there exists exactly one equivalent edge e2 of I2.Children and I1.Children[e1] is equivalent to I2.Children[e2] w.r.t. T . COMPLEXITY - Checking for edges equivalence is a O(n) operation, where n is the number of nodes in the tree, since it requires decompressing the labels of each of the edges being compare and compare for equality the two resulting O(n) strings. - Checking for leaves equivalence is a O(1) operation, since it only requires comparing LeafStart , which has constant size. - Checking for intermediate nodes equivalence is a O(n) operation, amortized cost over the total number of edges in the tree, since there are O(n) edges in total in the tree, an edge is visited multiple times but always in the context of a single node, and the node equivalence check requires looking for the equivalent edge. - In conclusion Time Complexity is O(n^2) and Space Complexity is O(n). | Improve this Doc View Source ToString() Uses a IStringifier<TEdge, TNode> to generate the string which show the node and its underlying structure. Declaration public sealed override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Remarks Sealed to prevent compiler from superceding ToString() in derived record. Implements ISuffixStructureNode<TEdge, TNode> IRecImmDictIndexedTreeNode<TEdge, TNode> System.IEquatable<T> Extension Methods RecImmDictIndexedTreeNodeExtensions.IsLeaf<TEdge, TNode>(IRecImmDictIndexedTreeNode<TEdge, TNode>) SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) Matcher.Match<TEdge, TNode>(ISuffixStructureNode<TEdge, TNode>, TextWithTerminator, String)"
  },
  "api/MoreStructures.SuffixTrees.SuffixTreeNode.Intermediate.html": {
    "href": "api/MoreStructures.SuffixTrees.SuffixTreeNode.Intermediate.html",
    "title": "Class SuffixTreeNode.Intermediate",
    "keywords": "Class SuffixTreeNode.Intermediate Builds an intermediate node, i.e. a node with children and their corresponding incoming edges. Inheritance System.Object SuffixTreeNode SuffixTreeNode.Intermediate Implements ISuffixStructureNode < SuffixTreeEdge , SuffixTreeNode > IRecImmDictIndexedTreeNode < SuffixTreeEdge , SuffixTreeNode > System.IEquatable < SuffixTreeNode > System.IEquatable < SuffixTreeNode.Intermediate > Inherited Members SuffixTreeNode.Children SuffixTreeNode.Start SuffixTreeNode.Item[SuffixTreeEdge] SuffixTreeNode.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.SuffixTrees Assembly : MoreStructures.dll Syntax public class Intermediate : SuffixTreeNode, ISuffixStructureNode<SuffixTreeEdge, SuffixTreeNode>, IRecImmDictIndexedTreeNode<SuffixTreeEdge, SuffixTreeNode>, IEquatable<SuffixTreeNode>, IEquatable<SuffixTreeNode.Intermediate> Constructors | Improve this Doc View Source Intermediate(IDictionary<SuffixTreeEdge, SuffixTreeNode>) Builds an intermediate node, i.e. a node with children and their corresponding incoming edges. Declaration public Intermediate(IDictionary<SuffixTreeEdge, SuffixTreeNode> Children) Parameters Type Name Description IDictionary < SuffixTreeEdge , SuffixTreeNode > Children Methods | Improve this Doc View Source IsEquivalentTo(SuffixTreeNode, TextWithTerminator[]) Determines whether this SuffixTreeNode structure is equivalent to the provided other structure, w.r.t. the provided texts . Declaration public override bool IsEquivalentTo(SuffixTreeNode other, params TextWithTerminator[] texts) Parameters Type Name Description SuffixTreeNode other The other tree, to compare this tree against. TextWithTerminator [] texts The text, based on which to evaluate the tree equivalence. Returns Type Description System.Boolean True if the two trees are equivalent for the provided text, false otherwise. Overrides SuffixTreeNode.IsEquivalentTo(SuffixTreeNode, TextWithTerminator[]) Remarks DEFINITION The definition of SuffixTreeNode structures equivalence depends on (a list of) TextWithTerminator : two trees can be equivalent for some texts, and not equivalent for others. This is because of the Edge Compression technique used by SuffixTreeEdge , to store edges in O(1) space, instead of O(n). Moreover, equivalence is based on the equivalence of edges and of the specific type of node. - Two SuffixTreeEdge E1 and E2 are equivalent w.r.t. a TextWithTerminator T, if the string identified by each edge is the same: T[E1] == T[E2] . - Two SuffixTreeNode.Leaf L1 and L2 are equivalent if their LeafStart is the same: L1.LeafStart == L2.LeafStart . - Two SuffixTreeNode.Intermediate I1 and I2 are equivalent if there is a 1-to-1 correspondence between children edges and child nodes pointed by such edges are equivalent: for each edge e1 of I1.Children there exists exactly one equivalent edge e2 of I2.Children and I1.Children[e1] is equivalent to I2.Children[e2] w.r.t. T . COMPLEXITY - Checking for edges equivalence is a O(n) operation, where n is the number of nodes in the tree, since it requires decompressing the labels of each of the edges being compare and compare for equality the two resulting O(n) strings. - Checking for leaves equivalence is a O(1) operation, since it only requires comparing LeafStart , which has constant size. - Checking for intermediate nodes equivalence is a O(n) operation, amortized cost over the total number of edges in the tree, since there are O(n) edges in total in the tree, an edge is visited multiple times but always in the context of a single node, and the node equivalence check requires looking for the equivalent edge. - In conclusion Time Complexity is O(n^2) and Space Complexity is O(n). Implements ISuffixStructureNode<TEdge, TNode> IRecImmDictIndexedTreeNode<TEdge, TNode> System.IEquatable<T> System.IEquatable<T> Extension Methods RecImmDictIndexedTreeNodeExtensions.IsLeaf<TEdge, TNode>(IRecImmDictIndexedTreeNode<TEdge, TNode>) SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) Matcher.Match<TEdge, TNode>(ISuffixStructureNode<TEdge, TNode>, TextWithTerminator, String)"
  },
  "api/MoreStructures.SuffixTrees.SuffixTreeNode.Leaf.html": {
    "href": "api/MoreStructures.SuffixTrees.SuffixTreeNode.Leaf.html",
    "title": "Class SuffixTreeNode.Leaf",
    "keywords": "Class SuffixTreeNode.Leaf Builds a leaf, i.e. a node with no children and the start index of the suffix in the text. Inheritance System.Object SuffixTreeNode SuffixTreeNode.Leaf Implements ISuffixStructureNode < SuffixTreeEdge , SuffixTreeNode > IRecImmDictIndexedTreeNode < SuffixTreeEdge , SuffixTreeNode > System.IEquatable < SuffixTreeNode > System.IEquatable < SuffixTreeNode.Leaf > Inherited Members SuffixTreeNode.Children SuffixTreeNode.Start SuffixTreeNode.Item[SuffixTreeEdge] SuffixTreeNode.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.SuffixTrees Assembly : MoreStructures.dll Syntax public class Leaf : SuffixTreeNode, ISuffixStructureNode<SuffixTreeEdge, SuffixTreeNode>, IRecImmDictIndexedTreeNode<SuffixTreeEdge, SuffixTreeNode>, IEquatable<SuffixTreeNode>, IEquatable<SuffixTreeNode.Leaf> Constructors | Improve this Doc View Source Leaf(Int32) Builds a leaf, i.e. a node with no children and the start index of the suffix in the text. Declaration public Leaf(int LeafStart) Parameters Type Name Description System.Int32 LeafStart Properties | Improve this Doc View Source LeafStart Declaration public int LeafStart { get; set; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source IsEquivalentTo(SuffixTreeNode, TextWithTerminator[]) Determines whether this SuffixTreeNode structure is equivalent to the provided other structure, w.r.t. the provided texts . Declaration public override bool IsEquivalentTo(SuffixTreeNode other, params TextWithTerminator[] texts) Parameters Type Name Description SuffixTreeNode other The other tree, to compare this tree against. TextWithTerminator [] texts The text, based on which to evaluate the tree equivalence. Returns Type Description System.Boolean True if the two trees are equivalent for the provided text, false otherwise. Overrides SuffixTreeNode.IsEquivalentTo(SuffixTreeNode, TextWithTerminator[]) Remarks DEFINITION The definition of SuffixTreeNode structures equivalence depends on (a list of) TextWithTerminator : two trees can be equivalent for some texts, and not equivalent for others. This is because of the Edge Compression technique used by SuffixTreeEdge , to store edges in O(1) space, instead of O(n). Moreover, equivalence is based on the equivalence of edges and of the specific type of node. - Two SuffixTreeEdge E1 and E2 are equivalent w.r.t. a TextWithTerminator T, if the string identified by each edge is the same: T[E1] == T[E2] . - Two SuffixTreeNode.Leaf L1 and L2 are equivalent if their LeafStart is the same: L1.LeafStart == L2.LeafStart . - Two SuffixTreeNode.Intermediate I1 and I2 are equivalent if there is a 1-to-1 correspondence between children edges and child nodes pointed by such edges are equivalent: for each edge e1 of I1.Children there exists exactly one equivalent edge e2 of I2.Children and I1.Children[e1] is equivalent to I2.Children[e2] w.r.t. T . COMPLEXITY - Checking for edges equivalence is a O(n) operation, where n is the number of nodes in the tree, since it requires decompressing the labels of each of the edges being compare and compare for equality the two resulting O(n) strings. - Checking for leaves equivalence is a O(1) operation, since it only requires comparing LeafStart , which has constant size. - Checking for intermediate nodes equivalence is a O(n) operation, amortized cost over the total number of edges in the tree, since there are O(n) edges in total in the tree, an edge is visited multiple times but always in the context of a single node, and the node equivalence check requires looking for the equivalent edge. - In conclusion Time Complexity is O(n^2) and Space Complexity is O(n). Implements ISuffixStructureNode<TEdge, TNode> IRecImmDictIndexedTreeNode<TEdge, TNode> System.IEquatable<T> System.IEquatable<T> Extension Methods RecImmDictIndexedTreeNodeExtensions.IsLeaf<TEdge, TNode>(IRecImmDictIndexedTreeNode<TEdge, TNode>) SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) Matcher.Match<TEdge, TNode>(ISuffixStructureNode<TEdge, TNode>, TextWithTerminator, String)"
  },
  "api/MoreStructures.SuffixTries.Builders.html": {
    "href": "api/MoreStructures.SuffixTries.Builders.html",
    "title": "Namespace MoreStructures.SuffixTries.Builders",
    "keywords": "Namespace MoreStructures.SuffixTries.Builders Classes NaivePartiallyRecursiveSuffixTrieBuilder Builds objects, such as edges and nodes, for SuffixTrieNode structures."
  },
  "api/MoreStructures.SuffixTries.Builders.NaivePartiallyRecursiveSuffixTrieBuilder.html": {
    "href": "api/MoreStructures.SuffixTries.Builders.NaivePartiallyRecursiveSuffixTrieBuilder.html",
    "title": "Class NaivePartiallyRecursiveSuffixTrieBuilder",
    "keywords": "Class NaivePartiallyRecursiveSuffixTrieBuilder Builds objects, such as edges and nodes, for SuffixTrieNode structures. Inheritance System.Object NaivePartiallyRecursiveSuffixTrieBuilder Implements IBuilder < SuffixTrieEdge , SuffixTrieNode > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.SuffixTries.Builders Assembly : MoreStructures.dll Syntax public class NaivePartiallyRecursiveSuffixTrieBuilder : IBuilder<SuffixTrieEdge, SuffixTrieNode> Remarks ALGORITHM Implemented iteratively, with one level of recursion per char of each suffix of the input TextWithTerminator (where the longest suffix is the text itself). ADVANTAGES AND DISADVANTAGES Limited by call stack depth and usable with input text of a \"reasonable\" length (i.e. string having a length < ~1K chars). COMPLEXITY - Time Complexity = O(t^2 * as) and Space Complexity = O(t^2) where t = length of the text to match and as = size of the alphabet of the text. - If the alphabet is of constant size, complexity is quadratic. Methods | Improve this Doc View Source BuildTree(TextWithTerminator[]) Declaration public SuffixTrieNode BuildTree(params TextWithTerminator[] texts) Parameters Type Name Description TextWithTerminator [] texts Returns Type Description SuffixTrieNode Remarks Implements IBuilder<TEdge, TNode> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) BuilderExtensions.BuildTree<TEdge, TNode>(IBuilder<TEdge, TNode>, String)"
  },
  "api/MoreStructures.SuffixTries.html": {
    "href": "api/MoreStructures.SuffixTries.html",
    "title": "Namespace MoreStructures.SuffixTries",
    "keywords": "Namespace MoreStructures.SuffixTries Classes SuffixTrieEdge The index key of the collection of children of a SuffixTrieNode , which identifies a single char in text, used as a selector to navigate the SuffixTrieNode in text pattern matching. SuffixTrieNode An immutable node of an immutable Suffix Trie, recursively pointing to its children nodes via SuffixTrieEdge instances, associated with selector characters. SuffixTrieNode.Intermediate Builds an intermediate node, i.e. a node with children and their corresponding incoming edges. SuffixTrieNode.Leaf Builds a leaf, i.e. a node with no children and the start index of the suffix in the text."
  },
  "api/MoreStructures.SuffixTries.SuffixTrieEdge.html": {
    "href": "api/MoreStructures.SuffixTries.SuffixTrieEdge.html",
    "title": "Class SuffixTrieEdge",
    "keywords": "Class SuffixTrieEdge The index key of the collection of children of a SuffixTrieNode , which identifies a single char in text, used as a selector to navigate the SuffixTrieNode in text pattern matching. Inheritance System.Object SuffixTreeEdge SuffixTrieEdge Implements ISuffixStructureEdge < SuffixTreeEdge , SuffixTreeNode > IRecImmDictIndexedTreeEdge < SuffixTreeEdge , SuffixTreeNode > IComparable < SuffixTreeEdge > System.IEquatable < SuffixTreeEdge > ISuffixStructureEdge < SuffixTrieEdge , SuffixTrieNode > TextWithTerminator.ISelector IRecImmDictIndexedTreeEdge < SuffixTrieEdge , SuffixTrieNode > IComparable < SuffixTrieEdge > System.IEquatable < SuffixTrieEdge > Inherited Members SuffixTreeEdge.Start SuffixTreeEdge.Length SuffixTreeEdge.CompareTo(SuffixTreeEdge) SuffixTreeEdge.Of(TextWithTerminator) SuffixTreeEdge.OfRotated(RotatedTextWithTerminator) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.SuffixTries Assembly : MoreStructures.dll Syntax public class SuffixTrieEdge : SuffixTreeEdge, ISuffixStructureEdge<SuffixTreeEdge, SuffixTreeNode>, IRecImmDictIndexedTreeEdge<SuffixTreeEdge, SuffixTreeNode>, IEquatable<SuffixTreeEdge>, ISuffixStructureEdge<SuffixTrieEdge, SuffixTrieNode>, TextWithTerminator.ISelector, IRecImmDictIndexedTreeEdge<SuffixTrieEdge, SuffixTrieNode>, IEquatable<SuffixTrieEdge> Remarks Supports , by Index . Constructors | Improve this Doc View Source SuffixTrieEdge(Int32) The index key of the collection of children of a SuffixTrieNode , which identifies a single char in text, used as a selector to navigate the SuffixTrieNode in text pattern matching. Declaration public SuffixTrieEdge(int Index) Parameters Type Name Description System.Int32 Index The index of the character in the text. Remarks Supports , by Index . Properties | Improve this Doc View Source Index Declaration public int Index { get; set; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source CompareTo(SuffixTrieEdge) Comparison is done by Index : lower is smaller, higher is bigger. Declaration public int CompareTo(SuffixTrieEdge other) Parameters Type Name Description SuffixTrieEdge other Returns Type Description System.Int32 | Improve this Doc View Source ToString() Generates a string in the form \"( Start )\". Length is not included as in this context it is always 1. Declaration public override string ToString() Returns Type Description System.String Overrides SuffixTreeEdge.ToString() Implements ISuffixStructureEdge<TEdge, TNode> IRecImmDictIndexedTreeEdge<TEdge, TNode> IComparable<> System.IEquatable<T> ISuffixStructureEdge<TEdge, TNode> TextWithTerminator.ISelector IRecImmDictIndexedTreeEdge<TEdge, TNode> IComparable<> System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.SuffixTries.SuffixTrieNode.html": {
    "href": "api/MoreStructures.SuffixTries.SuffixTrieNode.html",
    "title": "Class SuffixTrieNode",
    "keywords": "Class SuffixTrieNode An immutable node of an immutable Suffix Trie, recursively pointing to its children nodes via SuffixTrieEdge instances, associated with selector characters. Inheritance System.Object SuffixTrieNode SuffixTrieNode.Intermediate SuffixTrieNode.Leaf Implements ISuffixStructureNode < SuffixTrieEdge , SuffixTrieNode > IRecImmDictIndexedTreeNode < SuffixTrieEdge , SuffixTrieNode > System.IEquatable < SuffixTrieNode > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.SuffixTries Assembly : MoreStructures.dll Syntax public abstract class SuffixTrieNode : ISuffixStructureNode<SuffixTrieEdge, SuffixTrieNode>, IRecImmDictIndexedTreeNode<SuffixTrieEdge, SuffixTrieNode>, IEquatable<SuffixTrieNode> Remarks ADVANTAGES AND DISADVANTAGES Compare to suffix trees, suffix tries, although less performant and optimized on many operations, are simpler to build, navigate and understand. IMMUTABILITY Immutability is guaranteed by using ValueReadOnlyCollection<T> . Constructors | Improve this Doc View Source SuffixTrieNode(IDictionary<SuffixTrieEdge, SuffixTrieNode>, Nullable<Int32>) An immutable node of an immutable Suffix Trie, recursively pointing to its children nodes via SuffixTrieEdge instances, associated with selector characters. Declaration protected SuffixTrieNode(IDictionary<SuffixTrieEdge, SuffixTrieNode> Children, int? Start) Parameters Type Name Description IDictionary < SuffixTrieEdge , SuffixTrieNode > Children The collection of children for the node, indexed by single char edges. System.Nullable < System.Int32 > Start Remarks ADVANTAGES AND DISADVANTAGES Compare to suffix trees, suffix tries, although less performant and optimized on many operations, are simpler to build, navigate and understand. IMMUTABILITY Immutability is guaranteed by using ValueReadOnlyCollection<T> . Properties | Improve this Doc View Source Children A readonly view of the children private collection of this node. Empty for leaves. Declaration public IDictionary<SuffixTrieEdge, SuffixTrieNode> Children { get; } Property Value Type Description IDictionary < SuffixTrieEdge , SuffixTrieNode > | Improve this Doc View Source Item[SuffixTrieEdge] Indexes into the children of this node, by edge, which is a single char selector. Declaration public SuffixTrieNode this[SuffixTrieEdge edge] { get; } Parameters Type Name Description SuffixTrieEdge edge Property Value Type Description SuffixTrieNode | Improve this Doc View Source Start The index of the character, the path from the root leading to this leaf starts with. Non-null for leaves only. Declaration public int? Start { get; } Property Value Type Description System.Nullable < System.Int32 > Methods | Improve this Doc View Source ToString() Uses a IStringifier<TEdge, TNode> to generate the string which show the node and its underlying structure. Declaration public sealed override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Remarks Sealed to prevent compiler from superceding ToString() in derived record. Implements ISuffixStructureNode<TEdge, TNode> IRecImmDictIndexedTreeNode<TEdge, TNode> System.IEquatable<T> Extension Methods RecImmDictIndexedTreeNodeExtensions.IsLeaf<TEdge, TNode>(IRecImmDictIndexedTreeNode<TEdge, TNode>) SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) Matcher.Match<TEdge, TNode>(ISuffixStructureNode<TEdge, TNode>, TextWithTerminator, String)"
  },
  "api/MoreStructures.SuffixTries.SuffixTrieNode.Intermediate.html": {
    "href": "api/MoreStructures.SuffixTries.SuffixTrieNode.Intermediate.html",
    "title": "Class SuffixTrieNode.Intermediate",
    "keywords": "Class SuffixTrieNode.Intermediate Builds an intermediate node, i.e. a node with children and their corresponding incoming edges. Inheritance System.Object SuffixTrieNode SuffixTrieNode.Intermediate Implements ISuffixStructureNode < SuffixTrieEdge , SuffixTrieNode > IRecImmDictIndexedTreeNode < SuffixTrieEdge , SuffixTrieNode > System.IEquatable < SuffixTrieNode > System.IEquatable < SuffixTrieNode.Intermediate > Inherited Members SuffixTrieNode.Children SuffixTrieNode.Start SuffixTrieNode.Item[SuffixTrieEdge] SuffixTrieNode.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.SuffixTries Assembly : MoreStructures.dll Syntax public class Intermediate : SuffixTrieNode, ISuffixStructureNode<SuffixTrieEdge, SuffixTrieNode>, IRecImmDictIndexedTreeNode<SuffixTrieEdge, SuffixTrieNode>, IEquatable<SuffixTrieNode>, IEquatable<SuffixTrieNode.Intermediate> Constructors | Improve this Doc View Source Intermediate(IDictionary<SuffixTrieEdge, SuffixTrieNode>) Builds an intermediate node, i.e. a node with children and their corresponding incoming edges. Declaration public Intermediate(IDictionary<SuffixTrieEdge, SuffixTrieNode> Children) Parameters Type Name Description IDictionary < SuffixTrieEdge , SuffixTrieNode > Children Implements ISuffixStructureNode<TEdge, TNode> IRecImmDictIndexedTreeNode<TEdge, TNode> System.IEquatable<T> System.IEquatable<T> Extension Methods RecImmDictIndexedTreeNodeExtensions.IsLeaf<TEdge, TNode>(IRecImmDictIndexedTreeNode<TEdge, TNode>) SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) Matcher.Match<TEdge, TNode>(ISuffixStructureNode<TEdge, TNode>, TextWithTerminator, String)"
  },
  "api/MoreStructures.SuffixTries.SuffixTrieNode.Leaf.html": {
    "href": "api/MoreStructures.SuffixTries.SuffixTrieNode.Leaf.html",
    "title": "Class SuffixTrieNode.Leaf",
    "keywords": "Class SuffixTrieNode.Leaf Builds a leaf, i.e. a node with no children and the start index of the suffix in the text. Inheritance System.Object SuffixTrieNode SuffixTrieNode.Leaf Implements ISuffixStructureNode < SuffixTrieEdge , SuffixTrieNode > IRecImmDictIndexedTreeNode < SuffixTrieEdge , SuffixTrieNode > System.IEquatable < SuffixTrieNode > System.IEquatable < SuffixTrieNode.Leaf > Inherited Members SuffixTrieNode.Children SuffixTrieNode.Start SuffixTrieNode.Item[SuffixTrieEdge] SuffixTrieNode.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.SuffixTries Assembly : MoreStructures.dll Syntax public class Leaf : SuffixTrieNode, ISuffixStructureNode<SuffixTrieEdge, SuffixTrieNode>, IRecImmDictIndexedTreeNode<SuffixTrieEdge, SuffixTrieNode>, IEquatable<SuffixTrieNode>, IEquatable<SuffixTrieNode.Leaf> Constructors | Improve this Doc View Source Leaf(Int32) Builds a leaf, i.e. a node with no children and the start index of the suffix in the text. Declaration public Leaf(int LeafStart) Parameters Type Name Description System.Int32 LeafStart Properties | Improve this Doc View Source LeafStart Declaration public int LeafStart { get; set; } Property Value Type Description System.Int32 Implements ISuffixStructureNode<TEdge, TNode> IRecImmDictIndexedTreeNode<TEdge, TNode> System.IEquatable<T> System.IEquatable<T> Extension Methods RecImmDictIndexedTreeNodeExtensions.IsLeaf<TEdge, TNode>(IRecImmDictIndexedTreeNode<TEdge, TNode>) SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator) Matcher.Match<TEdge, TNode>(ISuffixStructureNode<TEdge, TNode>, TextWithTerminator, String)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.BuilderTests.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.BuilderTests.html",
    "title": "Class BuilderTests",
    "keywords": "Class BuilderTests Inheritance System.Object BuilderTests LastFirstPropertyBasedBuilderTests_WithBinarySearchFinder LastFirstPropertyBasedBuilderTests_WithNaiveFinder LastFirstPropertyBasedBuilderTests_WithPrecomputedFinder NaiveBuilderTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Builder Assembly : MoreStructures.Tests.dll Syntax public abstract class BuilderTests Constructors | Improve this Doc View Source BuilderTests(IBuilder) Declaration public BuilderTests(IBuilder builder) Parameters Type Name Description IBuilder builder Properties | Improve this Doc View Source Builder Declaration protected IBuilder Builder { get; } Property Value Type Description IBuilder Methods | Improve this Doc View Source BuildMatrix_AllRotationsAreDifferent() Declaration public void BuildMatrix_AllRotationsAreDifferent() | Improve this Doc View Source BuildMatrix_FromTransform_IsCorrect(BuilderTests.TestCase) Declaration public void BuildMatrix_FromTransform_IsCorrect(BuilderTests.TestCase testCase) Parameters Type Name Description BuilderTests.TestCase testCase | Improve this Doc View Source BuildMatrix_LastFirstProperty() Declaration public void BuildMatrix_LastFirstProperty() | Improve this Doc View Source BuildMatrix_ReturnsAllRotationsOfText() Declaration public void BuildMatrix_ReturnsAllRotationsOfText() | Improve this Doc View Source BuildMatrix_ReturnsRotationsSorted() Declaration public void BuildMatrix_ReturnsRotationsSorted() | Improve this Doc View Source BuildTransform_WithMatrix_IsCorrect(BuilderTests.TestCase) Declaration public void BuildTransform_WithMatrix_IsCorrect(BuilderTests.TestCase testCase) Parameters Type Name Description BuilderTests.TestCase testCase | Improve this Doc View Source BuildTransform_WithText_IsCorrect(BuilderTests.TestCase) Declaration public void BuildTransform_WithText_IsCorrect(BuilderTests.TestCase testCase) Parameters Type Name Description BuilderTests.TestCase testCase | Improve this Doc View Source InvertMatrix_IsCorrect(BuilderTests.TestCase) Declaration public void InvertMatrix_IsCorrect(BuilderTests.TestCase testCase) Parameters Type Name Description BuilderTests.TestCase testCase | Improve this Doc View Source InvertTransform_IsCorrect(BuilderTests.TestCase) Declaration public void InvertTransform_IsCorrect(BuilderTests.TestCase testCase) Parameters Type Name Description BuilderTests.TestCase testCase Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.BuilderTests.TestCase.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.BuilderTests.TestCase.html",
    "title": "Enum BuilderTests.TestCase",
    "keywords": "Enum BuilderTests.TestCase Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Builder Assembly : MoreStructures.Tests.dll Syntax public enum TestCase Fields Name Description Allele Banana BurrowsWheelerTransform Mississippi PanamaBananas Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, BuilderTests.TestCase>(TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.html",
    "title": "Namespace MoreStructures.Tests.BurrowsWheelerTransform.Builder",
    "keywords": "Namespace MoreStructures.Tests.BurrowsWheelerTransform.Builder Classes BuilderTests LastFirstPropertyBasedBuilderTests_WithBinarySearchFinder LastFirstPropertyBasedBuilderTests_WithNaiveFinder LastFirstPropertyBasedBuilderTests_WithPrecomputedFinder NaiveBuilderTests Enums BuilderTests.TestCase"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders.BinarySearchFinderTests.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders.BinarySearchFinderTests.html",
    "title": "Class BinarySearchFinderTests",
    "keywords": "Class BinarySearchFinderTests Inheritance System.Object LastFirstFinderTests BinarySearchFinderTests Inherited Members LastFirstFinderTests.FinderBuilder LastFirstFinderTests.FindIndexOfNthOccurrenceInBWTAndSortedBWT_IsCorrect(String, Char, Int32, Int32, Int32, Int32) LastFirstFinderTests.FindIndexOfNthOccurrenceInBWTAndSortedBWT_ThrowsExceptionOnInvalidInput(String, Char, Int32, Int32) LastFirstFinderTests.FindOccurrenceOfCharInBWT_IsCorrect(String, Char, Int32, Int32) LastFirstFinderTests.FindOccurrenceOfCharInSortedBWT_IsCorrect(String, Char, Int32, Int32) LastFirstFinderTests.FindOccurrenceOfCharInSortedBWTAndSortedBWT_ThrowsExceptionOnInvalidInput(String, Char, Int32) LastFirstFinderTests.LastToFirst_IsCorrect(String, Char, Int32, Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders Assembly : MoreStructures.Tests.dll Syntax public class BinarySearchFinderTests : LastFirstFinderTests Constructors | Improve this Doc View Source BinarySearchFinderTests() Declaration public BinarySearchFinderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders.html",
    "title": "Namespace MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders",
    "keywords": "Namespace MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders Classes BinarySearchFinderTests LastFirstFinderTests NaiveFinderTests PrecomputedFinderTests"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders.LastFirstFinderTests.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders.LastFirstFinderTests.html",
    "title": "Class LastFirstFinderTests",
    "keywords": "Class LastFirstFinderTests Inheritance System.Object LastFirstFinderTests BinarySearchFinderTests NaiveFinderTests PrecomputedFinderTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders Assembly : MoreStructures.Tests.dll Syntax public abstract class LastFirstFinderTests Constructors | Improve this Doc View Source LastFirstFinderTests(Func<RotatedTextWithTerminator, ILastFirstFinder>) Declaration protected LastFirstFinderTests(Func<RotatedTextWithTerminator, ILastFirstFinder> finderBuilder) Parameters Type Name Description Func < RotatedTextWithTerminator , ILastFirstFinder > finderBuilder Properties | Improve this Doc View Source FinderBuilder Declaration protected Func<RotatedTextWithTerminator, ILastFirstFinder> FinderBuilder { get; } Property Value Type Description Func < RotatedTextWithTerminator , ILastFirstFinder > Methods | Improve this Doc View Source FindIndexOfNthOccurrenceInBWTAndSortedBWT_IsCorrect(String, Char, Int32, Int32, Int32, Int32) Declaration public void FindIndexOfNthOccurrenceInBWTAndSortedBWT_IsCorrect(string bwtStr, char terminator, int indexOfCharInBWT, int occurrence, int expectedBWTResult, int expectedSortedBWTResult) Parameters Type Name Description System.String bwtStr System.Char terminator System.Int32 indexOfCharInBWT System.Int32 occurrence System.Int32 expectedBWTResult System.Int32 expectedSortedBWTResult | Improve this Doc View Source FindIndexOfNthOccurrenceInBWTAndSortedBWT_ThrowsExceptionOnInvalidInput(String, Char, Int32, Int32) Declaration public void FindIndexOfNthOccurrenceInBWTAndSortedBWT_ThrowsExceptionOnInvalidInput(string bwtStr, char terminator, int indexOfCharInBWT, int occurrence) Parameters Type Name Description System.String bwtStr System.Char terminator System.Int32 indexOfCharInBWT System.Int32 occurrence | Improve this Doc View Source FindOccurrenceOfCharInBWT_IsCorrect(String, Char, Int32, Int32) Declaration public void FindOccurrenceOfCharInBWT_IsCorrect(string bwtStr, char terminator, int indexOfCharInBWT, int expectedOccurrenceRank) Parameters Type Name Description System.String bwtStr System.Char terminator System.Int32 indexOfCharInBWT System.Int32 expectedOccurrenceRank | Improve this Doc View Source FindOccurrenceOfCharInSortedBWT_IsCorrect(String, Char, Int32, Int32) Declaration public void FindOccurrenceOfCharInSortedBWT_IsCorrect(string bwtStr, char terminator, int indexOfCharInSortedBWT, int expectedOccurrenceRank) Parameters Type Name Description System.String bwtStr System.Char terminator System.Int32 indexOfCharInSortedBWT System.Int32 expectedOccurrenceRank | Improve this Doc View Source FindOccurrenceOfCharInSortedBWTAndSortedBWT_ThrowsExceptionOnInvalidInput(String, Char, Int32) Declaration public void FindOccurrenceOfCharInSortedBWTAndSortedBWT_ThrowsExceptionOnInvalidInput(string bwtStr, char terminator, int indexOfChar) Parameters Type Name Description System.String bwtStr System.Char terminator System.Int32 indexOfChar | Improve this Doc View Source LastToFirst_IsCorrect(String, Char, Int32, Int32) Declaration public void LastToFirst_IsCorrect(string bwtStr, char terminator, int last, int expectedFirst) Parameters Type Name Description System.String bwtStr System.Char terminator System.Int32 last System.Int32 expectedFirst Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders.NaiveFinderTests.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders.NaiveFinderTests.html",
    "title": "Class NaiveFinderTests",
    "keywords": "Class NaiveFinderTests Inheritance System.Object LastFirstFinderTests NaiveFinderTests Inherited Members LastFirstFinderTests.FinderBuilder LastFirstFinderTests.FindIndexOfNthOccurrenceInBWTAndSortedBWT_IsCorrect(String, Char, Int32, Int32, Int32, Int32) LastFirstFinderTests.FindIndexOfNthOccurrenceInBWTAndSortedBWT_ThrowsExceptionOnInvalidInput(String, Char, Int32, Int32) LastFirstFinderTests.FindOccurrenceOfCharInBWT_IsCorrect(String, Char, Int32, Int32) LastFirstFinderTests.FindOccurrenceOfCharInSortedBWT_IsCorrect(String, Char, Int32, Int32) LastFirstFinderTests.FindOccurrenceOfCharInSortedBWTAndSortedBWT_ThrowsExceptionOnInvalidInput(String, Char, Int32) LastFirstFinderTests.LastToFirst_IsCorrect(String, Char, Int32, Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders Assembly : MoreStructures.Tests.dll Syntax public class NaiveFinderTests : LastFirstFinderTests Constructors | Improve this Doc View Source NaiveFinderTests() Declaration public NaiveFinderTests() Methods | Improve this Doc View Source Ctor_SetsBWTAndSortedBWT() Declaration public void Ctor_SetsBWTAndSortedBWT() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders.PrecomputedFinderTests.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders.PrecomputedFinderTests.html",
    "title": "Class PrecomputedFinderTests",
    "keywords": "Class PrecomputedFinderTests Inheritance System.Object LastFirstFinderTests PrecomputedFinderTests Inherited Members LastFirstFinderTests.FinderBuilder LastFirstFinderTests.FindIndexOfNthOccurrenceInBWTAndSortedBWT_IsCorrect(String, Char, Int32, Int32, Int32, Int32) LastFirstFinderTests.FindIndexOfNthOccurrenceInBWTAndSortedBWT_ThrowsExceptionOnInvalidInput(String, Char, Int32, Int32) LastFirstFinderTests.FindOccurrenceOfCharInBWT_IsCorrect(String, Char, Int32, Int32) LastFirstFinderTests.FindOccurrenceOfCharInSortedBWT_IsCorrect(String, Char, Int32, Int32) LastFirstFinderTests.FindOccurrenceOfCharInSortedBWTAndSortedBWT_ThrowsExceptionOnInvalidInput(String, Char, Int32) LastFirstFinderTests.LastToFirst_IsCorrect(String, Char, Int32, Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstFinders Assembly : MoreStructures.Tests.dll Syntax public class PrecomputedFinderTests : LastFirstFinderTests Constructors | Improve this Doc View Source PrecomputedFinderTests() Declaration public PrecomputedFinderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstPropertyBasedBuilderTests_WithBinarySearchFinder.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstPropertyBasedBuilderTests_WithBinarySearchFinder.html",
    "title": "Class LastFirstPropertyBasedBuilderTests_WithBinarySearchFinder",
    "keywords": "Class LastFirstPropertyBasedBuilderTests_WithBinarySearchFinder Inheritance System.Object BuilderTests LastFirstPropertyBasedBuilderTests_WithBinarySearchFinder Inherited Members BuilderTests.Builder BuilderTests.BuildMatrix_ReturnsAllRotationsOfText() BuilderTests.BuildMatrix_ReturnsRotationsSorted() BuilderTests.BuildMatrix_AllRotationsAreDifferent() BuilderTests.BuildMatrix_LastFirstProperty() BuilderTests.BuildMatrix_FromTransform_IsCorrect(BuilderTests.TestCase) BuilderTests.BuildTransform_WithText_IsCorrect(BuilderTests.TestCase) BuilderTests.BuildTransform_WithMatrix_IsCorrect(BuilderTests.TestCase) BuilderTests.InvertMatrix_IsCorrect(BuilderTests.TestCase) BuilderTests.InvertTransform_IsCorrect(BuilderTests.TestCase) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Builder Assembly : MoreStructures.Tests.dll Syntax public class LastFirstPropertyBasedBuilderTests_WithBinarySearchFinder : BuilderTests Constructors | Improve this Doc View Source LastFirstPropertyBasedBuilderTests_WithBinarySearchFinder() Declaration public LastFirstPropertyBasedBuilderTests_WithBinarySearchFinder() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstPropertyBasedBuilderTests_WithNaiveFinder.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstPropertyBasedBuilderTests_WithNaiveFinder.html",
    "title": "Class LastFirstPropertyBasedBuilderTests_WithNaiveFinder",
    "keywords": "Class LastFirstPropertyBasedBuilderTests_WithNaiveFinder Inheritance System.Object BuilderTests LastFirstPropertyBasedBuilderTests_WithNaiveFinder Inherited Members BuilderTests.Builder BuilderTests.BuildMatrix_ReturnsAllRotationsOfText() BuilderTests.BuildMatrix_ReturnsRotationsSorted() BuilderTests.BuildMatrix_AllRotationsAreDifferent() BuilderTests.BuildMatrix_LastFirstProperty() BuilderTests.BuildMatrix_FromTransform_IsCorrect(BuilderTests.TestCase) BuilderTests.BuildTransform_WithText_IsCorrect(BuilderTests.TestCase) BuilderTests.BuildTransform_WithMatrix_IsCorrect(BuilderTests.TestCase) BuilderTests.InvertMatrix_IsCorrect(BuilderTests.TestCase) BuilderTests.InvertTransform_IsCorrect(BuilderTests.TestCase) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Builder Assembly : MoreStructures.Tests.dll Syntax public class LastFirstPropertyBasedBuilderTests_WithNaiveFinder : BuilderTests Constructors | Improve this Doc View Source LastFirstPropertyBasedBuilderTests_WithNaiveFinder() Declaration public LastFirstPropertyBasedBuilderTests_WithNaiveFinder() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstPropertyBasedBuilderTests_WithPrecomputedFinder.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.LastFirstPropertyBasedBuilderTests_WithPrecomputedFinder.html",
    "title": "Class LastFirstPropertyBasedBuilderTests_WithPrecomputedFinder",
    "keywords": "Class LastFirstPropertyBasedBuilderTests_WithPrecomputedFinder Inheritance System.Object BuilderTests LastFirstPropertyBasedBuilderTests_WithPrecomputedFinder Inherited Members BuilderTests.Builder BuilderTests.BuildMatrix_ReturnsAllRotationsOfText() BuilderTests.BuildMatrix_ReturnsRotationsSorted() BuilderTests.BuildMatrix_AllRotationsAreDifferent() BuilderTests.BuildMatrix_LastFirstProperty() BuilderTests.BuildMatrix_FromTransform_IsCorrect(BuilderTests.TestCase) BuilderTests.BuildTransform_WithText_IsCorrect(BuilderTests.TestCase) BuilderTests.BuildTransform_WithMatrix_IsCorrect(BuilderTests.TestCase) BuilderTests.InvertMatrix_IsCorrect(BuilderTests.TestCase) BuilderTests.InvertTransform_IsCorrect(BuilderTests.TestCase) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Builder Assembly : MoreStructures.Tests.dll Syntax public class LastFirstPropertyBasedBuilderTests_WithPrecomputedFinder : BuilderTests Constructors | Improve this Doc View Source LastFirstPropertyBasedBuilderTests_WithPrecomputedFinder() Declaration public LastFirstPropertyBasedBuilderTests_WithPrecomputedFinder() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.NaiveBuilderTests.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Builder.NaiveBuilderTests.html",
    "title": "Class NaiveBuilderTests",
    "keywords": "Class NaiveBuilderTests Inheritance System.Object BuilderTests NaiveBuilderTests Inherited Members BuilderTests.Builder BuilderTests.BuildMatrix_ReturnsAllRotationsOfText() BuilderTests.BuildMatrix_ReturnsRotationsSorted() BuilderTests.BuildMatrix_AllRotationsAreDifferent() BuilderTests.BuildMatrix_LastFirstProperty() BuilderTests.BuildMatrix_FromTransform_IsCorrect(BuilderTests.TestCase) BuilderTests.BuildTransform_WithText_IsCorrect(BuilderTests.TestCase) BuilderTests.BuildTransform_WithMatrix_IsCorrect(BuilderTests.TestCase) BuilderTests.InvertMatrix_IsCorrect(BuilderTests.TestCase) BuilderTests.InvertTransform_IsCorrect(BuilderTests.TestCase) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Builder Assembly : MoreStructures.Tests.dll Syntax public class NaiveBuilderTests : BuilderTests Constructors | Improve this Doc View Source NaiveBuilderTests() Declaration public NaiveBuilderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.BWMatrixTests.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.BWMatrixTests.html",
    "title": "Class BWMatrixTests",
    "keywords": "Class BWMatrixTests Inheritance System.Object BWMatrixTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform Assembly : MoreStructures.Tests.dll Syntax public class BWMatrixTests Methods | Improve this Doc View Source Content_ReturnsAnImmutableCollection() Declaration public void Content_ReturnsAnImmutableCollection() | Improve this Doc View Source Ctor_AssignsContentSpecified() Declaration public void Ctor_AssignsContentSpecified() | Improve this Doc View Source Equals_ByValue() Declaration public void Equals_ByValue() | Improve this Doc View Source FirstColumn_IsATextPermutation() Declaration public void FirstColumn_IsATextPermutation() | Improve this Doc View Source FirstColumnAndLastColumn_AreConsistent() Declaration public void FirstColumnAndLastColumn_AreConsistent() | Improve this Doc View Source GetHashCode_ByValue() Declaration public void GetHashCode_ByValue() | Improve this Doc View Source LastColumn_IsATextPermutation() Declaration public void LastColumn_IsATextPermutation() | Improve this Doc View Source Transform_HasSameLengthAsTextPlusTerminator() Declaration public void Transform_HasSameLengthAsTextPlusTerminator() | Improve this Doc View Source Transform_IsCorrect() Declaration public void Transform_IsCorrect() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.BWTransformTests.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.BWTransformTests.html",
    "title": "Class BWTransformTests",
    "keywords": "Class BWTransformTests Inheritance System.Object BWTransformTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform Assembly : MoreStructures.Tests.dll Syntax public class BWTransformTests Methods | Improve this Doc View Source Length_IsTheSameOfLengthOfText() Declaration public void Length_IsTheSameOfLengthOfText() | Improve this Doc View Source Quicksort_IndexesMappingIsCorrect() Declaration public void Quicksort_IndexesMappingIsCorrect() | Improve this Doc View Source Quicksort_WithCustomComparer() Declaration public void Quicksort_WithCustomComparer() | Improve this Doc View Source Quicksort_WithDefaultComparer() Declaration public void Quicksort_WithDefaultComparer() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.html",
    "title": "Namespace MoreStructures.Tests.BurrowsWheelerTransform",
    "keywords": "Namespace MoreStructures.Tests.BurrowsWheelerTransform Classes BWMatrixTests BWTransformTests"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.Comparers.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.Comparers.html",
    "title": "Namespace MoreStructures.Tests.BurrowsWheelerTransform.Matching.Comparers",
    "keywords": "Namespace MoreStructures.Tests.BurrowsWheelerTransform.Matching.Comparers Classes IndexModKPartialSuffixArrayAgainstPatternComparerTests SuffixArrayAgainstPatternComparerTests"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.Comparers.IndexModKPartialSuffixArrayAgainstPatternComparerTests.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.Comparers.IndexModKPartialSuffixArrayAgainstPatternComparerTests.html",
    "title": "Class IndexModKPartialSuffixArrayAgainstPatternComparerTests",
    "keywords": "Class IndexModKPartialSuffixArrayAgainstPatternComparerTests Inheritance System.Object IndexModKPartialSuffixArrayAgainstPatternComparerTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Matching.Comparers Assembly : MoreStructures.Tests.dll Syntax public class IndexModKPartialSuffixArrayAgainstPatternComparerTests Methods | Improve this Doc View Source Compare_IsCorrect() Declaration public void Compare_IsCorrect() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.Comparers.SuffixArrayAgainstPatternComparerTests.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.Comparers.SuffixArrayAgainstPatternComparerTests.html",
    "title": "Class SuffixArrayAgainstPatternComparerTests",
    "keywords": "Class SuffixArrayAgainstPatternComparerTests Inheritance System.Object SuffixArrayAgainstPatternComparerTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Matching.Comparers Assembly : MoreStructures.Tests.dll Syntax public class SuffixArrayAgainstPatternComparerTests Methods | Improve this Doc View Source Compare_IsCorrect() Declaration public void Compare_IsCorrect() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.CountBasedNarrowingIntervalMatcherTests.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.CountBasedNarrowingIntervalMatcherTests.html",
    "title": "Class CountBasedNarrowingIntervalMatcherTests",
    "keywords": "Class CountBasedNarrowingIntervalMatcherTests Inheritance System.Object MatcherTests NarrowingIntervalMatcherTests CountBasedNarrowingIntervalMatcherTests Inherited Members NarrowingIntervalMatcherTests.Match_IsCorrectWhenFailure(String, String, Boolean, Int32, Int32, Int32) MatcherTests.MatcherBuilder MatcherTests.Match_IsCorrectWhenSuccess(String, String, Boolean, Int32, Int32, Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Matching Assembly : MoreStructures.Tests.dll Syntax public class CountBasedNarrowingIntervalMatcherTests : NarrowingIntervalMatcherTests Constructors | Improve this Doc View Source CountBasedNarrowingIntervalMatcherTests() Declaration public CountBasedNarrowingIntervalMatcherTests() Methods | Improve this Doc View Source Ctor_RaisesExceptionWithIncosistentBWTAndSortedBWT() Declaration public override void Ctor_RaisesExceptionWithIncosistentBWTAndSortedBWT() Overrides NarrowingIntervalMatcherTests.Ctor_RaisesExceptionWithIncosistentBWTAndSortedBWT() | Improve this Doc View Source Match_RaisesExceptionWithEmptyPattern() Declaration public override void Match_RaisesExceptionWithEmptyPattern() Overrides NarrowingIntervalMatcherTests.Match_RaisesExceptionWithEmptyPattern() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.html",
    "title": "Namespace MoreStructures.Tests.BurrowsWheelerTransform.Matching",
    "keywords": "Namespace MoreStructures.Tests.BurrowsWheelerTransform.Matching Classes CountBasedNarrowingIntervalMatcherTests MatcherTests NarrowingIntervalMatcherTests SuffixArrayBasedMatcherTests"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.MatcherTests.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.MatcherTests.html",
    "title": "Class MatcherTests",
    "keywords": "Class MatcherTests Inheritance System.Object MatcherTests NarrowingIntervalMatcherTests SuffixArrayBasedMatcherTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Matching Assembly : MoreStructures.Tests.dll Syntax public abstract class MatcherTests Constructors | Improve this Doc View Source MatcherTests(Func<TextWithTerminator, IMatcher>) Declaration protected MatcherTests(Func<TextWithTerminator, IMatcher> matcherBuilder) Parameters Type Name Description Func < TextWithTerminator , IMatcher > matcherBuilder Properties | Improve this Doc View Source MatcherBuilder Declaration protected Func<TextWithTerminator, IMatcher> MatcherBuilder { get; } Property Value Type Description Func < TextWithTerminator , IMatcher > Methods | Improve this Doc View Source Match_IsCorrectWhenSuccess(String, String, Boolean, Int32, Int32, Int32) Declaration public void Match_IsCorrectWhenSuccess(string textContent, string patternContent, bool expectedSuccess, int expectedMatchedChars, int expectedStart, int expectedEnd) Parameters Type Name Description System.String textContent System.String patternContent System.Boolean expectedSuccess System.Int32 expectedMatchedChars System.Int32 expectedStart System.Int32 expectedEnd Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.NarrowingIntervalMatcherTests.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.NarrowingIntervalMatcherTests.html",
    "title": "Class NarrowingIntervalMatcherTests",
    "keywords": "Class NarrowingIntervalMatcherTests Inheritance System.Object MatcherTests NarrowingIntervalMatcherTests CountBasedNarrowingIntervalMatcherTests Inherited Members MatcherTests.MatcherBuilder MatcherTests.Match_IsCorrectWhenSuccess(String, String, Boolean, Int32, Int32, Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Matching Assembly : MoreStructures.Tests.dll Syntax public class NarrowingIntervalMatcherTests : MatcherTests Constructors | Improve this Doc View Source NarrowingIntervalMatcherTests() Declaration public NarrowingIntervalMatcherTests() | Improve this Doc View Source NarrowingIntervalMatcherTests(Func<TextWithTerminator, IMatcher>) Declaration protected NarrowingIntervalMatcherTests(Func<TextWithTerminator, IMatcher> matcherBuilder) Parameters Type Name Description Func < TextWithTerminator , IMatcher > matcherBuilder Methods | Improve this Doc View Source Ctor_RaisesExceptionWithIncosistentBWTAndSortedBWT() Declaration public virtual void Ctor_RaisesExceptionWithIncosistentBWTAndSortedBWT() | Improve this Doc View Source Match_IsCorrectWhenFailure(String, String, Boolean, Int32, Int32, Int32) Declaration public void Match_IsCorrectWhenFailure(string textContent, string patternContent, bool expectedSuccess, int expectedMatchedChars, int expectedStart, int expectedEnd) Parameters Type Name Description System.String textContent System.String patternContent System.Boolean expectedSuccess System.Int32 expectedMatchedChars System.Int32 expectedStart System.Int32 expectedEnd | Improve this Doc View Source Match_RaisesExceptionWithEmptyPattern() Declaration public virtual void Match_RaisesExceptionWithEmptyPattern() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.SuffixArrayBasedMatcherTests.html": {
    "href": "api/MoreStructures.Tests.BurrowsWheelerTransform.Matching.SuffixArrayBasedMatcherTests.html",
    "title": "Class SuffixArrayBasedMatcherTests",
    "keywords": "Class SuffixArrayBasedMatcherTests Inheritance System.Object MatcherTests SuffixArrayBasedMatcherTests Inherited Members MatcherTests.MatcherBuilder MatcherTests.Match_IsCorrectWhenSuccess(String, String, Boolean, Int32, Int32, Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.BurrowsWheelerTransform.Matching Assembly : MoreStructures.Tests.dll Syntax public class SuffixArrayBasedMatcherTests : MatcherTests Constructors | Improve this Doc View Source SuffixArrayBasedMatcherTests() Declaration public SuffixArrayBasedMatcherTests() Methods | Improve this Doc View Source BWT_IsNotSupported() Declaration public void BWT_IsNotSupported() | Improve this Doc View Source Ctor_WithSuffixArrayWithDynamicIndexes() Declaration public void Ctor_WithSuffixArrayWithDynamicIndexes() | Improve this Doc View Source Match_IsCorrect(String, String, Boolean, Int32, Int32, Int32) Declaration public void Match_IsCorrect(string textContent, string patternContent, bool expectedSuccess, int expectedMatchedChars, int expectedStart, int expectedEnd) Parameters Type Name Description System.String textContent System.String patternContent System.Boolean expectedSuccess System.Int32 expectedMatchedChars System.Int32 expectedStart System.Int32 expectedEnd Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.CountTrees.CountTreeEdgeTests.html": {
    "href": "api/MoreStructures.Tests.CountTrees.CountTreeEdgeTests.html",
    "title": "Class CountTreeEdgeTests",
    "keywords": "Class CountTreeEdgeTests Inheritance System.Object CountTreeEdgeTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.CountTrees Assembly : MoreStructures.Tests.dll Syntax public class CountTreeEdgeTests Methods | Improve this Doc View Source Equals_BasedOnWrappedEdge() Declaration public void Equals_BasedOnWrappedEdge() | Improve this Doc View Source WrappedEdge_IsPreserved() Declaration public void WrappedEdge_IsPreserved() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.CountTrees.CountTreeNodeTests.html": {
    "href": "api/MoreStructures.Tests.CountTrees.CountTreeNodeTests.html",
    "title": "Class CountTreeNodeTests",
    "keywords": "Class CountTreeNodeTests Inheritance System.Object CountTreeNodeTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.CountTrees Assembly : MoreStructures.Tests.dll Syntax public class CountTreeNodeTests Methods | Improve this Doc View Source Children_PreservedWrappedStructure() Declaration public void Children_PreservedWrappedStructure() | Improve this Doc View Source DescendantsCount_DoesntStackOverflowWithDeepStructures() Declaration public void DescendantsCount_DoesntStackOverflowWithDeepStructures() | Improve this Doc View Source DescendantsCount_GivesConsistentResults() Declaration public void DescendantsCount_GivesConsistentResults() | Improve this Doc View Source DescendantsCount_OfLeafIsZero() Declaration public void DescendantsCount_OfLeafIsZero() | Improve this Doc View Source DescendantsCount_OfSingletonIsOne() Declaration public void DescendantsCount_OfSingletonIsOne() | Improve this Doc View Source DescendantsCount_OfThreeWithNNodesIsN() Declaration public void DescendantsCount_OfThreeWithNNodesIsN() | Improve this Doc View Source Equals_BasedOnWrappedNode() Declaration public void Equals_BasedOnWrappedNode() | Improve this Doc View Source WrappedNode_IsPreserved() Declaration public void WrappedNode_IsPreserved() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.CountTrees.html": {
    "href": "api/MoreStructures.Tests.CountTrees.html",
    "title": "Namespace MoreStructures.Tests.CountTrees",
    "keywords": "Namespace MoreStructures.Tests.CountTrees Classes CountTreeEdgeTests CountTreeNodeTests"
  },
  "api/MoreStructures.Tests.DisjointSets.DisjointSetTests.html": {
    "href": "api/MoreStructures.Tests.DisjointSets.DisjointSetTests.html",
    "title": "Class DisjointSetTests",
    "keywords": "Class DisjointSetTests Inheritance System.Object DisjointSetTests QuickFindDisjointSetTests QuickUnionDisjointSetTests WeightedQuickUnionDisjointSetTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.DisjointSets Assembly : MoreStructures.Tests.dll Syntax public abstract class DisjointSetTests Constructors | Improve this Doc View Source DisjointSetTests(Func<Int32, IDisjointSet>) Declaration protected DisjointSetTests(Func<int, IDisjointSet> builder) Parameters Type Name Description Func < System.Int32 , IDisjointSet > builder Properties | Improve this Doc View Source Builder Declaration protected Func<int, IDisjointSet> Builder { get; } Property Value Type Description Func < System.Int32 , IDisjointSet > Methods | Improve this Doc View Source AreConnected_IsReflexive() Declaration public void AreConnected_IsReflexive() | Improve this Doc View Source AreConnected_IsSymmetric() Declaration public void AreConnected_IsSymmetric() | Improve this Doc View Source AreConnected_IsTransitive() Declaration public void AreConnected_IsTransitive() | Improve this Doc View Source AreConnected_RaisesExceptionOnEmptyQueue() Declaration public void AreConnected_RaisesExceptionOnEmptyQueue() | Improve this Doc View Source AreConnected_RaisesExceptionOnInvalidValues() Declaration public void AreConnected_RaisesExceptionOnInvalidValues() | Improve this Doc View Source Ctor_RaisesExceptionOnInvalidValuesCount() Declaration public void Ctor_RaisesExceptionOnInvalidValuesCount() | Improve this Doc View Source Ctor_SetsSetsCountAccordingly() Declaration public void Ctor_SetsSetsCountAccordingly() | Improve this Doc View Source Ctor_SetsValuesCountAccordingly() Declaration public void Ctor_SetsValuesCountAccordingly() | Improve this Doc View Source Find_IsReflexive() Declaration public void Find_IsReflexive() | Improve this Doc View Source Find_IsSymmetric() Declaration public void Find_IsSymmetric() | Improve this Doc View Source Find_IsTransitive() Declaration public void Find_IsTransitive() | Improve this Doc View Source Find_ReturnsDifferentSetIdsForNonConnectedValues() Declaration public void Find_ReturnsDifferentSetIdsForNonConnectedValues() | Improve this Doc View Source Find_ReturnsSameSetIdForConnectedValues() Declaration public void Find_ReturnsSameSetIdForConnectedValues() | Improve this Doc View Source Find_ThrowsExceptionOnEmptyQueue() Declaration public void Find_ThrowsExceptionOnEmptyQueue() | Improve this Doc View Source Find_ThrowsExceptionOnInvalidValue() Declaration public void Find_ThrowsExceptionOnInvalidValue() | Improve this Doc View Source SetCounts_WithTransitivity() Declaration public void SetCounts_WithTransitivity() | Improve this Doc View Source SetsCount_IsCorrect() Declaration public void SetsCount_IsCorrect() | Improve this Doc View Source Union_BehavesCorrectlyWithCycles() Declaration public void Union_BehavesCorrectlyWithCycles() | Improve this Doc View Source Union_IsIdempotent() Declaration public void Union_IsIdempotent() | Improve this Doc View Source Union_ThrowsExceptionOnEmptyQueue() Declaration public void Union_ThrowsExceptionOnEmptyQueue() | Improve this Doc View Source Union_ThrowsExceptionOnInvalidValues() Declaration public void Union_ThrowsExceptionOnInvalidValues() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.DisjointSets.html": {
    "href": "api/MoreStructures.Tests.DisjointSets.html",
    "title": "Namespace MoreStructures.Tests.DisjointSets",
    "keywords": "Namespace MoreStructures.Tests.DisjointSets Classes DisjointSetTests PathCompressionWeightedQuickUnionDisjointSetTests QuickFindDisjointSetTests QuickUnionDisjointSetTests WeightedQuickUnionDisjointSetTests"
  },
  "api/MoreStructures.Tests.DisjointSets.PathCompressionWeightedQuickUnionDisjointSetTests.html": {
    "href": "api/MoreStructures.Tests.DisjointSets.PathCompressionWeightedQuickUnionDisjointSetTests.html",
    "title": "Class PathCompressionWeightedQuickUnionDisjointSetTests",
    "keywords": "Class PathCompressionWeightedQuickUnionDisjointSetTests Inheritance System.Object DisjointSetTests WeightedQuickUnionDisjointSetTests PathCompressionWeightedQuickUnionDisjointSetTests Inherited Members WeightedQuickUnionDisjointSetTests.GetRanks_IsZeroAfterCtor() WeightedQuickUnionDisjointSetTests.GetRanks_ReturnsCopy() WeightedQuickUnionDisjointSetTests.Union_UpdatesRanks() WeightedQuickUnionDisjointSetTests.Union_MergesByRank() WeightedQuickUnionDisjointSetTests.Union_MinimizesRankGrow(Int32) DisjointSetTests.Builder DisjointSetTests.Ctor_SetsValuesCountAccordingly() DisjointSetTests.Ctor_SetsSetsCountAccordingly() DisjointSetTests.Ctor_RaisesExceptionOnInvalidValuesCount() DisjointSetTests.SetsCount_IsCorrect() DisjointSetTests.SetCounts_WithTransitivity() DisjointSetTests.AreConnected_RaisesExceptionOnInvalidValues() DisjointSetTests.AreConnected_RaisesExceptionOnEmptyQueue() DisjointSetTests.AreConnected_IsReflexive() DisjointSetTests.AreConnected_IsSymmetric() DisjointSetTests.AreConnected_IsTransitive() DisjointSetTests.Find_ThrowsExceptionOnInvalidValue() DisjointSetTests.Find_ThrowsExceptionOnEmptyQueue() DisjointSetTests.Find_ReturnsDifferentSetIdsForNonConnectedValues() DisjointSetTests.Find_ReturnsSameSetIdForConnectedValues() DisjointSetTests.Find_IsReflexive() DisjointSetTests.Find_IsSymmetric() DisjointSetTests.Find_IsTransitive() DisjointSetTests.Union_IsIdempotent() DisjointSetTests.Union_ThrowsExceptionOnInvalidValues() DisjointSetTests.Union_ThrowsExceptionOnEmptyQueue() DisjointSetTests.Union_BehavesCorrectlyWithCycles() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.DisjointSets Assembly : MoreStructures.Tests.dll Syntax public class PathCompressionWeightedQuickUnionDisjointSetTests : WeightedQuickUnionDisjointSetTests Constructors | Improve this Doc View Source PathCompressionWeightedQuickUnionDisjointSetTests() Declaration public PathCompressionWeightedQuickUnionDisjointSetTests() Methods | Improve this Doc View Source Find_MakesTreeFlat() Declaration public void Find_MakesTreeFlat() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.DisjointSets.QuickFindDisjointSetTests.html": {
    "href": "api/MoreStructures.Tests.DisjointSets.QuickFindDisjointSetTests.html",
    "title": "Class QuickFindDisjointSetTests",
    "keywords": "Class QuickFindDisjointSetTests Inheritance System.Object DisjointSetTests QuickFindDisjointSetTests Inherited Members DisjointSetTests.Builder DisjointSetTests.Ctor_SetsValuesCountAccordingly() DisjointSetTests.Ctor_SetsSetsCountAccordingly() DisjointSetTests.Ctor_RaisesExceptionOnInvalidValuesCount() DisjointSetTests.SetsCount_IsCorrect() DisjointSetTests.SetCounts_WithTransitivity() DisjointSetTests.AreConnected_RaisesExceptionOnInvalidValues() DisjointSetTests.AreConnected_RaisesExceptionOnEmptyQueue() DisjointSetTests.AreConnected_IsReflexive() DisjointSetTests.AreConnected_IsSymmetric() DisjointSetTests.AreConnected_IsTransitive() DisjointSetTests.Find_ThrowsExceptionOnInvalidValue() DisjointSetTests.Find_ThrowsExceptionOnEmptyQueue() DisjointSetTests.Find_ReturnsDifferentSetIdsForNonConnectedValues() DisjointSetTests.Find_ReturnsSameSetIdForConnectedValues() DisjointSetTests.Find_IsReflexive() DisjointSetTests.Find_IsSymmetric() DisjointSetTests.Find_IsTransitive() DisjointSetTests.Union_IsIdempotent() DisjointSetTests.Union_ThrowsExceptionOnInvalidValues() DisjointSetTests.Union_ThrowsExceptionOnEmptyQueue() DisjointSetTests.Union_BehavesCorrectlyWithCycles() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.DisjointSets Assembly : MoreStructures.Tests.dll Syntax public class QuickFindDisjointSetTests : DisjointSetTests Constructors | Improve this Doc View Source QuickFindDisjointSetTests() Declaration public QuickFindDisjointSetTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.DisjointSets.QuickUnionDisjointSetTests.html": {
    "href": "api/MoreStructures.Tests.DisjointSets.QuickUnionDisjointSetTests.html",
    "title": "Class QuickUnionDisjointSetTests",
    "keywords": "Class QuickUnionDisjointSetTests Inheritance System.Object DisjointSetTests QuickUnionDisjointSetTests Inherited Members DisjointSetTests.Builder DisjointSetTests.Ctor_SetsValuesCountAccordingly() DisjointSetTests.Ctor_SetsSetsCountAccordingly() DisjointSetTests.Ctor_RaisesExceptionOnInvalidValuesCount() DisjointSetTests.SetsCount_IsCorrect() DisjointSetTests.SetCounts_WithTransitivity() DisjointSetTests.AreConnected_RaisesExceptionOnInvalidValues() DisjointSetTests.AreConnected_RaisesExceptionOnEmptyQueue() DisjointSetTests.AreConnected_IsReflexive() DisjointSetTests.AreConnected_IsSymmetric() DisjointSetTests.AreConnected_IsTransitive() DisjointSetTests.Find_ThrowsExceptionOnInvalidValue() DisjointSetTests.Find_ThrowsExceptionOnEmptyQueue() DisjointSetTests.Find_ReturnsDifferentSetIdsForNonConnectedValues() DisjointSetTests.Find_ReturnsSameSetIdForConnectedValues() DisjointSetTests.Find_IsReflexive() DisjointSetTests.Find_IsSymmetric() DisjointSetTests.Find_IsTransitive() DisjointSetTests.Union_IsIdempotent() DisjointSetTests.Union_ThrowsExceptionOnInvalidValues() DisjointSetTests.Union_ThrowsExceptionOnEmptyQueue() DisjointSetTests.Union_BehavesCorrectlyWithCycles() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.DisjointSets Assembly : MoreStructures.Tests.dll Syntax public class QuickUnionDisjointSetTests : DisjointSetTests Constructors | Improve this Doc View Source QuickUnionDisjointSetTests() Declaration public QuickUnionDisjointSetTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.DisjointSets.WeightedQuickUnionDisjointSetTests.html": {
    "href": "api/MoreStructures.Tests.DisjointSets.WeightedQuickUnionDisjointSetTests.html",
    "title": "Class WeightedQuickUnionDisjointSetTests",
    "keywords": "Class WeightedQuickUnionDisjointSetTests Inheritance System.Object DisjointSetTests WeightedQuickUnionDisjointSetTests PathCompressionWeightedQuickUnionDisjointSetTests Inherited Members DisjointSetTests.Builder DisjointSetTests.Ctor_SetsValuesCountAccordingly() DisjointSetTests.Ctor_SetsSetsCountAccordingly() DisjointSetTests.Ctor_RaisesExceptionOnInvalidValuesCount() DisjointSetTests.SetsCount_IsCorrect() DisjointSetTests.SetCounts_WithTransitivity() DisjointSetTests.AreConnected_RaisesExceptionOnInvalidValues() DisjointSetTests.AreConnected_RaisesExceptionOnEmptyQueue() DisjointSetTests.AreConnected_IsReflexive() DisjointSetTests.AreConnected_IsSymmetric() DisjointSetTests.AreConnected_IsTransitive() DisjointSetTests.Find_ThrowsExceptionOnInvalidValue() DisjointSetTests.Find_ThrowsExceptionOnEmptyQueue() DisjointSetTests.Find_ReturnsDifferentSetIdsForNonConnectedValues() DisjointSetTests.Find_ReturnsSameSetIdForConnectedValues() DisjointSetTests.Find_IsReflexive() DisjointSetTests.Find_IsSymmetric() DisjointSetTests.Find_IsTransitive() DisjointSetTests.Union_IsIdempotent() DisjointSetTests.Union_ThrowsExceptionOnInvalidValues() DisjointSetTests.Union_ThrowsExceptionOnEmptyQueue() DisjointSetTests.Union_BehavesCorrectlyWithCycles() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.DisjointSets Assembly : MoreStructures.Tests.dll Syntax public class WeightedQuickUnionDisjointSetTests : DisjointSetTests Constructors | Improve this Doc View Source WeightedQuickUnionDisjointSetTests() Declaration public WeightedQuickUnionDisjointSetTests() | Improve this Doc View Source WeightedQuickUnionDisjointSetTests(Func<Int32, IDisjointSet>) Declaration protected WeightedQuickUnionDisjointSetTests(Func<int, IDisjointSet> builder) Parameters Type Name Description Func < System.Int32 , IDisjointSet > builder Methods | Improve this Doc View Source GetRanks_IsZeroAfterCtor() Declaration public void GetRanks_IsZeroAfterCtor() | Improve this Doc View Source GetRanks_ReturnsCopy() Declaration public void GetRanks_ReturnsCopy() | Improve this Doc View Source Union_MergesByRank() Declaration public void Union_MergesByRank() | Improve this Doc View Source Union_MinimizesRankGrow(Int32) Declaration public void Union_MinimizesRankGrow(int numberOfItems) Parameters Type Name Description System.Int32 numberOfItems | Improve this Doc View Source Union_UpdatesRanks() Declaration public void Union_UpdatesRanks() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.AdjacencyListGraphTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.AdjacencyListGraphTests.html",
    "title": "Class AdjacencyListGraphTests",
    "keywords": "Class AdjacencyListGraphTests Inheritance System.Object GraphTests AdjacencyListGraphTests Inherited Members GraphTests.GraphBuilder GraphTests.GetAllEdges_IsCorrect(Int32, Int32[], Int32[]) GraphTests.Reverse_IsCorrect(Int32, Int32[], Int32[]) GraphTests.Reverse_OfReverseIsInitialGraph(Int32, Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs Assembly : MoreStructures.Tests.dll Syntax public class AdjacencyListGraphTests : GraphTests Constructors | Improve this Doc View Source AdjacencyListGraphTests() Declaration public AdjacencyListGraphTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.AdjacencyMatrixGraphTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.AdjacencyMatrixGraphTests.html",
    "title": "Class AdjacencyMatrixGraphTests",
    "keywords": "Class AdjacencyMatrixGraphTests Inheritance System.Object GraphTests AdjacencyMatrixGraphTests Inherited Members GraphTests.GraphBuilder GraphTests.GetAllEdges_IsCorrect(Int32, Int32[], Int32[]) GraphTests.Reverse_IsCorrect(Int32, Int32[], Int32[]) GraphTests.Reverse_OfReverseIsInitialGraph(Int32, Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs Assembly : MoreStructures.Tests.dll Syntax public class AdjacencyMatrixGraphTests : GraphTests Constructors | Improve this Doc View Source AdjacencyMatrixGraphTests() Declaration public AdjacencyMatrixGraphTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.DictionaryAdapterGraphDistancesTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.DictionaryAdapterGraphDistancesTests.html",
    "title": "Class DictionaryAdapterGraphDistancesTests",
    "keywords": "Class DictionaryAdapterGraphDistancesTests Inheritance System.Object DictionaryAdapterGraphDistancesTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs Assembly : MoreStructures.Tests.dll Syntax public class DictionaryAdapterGraphDistancesTests Methods | Improve this Doc View Source Indexer_RaisesExceptionWhenProvidedEdgeIsUnknown() Declaration public void Indexer_RaisesExceptionWhenProvidedEdgeIsUnknown() | Improve this Doc View Source Indexer_TakesDataFromUnderlyingDictionary() Declaration public void Indexer_TakesDataFromUnderlyingDictionary() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.EdgeListGraphTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.EdgeListGraphTests.html",
    "title": "Class EdgeListGraphTests",
    "keywords": "Class EdgeListGraphTests Inheritance System.Object GraphTests EdgeListGraphTests Inherited Members GraphTests.GraphBuilder GraphTests.GetAllEdges_IsCorrect(Int32, Int32[], Int32[]) GraphTests.Reverse_IsCorrect(Int32, Int32[], Int32[]) GraphTests.Reverse_OfReverseIsInitialGraph(Int32, Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs Assembly : MoreStructures.Tests.dll Syntax public class EdgeListGraphTests : GraphTests Constructors | Improve this Doc View Source EdgeListGraphTests() Declaration public EdgeListGraphTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.GraphTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.GraphTests.html",
    "title": "Class GraphTests",
    "keywords": "Class GraphTests Inheritance System.Object GraphTests AdjacencyListGraphTests AdjacencyMatrixGraphTests EdgeListGraphTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs Assembly : MoreStructures.Tests.dll Syntax public abstract class GraphTests Constructors | Improve this Doc View Source GraphTests(Func<Int32, IList<(Int32, Int32)>, IGraph>) Declaration protected GraphTests(Func<int, IList<(int, int)>, IGraph> graphBuilder) Parameters Type Name Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > graphBuilder Properties | Improve this Doc View Source GraphBuilder Declaration protected Func<int, IList<(int, int)>, IGraph> GraphBuilder { get; } Property Value Type Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > Methods | Improve this Doc View Source GetAllEdges_IsCorrect(Int32, Int32[], Int32[]) Declaration public void GetAllEdges_IsCorrect(int numberOfVertices, int[] starts, int[] ends) Parameters Type Name Description System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends | Improve this Doc View Source Reverse_IsCorrect(Int32, Int32[], Int32[]) Declaration public void Reverse_IsCorrect(int numberOfVertices, int[] starts, int[] ends) Parameters Type Name Description System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends | Improve this Doc View Source Reverse_OfReverseIsInitialGraph(Int32, Int32[], Int32[]) Declaration public void Reverse_OfReverseIsInitialGraph(int numberOfVertices, int[] starts, int[] ends) Parameters Type Name Description System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.html": {
    "href": "api/MoreStructures.Tests.Graphs.html",
    "title": "Namespace MoreStructures.Tests.Graphs",
    "keywords": "Namespace MoreStructures.Tests.Graphs Classes AdjacencyListGraphTests AdjacencyMatrixGraphTests DictionaryAdapterGraphDistancesTests EdgeListGraphTests GraphTests"
  },
  "api/MoreStructures.Tests.Graphs.MinimumSpanningTree.html": {
    "href": "api/MoreStructures.Tests.Graphs.MinimumSpanningTree.html",
    "title": "Namespace MoreStructures.Tests.Graphs.MinimumSpanningTree",
    "keywords": "Namespace MoreStructures.Tests.Graphs.MinimumSpanningTree Classes KruskalMstFinderTests MstFinderTests PrimMstFinderTests"
  },
  "api/MoreStructures.Tests.Graphs.MinimumSpanningTree.KruskalMstFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.MinimumSpanningTree.KruskalMstFinderTests.html",
    "title": "Class KruskalMstFinderTests",
    "keywords": "Class KruskalMstFinderTests Inheritance System.Object MstFinderTests KruskalMstFinderTests Inherited Members MstFinderTests.GraphBuilder MstFinderTests.FinderBuilder MstFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32) MstFinderTests.Find_ThrowsExceptionIfTheGraphIsNotConnected(String, Int32, Int32[], Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.MinimumSpanningTree Assembly : MoreStructures.Tests.dll Syntax public class KruskalMstFinderTests : MstFinderTests Constructors | Improve this Doc View Source KruskalMstFinderTests() Declaration public KruskalMstFinderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.MinimumSpanningTree.MstFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.MinimumSpanningTree.MstFinderTests.html",
    "title": "Class MstFinderTests",
    "keywords": "Class MstFinderTests Inheritance System.Object MstFinderTests KruskalMstFinderTests PrimMstFinderTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.MinimumSpanningTree Assembly : MoreStructures.Tests.dll Syntax public abstract class MstFinderTests Constructors | Improve this Doc View Source MstFinderTests(Func<Int32, IList<(Int32, Int32)>, IGraph>, Func<IMstFinder>) Declaration protected MstFinderTests(Func<int, IList<(int, int)>, IGraph> graphBuilder, Func<IMstFinder> builder) Parameters Type Name Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > graphBuilder Func < IMstFinder > builder Properties | Improve this Doc View Source FinderBuilder Declaration protected Func<IMstFinder> FinderBuilder { get; } Property Value Type Description Func < IMstFinder > | Improve this Doc View Source GraphBuilder Declaration protected Func<int, IList<(int, int)>, IGraph> GraphBuilder { get; } Property Value Type Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > Methods | Improve this Doc View Source Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32) Declaration public void Find_IsCorrect(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] distances, int expectedMstWeight) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] distances System.Int32 expectedMstWeight | Improve this Doc View Source Find_ThrowsExceptionIfTheGraphIsNotConnected(String, Int32, Int32[], Int32[], Int32[]) Declaration public void Find_ThrowsExceptionIfTheGraphIsNotConnected(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] distances) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] distances Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.MinimumSpanningTree.PrimMstFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.MinimumSpanningTree.PrimMstFinderTests.html",
    "title": "Class PrimMstFinderTests",
    "keywords": "Class PrimMstFinderTests Inheritance System.Object MstFinderTests PrimMstFinderTests Inherited Members MstFinderTests.GraphBuilder MstFinderTests.FinderBuilder MstFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32) MstFinderTests.Find_ThrowsExceptionIfTheGraphIsNotConnected(String, Int32, Int32[], Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.MinimumSpanningTree Assembly : MoreStructures.Tests.dll Syntax public class PrimMstFinderTests : MstFinderTests Constructors | Improve this Doc View Source PrimMstFinderTests() Declaration public PrimMstFinderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.AStarShortestDistanceFinderTests_WithHeuristic.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.AStarShortestDistanceFinderTests_WithHeuristic.html",
    "title": "Class AStarShortestDistanceFinderTests_WithHeuristic",
    "keywords": "Class AStarShortestDistanceFinderTests_WithHeuristic Inheritance System.Object PotentialBasedShortestDistanceFinderTests AStarShortestDistanceFinderTests_WithHeuristic Inherited Members PotentialBasedShortestDistanceFinderTests.GraphBuilder PotentialBasedShortestDistanceFinderTests.FinderBuilder PotentialBasedShortestDistanceFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistance Assembly : MoreStructures.Tests.dll Syntax public class AStarShortestDistanceFinderTests_WithHeuristic : PotentialBasedShortestDistanceFinderTests Constructors | Improve this Doc View Source AStarShortestDistanceFinderTests_WithHeuristic() Declaration public AStarShortestDistanceFinderTests_WithHeuristic() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.AStarShortestDistanceFinderTests_WithoutHeuristic.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.AStarShortestDistanceFinderTests_WithoutHeuristic.html",
    "title": "Class AStarShortestDistanceFinderTests_WithoutHeuristic",
    "keywords": "Class AStarShortestDistanceFinderTests_WithoutHeuristic Inheritance System.Object ShortestDistanceFinderTests DijkstraShortestDistanceFinderTests AStarShortestDistanceFinderTests_WithoutHeuristic Inherited Members DijkstraShortestDistanceFinderTests.Find_RaisesExceptionWhenNegativeEdgesAreEncountered(String, Int32, Int32[], Int32[], Int32[], Int32, Int32) ShortestDistanceFinderTests.GraphBuilder ShortestDistanceFinderTests.FinderBuilder ShortestDistanceFinderTests.Find_ThrowsExceptionWithInvalidStartOrEnd(String, Int32, Int32[], Int32[], Int32[]) ShortestDistanceFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) ShortestDistanceFinderTests.TestGraph(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistance Assembly : MoreStructures.Tests.dll Syntax public class AStarShortestDistanceFinderTests_WithoutHeuristic : DijkstraShortestDistanceFinderTests Constructors | Improve this Doc View Source AStarShortestDistanceFinderTests_WithoutHeuristic() Declaration public AStarShortestDistanceFinderTests_WithoutHeuristic() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.BellmanFordShortestDistanceFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.BellmanFordShortestDistanceFinderTests.html",
    "title": "Class BellmanFordShortestDistanceFinderTests",
    "keywords": "Class BellmanFordShortestDistanceFinderTests Inheritance System.Object ShortestDistanceFinderTests BellmanFordShortestDistanceFinderTests Inherited Members ShortestDistanceFinderTests.GraphBuilder ShortestDistanceFinderTests.FinderBuilder ShortestDistanceFinderTests.Find_ThrowsExceptionWithInvalidStartOrEnd(String, Int32, Int32[], Int32[], Int32[]) ShortestDistanceFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) ShortestDistanceFinderTests.TestGraph(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistance Assembly : MoreStructures.Tests.dll Syntax public class BellmanFordShortestDistanceFinderTests : ShortestDistanceFinderTests Constructors | Improve this Doc View Source BellmanFordShortestDistanceFinderTests() Declaration public BellmanFordShortestDistanceFinderTests() Methods | Improve this Doc View Source Find_IsCorrectWithNegativeCycles(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) Declaration public void Find_IsCorrectWithNegativeCycles(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] distances, int start, int end, int expectedDistance, int[] expectedPath) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] distances System.Int32 start System.Int32 end System.Int32 expectedDistance System.Int32 [] expectedPath | Improve this Doc View Source Find_IsCorrectWithNegativeValues(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) Declaration public void Find_IsCorrectWithNegativeValues(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] distances, int start, int end, int expectedDistance, int[] expectedPath) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] distances System.Int32 start System.Int32 end System.Int32 expectedDistance System.Int32 [] expectedPath Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.BfsBasedShortestDistanceFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.BfsBasedShortestDistanceFinderTests.html",
    "title": "Class BfsBasedShortestDistanceFinderTests",
    "keywords": "Class BfsBasedShortestDistanceFinderTests Inheritance System.Object ShortestDistanceFinderTests BfsBasedShortestDistanceFinderTests Inherited Members ShortestDistanceFinderTests.GraphBuilder ShortestDistanceFinderTests.FinderBuilder ShortestDistanceFinderTests.Find_ThrowsExceptionWithInvalidStartOrEnd(String, Int32, Int32[], Int32[], Int32[]) ShortestDistanceFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) ShortestDistanceFinderTests.TestGraph(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistance Assembly : MoreStructures.Tests.dll Syntax public class BfsBasedShortestDistanceFinderTests : ShortestDistanceFinderTests Constructors | Improve this Doc View Source BfsBasedShortestDistanceFinderTests() Declaration public BfsBasedShortestDistanceFinderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.BidirectionalAStarShortestDistanceFinderTests_WithHeuristic.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.BidirectionalAStarShortestDistanceFinderTests_WithHeuristic.html",
    "title": "Class BidirectionalAStarShortestDistanceFinderTests_WithHeuristic",
    "keywords": "Class BidirectionalAStarShortestDistanceFinderTests_WithHeuristic Inheritance System.Object PotentialBasedShortestDistanceFinderTests BidirectionalAStarShortestDistanceFinderTests_WithHeuristic Inherited Members PotentialBasedShortestDistanceFinderTests.GraphBuilder PotentialBasedShortestDistanceFinderTests.FinderBuilder PotentialBasedShortestDistanceFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistance Assembly : MoreStructures.Tests.dll Syntax public class BidirectionalAStarShortestDistanceFinderTests_WithHeuristic : PotentialBasedShortestDistanceFinderTests Constructors | Improve this Doc View Source BidirectionalAStarShortestDistanceFinderTests_WithHeuristic() Declaration public BidirectionalAStarShortestDistanceFinderTests_WithHeuristic() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.BidirectionalAStarShortestDistanceFinderTests_WithoutHeuristic.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.BidirectionalAStarShortestDistanceFinderTests_WithoutHeuristic.html",
    "title": "Class BidirectionalAStarShortestDistanceFinderTests_WithoutHeuristic",
    "keywords": "Class BidirectionalAStarShortestDistanceFinderTests_WithoutHeuristic Inheritance System.Object ShortestDistanceFinderTests DijkstraShortestDistanceFinderTests BidirectionalAStarShortestDistanceFinderTests_WithoutHeuristic Inherited Members DijkstraShortestDistanceFinderTests.Find_RaisesExceptionWhenNegativeEdgesAreEncountered(String, Int32, Int32[], Int32[], Int32[], Int32, Int32) ShortestDistanceFinderTests.GraphBuilder ShortestDistanceFinderTests.FinderBuilder ShortestDistanceFinderTests.Find_ThrowsExceptionWithInvalidStartOrEnd(String, Int32, Int32[], Int32[], Int32[]) ShortestDistanceFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) ShortestDistanceFinderTests.TestGraph(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistance Assembly : MoreStructures.Tests.dll Syntax public class BidirectionalAStarShortestDistanceFinderTests_WithoutHeuristic : DijkstraShortestDistanceFinderTests Constructors | Improve this Doc View Source BidirectionalAStarShortestDistanceFinderTests_WithoutHeuristic() Declaration public BidirectionalAStarShortestDistanceFinderTests_WithoutHeuristic() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.BidirectionalDijkstraShortestDistanceFinderTests_WithFibonacciHeap.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.BidirectionalDijkstraShortestDistanceFinderTests_WithFibonacciHeap.html",
    "title": "Class BidirectionalDijkstraShortestDistanceFinderTests_WithFibonacciHeap",
    "keywords": "Class BidirectionalDijkstraShortestDistanceFinderTests_WithFibonacciHeap Inheritance System.Object ShortestDistanceFinderTests DijkstraShortestDistanceFinderTests BidirectionalDijkstraShortestDistanceFinderTests_WithFibonacciHeap Inherited Members DijkstraShortestDistanceFinderTests.Find_RaisesExceptionWhenNegativeEdgesAreEncountered(String, Int32, Int32[], Int32[], Int32[], Int32, Int32) ShortestDistanceFinderTests.GraphBuilder ShortestDistanceFinderTests.FinderBuilder ShortestDistanceFinderTests.Find_ThrowsExceptionWithInvalidStartOrEnd(String, Int32, Int32[], Int32[], Int32[]) ShortestDistanceFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) ShortestDistanceFinderTests.TestGraph(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistance Assembly : MoreStructures.Tests.dll Syntax public class BidirectionalDijkstraShortestDistanceFinderTests_WithFibonacciHeap : DijkstraShortestDistanceFinderTests Constructors | Improve this Doc View Source BidirectionalDijkstraShortestDistanceFinderTests_WithFibonacciHeap() Declaration public BidirectionalDijkstraShortestDistanceFinderTests_WithFibonacciHeap() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.DijkstraShortestDistanceFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.DijkstraShortestDistanceFinderTests.html",
    "title": "Class DijkstraShortestDistanceFinderTests",
    "keywords": "Class DijkstraShortestDistanceFinderTests Inheritance System.Object ShortestDistanceFinderTests DijkstraShortestDistanceFinderTests AStarShortestDistanceFinderTests_WithoutHeuristic BidirectionalAStarShortestDistanceFinderTests_WithoutHeuristic BidirectionalDijkstraShortestDistanceFinderTests_WithFibonacciHeap DijkstraShortestDistanceFinderTests_WithArrayList DijkstraShortestDistanceFinderTests_WithBinaryHeap DijkstraShortestDistanceFinderTests_WithBinomialHeap DijkstraShortestDistanceFinderTests_WithFibonacciHeap Inherited Members ShortestDistanceFinderTests.GraphBuilder ShortestDistanceFinderTests.FinderBuilder ShortestDistanceFinderTests.Find_ThrowsExceptionWithInvalidStartOrEnd(String, Int32, Int32[], Int32[], Int32[]) ShortestDistanceFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) ShortestDistanceFinderTests.TestGraph(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistance Assembly : MoreStructures.Tests.dll Syntax public abstract class DijkstraShortestDistanceFinderTests : ShortestDistanceFinderTests Constructors | Improve this Doc View Source DijkstraShortestDistanceFinderTests(Func<Int32, IList<(Int32, Int32)>, IGraph>, Func<IShortestDistanceFinder>) Declaration protected DijkstraShortestDistanceFinderTests(Func<int, IList<(int, int)>, IGraph> graphBuilder, Func<IShortestDistanceFinder> finderBuilder) Parameters Type Name Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > graphBuilder Func < IShortestDistanceFinder > finderBuilder Methods | Improve this Doc View Source Find_RaisesExceptionWhenNegativeEdgesAreEncountered(String, Int32, Int32[], Int32[], Int32[], Int32, Int32) Declaration public void Find_RaisesExceptionWhenNegativeEdgesAreEncountered(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] distances, int start, int end) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] distances System.Int32 start System.Int32 end Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.DijkstraShortestDistanceFinderTests_WithArrayList.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.DijkstraShortestDistanceFinderTests_WithArrayList.html",
    "title": "Class DijkstraShortestDistanceFinderTests_WithArrayList",
    "keywords": "Class DijkstraShortestDistanceFinderTests_WithArrayList Inheritance System.Object ShortestDistanceFinderTests DijkstraShortestDistanceFinderTests DijkstraShortestDistanceFinderTests_WithArrayList Inherited Members DijkstraShortestDistanceFinderTests.Find_RaisesExceptionWhenNegativeEdgesAreEncountered(String, Int32, Int32[], Int32[], Int32[], Int32, Int32) ShortestDistanceFinderTests.GraphBuilder ShortestDistanceFinderTests.FinderBuilder ShortestDistanceFinderTests.Find_ThrowsExceptionWithInvalidStartOrEnd(String, Int32, Int32[], Int32[], Int32[]) ShortestDistanceFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) ShortestDistanceFinderTests.TestGraph(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistance Assembly : MoreStructures.Tests.dll Syntax public class DijkstraShortestDistanceFinderTests_WithArrayList : DijkstraShortestDistanceFinderTests Constructors | Improve this Doc View Source DijkstraShortestDistanceFinderTests_WithArrayList() Declaration public DijkstraShortestDistanceFinderTests_WithArrayList() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.DijkstraShortestDistanceFinderTests_WithBinaryHeap.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.DijkstraShortestDistanceFinderTests_WithBinaryHeap.html",
    "title": "Class DijkstraShortestDistanceFinderTests_WithBinaryHeap",
    "keywords": "Class DijkstraShortestDistanceFinderTests_WithBinaryHeap Inheritance System.Object ShortestDistanceFinderTests DijkstraShortestDistanceFinderTests DijkstraShortestDistanceFinderTests_WithBinaryHeap Inherited Members DijkstraShortestDistanceFinderTests.Find_RaisesExceptionWhenNegativeEdgesAreEncountered(String, Int32, Int32[], Int32[], Int32[], Int32, Int32) ShortestDistanceFinderTests.GraphBuilder ShortestDistanceFinderTests.FinderBuilder ShortestDistanceFinderTests.Find_ThrowsExceptionWithInvalidStartOrEnd(String, Int32, Int32[], Int32[], Int32[]) ShortestDistanceFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) ShortestDistanceFinderTests.TestGraph(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistance Assembly : MoreStructures.Tests.dll Syntax public class DijkstraShortestDistanceFinderTests_WithBinaryHeap : DijkstraShortestDistanceFinderTests Constructors | Improve this Doc View Source DijkstraShortestDistanceFinderTests_WithBinaryHeap() Declaration public DijkstraShortestDistanceFinderTests_WithBinaryHeap() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.DijkstraShortestDistanceFinderTests_WithBinomialHeap.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.DijkstraShortestDistanceFinderTests_WithBinomialHeap.html",
    "title": "Class DijkstraShortestDistanceFinderTests_WithBinomialHeap",
    "keywords": "Class DijkstraShortestDistanceFinderTests_WithBinomialHeap Inheritance System.Object ShortestDistanceFinderTests DijkstraShortestDistanceFinderTests DijkstraShortestDistanceFinderTests_WithBinomialHeap Inherited Members DijkstraShortestDistanceFinderTests.Find_RaisesExceptionWhenNegativeEdgesAreEncountered(String, Int32, Int32[], Int32[], Int32[], Int32, Int32) ShortestDistanceFinderTests.GraphBuilder ShortestDistanceFinderTests.FinderBuilder ShortestDistanceFinderTests.Find_ThrowsExceptionWithInvalidStartOrEnd(String, Int32, Int32[], Int32[], Int32[]) ShortestDistanceFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) ShortestDistanceFinderTests.TestGraph(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistance Assembly : MoreStructures.Tests.dll Syntax public class DijkstraShortestDistanceFinderTests_WithBinomialHeap : DijkstraShortestDistanceFinderTests Constructors | Improve this Doc View Source DijkstraShortestDistanceFinderTests_WithBinomialHeap() Declaration public DijkstraShortestDistanceFinderTests_WithBinomialHeap() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.DijkstraShortestDistanceFinderTests_WithFibonacciHeap.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.DijkstraShortestDistanceFinderTests_WithFibonacciHeap.html",
    "title": "Class DijkstraShortestDistanceFinderTests_WithFibonacciHeap",
    "keywords": "Class DijkstraShortestDistanceFinderTests_WithFibonacciHeap Inheritance System.Object ShortestDistanceFinderTests DijkstraShortestDistanceFinderTests DijkstraShortestDistanceFinderTests_WithFibonacciHeap Inherited Members DijkstraShortestDistanceFinderTests.Find_RaisesExceptionWhenNegativeEdgesAreEncountered(String, Int32, Int32[], Int32[], Int32[], Int32, Int32) ShortestDistanceFinderTests.GraphBuilder ShortestDistanceFinderTests.FinderBuilder ShortestDistanceFinderTests.Find_ThrowsExceptionWithInvalidStartOrEnd(String, Int32, Int32[], Int32[], Int32[]) ShortestDistanceFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) ShortestDistanceFinderTests.TestGraph(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistance Assembly : MoreStructures.Tests.dll Syntax public class DijkstraShortestDistanceFinderTests_WithFibonacciHeap : DijkstraShortestDistanceFinderTests Constructors | Improve this Doc View Source DijkstraShortestDistanceFinderTests_WithFibonacciHeap() Declaration public DijkstraShortestDistanceFinderTests_WithFibonacciHeap() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.html",
    "title": "Namespace MoreStructures.Tests.Graphs.ShortestDistance",
    "keywords": "Namespace MoreStructures.Tests.Graphs.ShortestDistance Classes AStarShortestDistanceFinderTests_WithHeuristic AStarShortestDistanceFinderTests_WithoutHeuristic BellmanFordShortestDistanceFinderTests BfsBasedShortestDistanceFinderTests BidirectionalAStarShortestDistanceFinderTests_WithHeuristic BidirectionalAStarShortestDistanceFinderTests_WithoutHeuristic BidirectionalDijkstraShortestDistanceFinderTests_WithFibonacciHeap DijkstraShortestDistanceFinderTests DijkstraShortestDistanceFinderTests_WithArrayList DijkstraShortestDistanceFinderTests_WithBinaryHeap DijkstraShortestDistanceFinderTests_WithBinomialHeap DijkstraShortestDistanceFinderTests_WithFibonacciHeap PotentialBasedShortestDistanceFinderTests ShortestDistanceFinderTests"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.PotentialBasedShortestDistanceFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.PotentialBasedShortestDistanceFinderTests.html",
    "title": "Class PotentialBasedShortestDistanceFinderTests",
    "keywords": "Class PotentialBasedShortestDistanceFinderTests Inheritance System.Object PotentialBasedShortestDistanceFinderTests AStarShortestDistanceFinderTests_WithHeuristic BidirectionalAStarShortestDistanceFinderTests_WithHeuristic Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistance Assembly : MoreStructures.Tests.dll Syntax public abstract class PotentialBasedShortestDistanceFinderTests Constructors | Improve this Doc View Source PotentialBasedShortestDistanceFinderTests(Func<Int32, IList<(Int32, Int32)>, IGraph>, Func<IPotentialBasedShortestDistanceFinder>) Declaration protected PotentialBasedShortestDistanceFinderTests(Func<int, IList<(int, int)>, IGraph> graphBuilder, Func<IPotentialBasedShortestDistanceFinder> finderBuilder) Parameters Type Name Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > graphBuilder Func < IPotentialBasedShortestDistanceFinder > finderBuilder Properties | Improve this Doc View Source FinderBuilder Declaration protected Func<IPotentialBasedShortestDistanceFinder> FinderBuilder { get; } Property Value Type Description Func < IPotentialBasedShortestDistanceFinder > | Improve this Doc View Source GraphBuilder Declaration protected Func<int, IList<(int, int)>, IGraph> GraphBuilder { get; } Property Value Type Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > Methods | Improve this Doc View Source Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[]) Declaration public void Find_IsCorrect(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] distances, int[] potentials) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] distances System.Int32 [] potentials Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistance.ShortestDistanceFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistance.ShortestDistanceFinderTests.html",
    "title": "Class ShortestDistanceFinderTests",
    "keywords": "Class ShortestDistanceFinderTests Inheritance System.Object ShortestDistanceFinderTests BellmanFordShortestDistanceFinderTests BfsBasedShortestDistanceFinderTests DijkstraShortestDistanceFinderTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistance Assembly : MoreStructures.Tests.dll Syntax public abstract class ShortestDistanceFinderTests Constructors | Improve this Doc View Source ShortestDistanceFinderTests(Func<Int32, IList<(Int32, Int32)>, IGraph>, Func<IShortestDistanceFinder>) Declaration protected ShortestDistanceFinderTests(Func<int, IList<(int, int)>, IGraph> graphBuilder, Func<IShortestDistanceFinder> finderBuilder) Parameters Type Name Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > graphBuilder Func < IShortestDistanceFinder > finderBuilder Properties | Improve this Doc View Source FinderBuilder Declaration protected Func<IShortestDistanceFinder> FinderBuilder { get; } Property Value Type Description Func < IShortestDistanceFinder > | Improve this Doc View Source GraphBuilder Declaration protected Func<int, IList<(int, int)>, IGraph> GraphBuilder { get; } Property Value Type Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > Methods | Improve this Doc View Source Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) Declaration public void Find_IsCorrect(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] distances, int start, int end, int expectedDistance, int[] expectedPath) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] distances System.Int32 start System.Int32 end System.Int32 expectedDistance System.Int32 [] expectedPath | Improve this Doc View Source Find_ThrowsExceptionWithInvalidStartOrEnd(String, Int32, Int32[], Int32[], Int32[]) Declaration public void Find_ThrowsExceptionWithInvalidStartOrEnd(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] distances) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] distances | Improve this Doc View Source TestGraph(String, Int32, Int32[], Int32[], Int32[], Int32, Int32, Int32, Int32[]) Declaration protected void TestGraph(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] distances, int start, int end, int expectedDistance, int[] expectedPath) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] distances System.Int32 start System.Int32 end System.Int32 expectedDistance System.Int32 [] expectedPath Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistanceTree.BellmanFordShortestDistanceTreeFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistanceTree.BellmanFordShortestDistanceTreeFinderTests.html",
    "title": "Class BellmanFordShortestDistanceTreeFinderTests",
    "keywords": "Class BellmanFordShortestDistanceTreeFinderTests Inheritance System.Object ShortestDistanceTreeFinderTests BellmanFordShortestDistanceTreeFinderTests Inherited Members ShortestDistanceTreeFinderTests.GraphBuilder ShortestDistanceTreeFinderTests.SinglePathFinderBuilder ShortestDistanceTreeFinderTests.FinderBuilder ShortestDistanceTreeFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[]) ShortestDistanceTreeFinderTests.TestGraph(String, Int32, Int32[], Int32[], Int32[], Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistanceTree Assembly : MoreStructures.Tests.dll Syntax public class BellmanFordShortestDistanceTreeFinderTests : ShortestDistanceTreeFinderTests Constructors | Improve this Doc View Source BellmanFordShortestDistanceTreeFinderTests() Declaration public BellmanFordShortestDistanceTreeFinderTests() Methods | Improve this Doc View Source Find_IsCorrectWithNegativeCycles(String, Int32, Int32[], Int32[], Int32[]) Declaration public void Find_IsCorrectWithNegativeCycles(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] distances) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] distances | Improve this Doc View Source Find_IsCorrectWithNegativeValues(String, Int32, Int32[], Int32[], Int32[]) Declaration public void Find_IsCorrectWithNegativeValues(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] distances) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] distances Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistanceTree.DijkstraShortestDistanceTreeFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistanceTree.DijkstraShortestDistanceTreeFinderTests.html",
    "title": "Class DijkstraShortestDistanceTreeFinderTests",
    "keywords": "Class DijkstraShortestDistanceTreeFinderTests Inheritance System.Object ShortestDistanceTreeFinderTests DijkstraShortestDistanceTreeFinderTests Inherited Members ShortestDistanceTreeFinderTests.GraphBuilder ShortestDistanceTreeFinderTests.SinglePathFinderBuilder ShortestDistanceTreeFinderTests.FinderBuilder ShortestDistanceTreeFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[]) ShortestDistanceTreeFinderTests.TestGraph(String, Int32, Int32[], Int32[], Int32[], Int32) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistanceTree Assembly : MoreStructures.Tests.dll Syntax public class DijkstraShortestDistanceTreeFinderTests : ShortestDistanceTreeFinderTests Constructors | Improve this Doc View Source DijkstraShortestDistanceTreeFinderTests() Declaration public DijkstraShortestDistanceTreeFinderTests() Methods | Improve this Doc View Source Find_RaisesExceptionWhenNegativeEdgesAreEncountered(String, Int32, Int32[], Int32[], Int32[], Int32) Declaration public void Find_RaisesExceptionWhenNegativeEdgesAreEncountered(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] distances, int start) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] distances System.Int32 start Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistanceTree.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistanceTree.html",
    "title": "Namespace MoreStructures.Tests.Graphs.ShortestDistanceTree",
    "keywords": "Namespace MoreStructures.Tests.Graphs.ShortestDistanceTree Classes BellmanFordShortestDistanceTreeFinderTests DijkstraShortestDistanceTreeFinderTests ShortestDistanceTreeFinderTests"
  },
  "api/MoreStructures.Tests.Graphs.ShortestDistanceTree.ShortestDistanceTreeFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestDistanceTree.ShortestDistanceTreeFinderTests.html",
    "title": "Class ShortestDistanceTreeFinderTests",
    "keywords": "Class ShortestDistanceTreeFinderTests Inheritance System.Object ShortestDistanceTreeFinderTests BellmanFordShortestDistanceTreeFinderTests DijkstraShortestDistanceTreeFinderTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestDistanceTree Assembly : MoreStructures.Tests.dll Syntax public abstract class ShortestDistanceTreeFinderTests Constructors | Improve this Doc View Source ShortestDistanceTreeFinderTests(Func<Int32, IList<(Int32, Int32)>, IGraph>, Func<IShortestDistanceFinder>, Func<IShortestDistanceTreeFinder>) Declaration protected ShortestDistanceTreeFinderTests(Func<int, IList<(int, int)>, IGraph> graphBuilder, Func<IShortestDistanceFinder> singlePathFinderBuilder, Func<IShortestDistanceTreeFinder> finderBuilder) Parameters Type Name Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > graphBuilder Func < IShortestDistanceFinder > singlePathFinderBuilder Func < IShortestDistanceTreeFinder > finderBuilder Properties | Improve this Doc View Source FinderBuilder Declaration protected Func<IShortestDistanceTreeFinder> FinderBuilder { get; } Property Value Type Description Func < IShortestDistanceTreeFinder > | Improve this Doc View Source GraphBuilder Declaration protected Func<int, IList<(int, int)>, IGraph> GraphBuilder { get; } Property Value Type Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > | Improve this Doc View Source SinglePathFinderBuilder Declaration protected Func<IShortestDistanceFinder> SinglePathFinderBuilder { get; } Property Value Type Description Func < IShortestDistanceFinder > Methods | Improve this Doc View Source Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[]) Declaration public void Find_IsCorrect(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] distances) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] distances | Improve this Doc View Source TestGraph(String, Int32, Int32[], Int32[], Int32[], Int32) Declaration protected void TestGraph(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] distances, int start) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] distances System.Int32 start Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestPath.BfsBasedShortestPathFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestPath.BfsBasedShortestPathFinderTests.html",
    "title": "Class BfsBasedShortestPathFinderTests",
    "keywords": "Class BfsBasedShortestPathFinderTests Inheritance System.Object ShortestPathFinderTests BfsBasedShortestPathFinderTests Inherited Members ShortestPathFinderTests.GraphBuilder ShortestPathFinderTests.FinderBuilder ShortestPathFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32, Int32, Int32, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestPath Assembly : MoreStructures.Tests.dll Syntax public class BfsBasedShortestPathFinderTests : ShortestPathFinderTests Constructors | Improve this Doc View Source BfsBasedShortestPathFinderTests() Declaration public BfsBasedShortestPathFinderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.ShortestPath.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestPath.html",
    "title": "Namespace MoreStructures.Tests.Graphs.ShortestPath",
    "keywords": "Namespace MoreStructures.Tests.Graphs.ShortestPath Classes BfsBasedShortestPathFinderTests ShortestPathFinderTests"
  },
  "api/MoreStructures.Tests.Graphs.ShortestPath.ShortestPathFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.ShortestPath.ShortestPathFinderTests.html",
    "title": "Class ShortestPathFinderTests",
    "keywords": "Class ShortestPathFinderTests Inheritance System.Object ShortestPathFinderTests BfsBasedShortestPathFinderTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.ShortestPath Assembly : MoreStructures.Tests.dll Syntax public abstract class ShortestPathFinderTests Constructors | Improve this Doc View Source ShortestPathFinderTests(Func<Int32, IList<(Int32, Int32)>, IGraph>, Func<IShortestPathFinder>) Declaration protected ShortestPathFinderTests(Func<int, IList<(int, int)>, IGraph> graphBuilder, Func<IShortestPathFinder> finderBuilder) Parameters Type Name Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > graphBuilder Func < IShortestPathFinder > finderBuilder Properties | Improve this Doc View Source FinderBuilder Declaration protected Func<IShortestPathFinder> FinderBuilder { get; } Property Value Type Description Func < IShortestPathFinder > | Improve this Doc View Source GraphBuilder Declaration protected Func<int, IList<(int, int)>, IGraph> GraphBuilder { get; } Property Value Type Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > Methods | Improve this Doc View Source Find_IsCorrect(String, Int32, Int32[], Int32[], Int32, Int32, Int32, Int32[]) Declaration public void Find_IsCorrect(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int start, int end, int expectedDistance, int[] expectedPath) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 start System.Int32 end System.Int32 expectedDistance System.Int32 [] expectedPath Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.Sorting.AnyPathToSinkBasedTopologicalSortTests_WithEdgeListGraph.html": {
    "href": "api/MoreStructures.Tests.Graphs.Sorting.AnyPathToSinkBasedTopologicalSortTests_WithEdgeListGraph.html",
    "title": "Class AnyPathToSinkBasedTopologicalSortTests_WithEdgeListGraph",
    "keywords": "Class AnyPathToSinkBasedTopologicalSortTests_WithEdgeListGraph Inheritance System.Object TopologicalSortTests AnyPathToSinkBasedTopologicalSortTests_WithEdgeListGraph Inherited Members TopologicalSortTests.GraphBuilder TopologicalSortTests.Sorter TopologicalSortTests.Sort_IsCorrectWhenSingleSolutionIsPossible(String, Int32, Int32[], Int32[], Int32[]) TopologicalSortTests.Sort_IsCorrectWhenMultipleSolutionsArePossible(String, Int32, Int32[], Int32[]) TopologicalSortTests.Sort_RaisesExceptionWhenNoDag(String, Int32, Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.Sorting Assembly : MoreStructures.Tests.dll Syntax public class AnyPathToSinkBasedTopologicalSortTests_WithEdgeListGraph : TopologicalSortTests Constructors | Improve this Doc View Source AnyPathToSinkBasedTopologicalSortTests_WithEdgeListGraph() Declaration public AnyPathToSinkBasedTopologicalSortTests_WithEdgeListGraph() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.Sorting.DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyListGraph.html": {
    "href": "api/MoreStructures.Tests.Graphs.Sorting.DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyListGraph.html",
    "title": "Class DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyListGraph",
    "keywords": "Class DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyListGraph Inheritance System.Object TopologicalSortTests DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyListGraph Inherited Members TopologicalSortTests.GraphBuilder TopologicalSortTests.Sorter TopologicalSortTests.Sort_IsCorrectWhenSingleSolutionIsPossible(String, Int32, Int32[], Int32[], Int32[]) TopologicalSortTests.Sort_IsCorrectWhenMultipleSolutionsArePossible(String, Int32, Int32[], Int32[]) TopologicalSortTests.Sort_RaisesExceptionWhenNoDag(String, Int32, Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.Sorting Assembly : MoreStructures.Tests.dll Syntax public class DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyListGraph : TopologicalSortTests Constructors | Improve this Doc View Source DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyListGraph() Declaration public DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyListGraph() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.Sorting.DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyMatrixGraph.html": {
    "href": "api/MoreStructures.Tests.Graphs.Sorting.DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyMatrixGraph.html",
    "title": "Class DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyMatrixGraph",
    "keywords": "Class DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyMatrixGraph Inheritance System.Object TopologicalSortTests DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyMatrixGraph Inherited Members TopologicalSortTests.GraphBuilder TopologicalSortTests.Sorter TopologicalSortTests.Sort_IsCorrectWhenSingleSolutionIsPossible(String, Int32, Int32[], Int32[], Int32[]) TopologicalSortTests.Sort_IsCorrectWhenMultipleSolutionsArePossible(String, Int32, Int32[], Int32[]) TopologicalSortTests.Sort_RaisesExceptionWhenNoDag(String, Int32, Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.Sorting Assembly : MoreStructures.Tests.dll Syntax public class DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyMatrixGraph : TopologicalSortTests Constructors | Improve this Doc View Source DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyMatrixGraph() Declaration public DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyMatrixGraph() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.Sorting.DfsOnEachVertexSinkBasedTopologicalSortTests_WithEdgeListGraph.html": {
    "href": "api/MoreStructures.Tests.Graphs.Sorting.DfsOnEachVertexSinkBasedTopologicalSortTests_WithEdgeListGraph.html",
    "title": "Class DfsOnEachVertexSinkBasedTopologicalSortTests_WithEdgeListGraph",
    "keywords": "Class DfsOnEachVertexSinkBasedTopologicalSortTests_WithEdgeListGraph Inheritance System.Object TopologicalSortTests DfsOnEachVertexSinkBasedTopologicalSortTests_WithEdgeListGraph Inherited Members TopologicalSortTests.GraphBuilder TopologicalSortTests.Sorter TopologicalSortTests.Sort_IsCorrectWhenSingleSolutionIsPossible(String, Int32, Int32[], Int32[], Int32[]) TopologicalSortTests.Sort_IsCorrectWhenMultipleSolutionsArePossible(String, Int32, Int32[], Int32[]) TopologicalSortTests.Sort_RaisesExceptionWhenNoDag(String, Int32, Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.Sorting Assembly : MoreStructures.Tests.dll Syntax public class DfsOnEachVertexSinkBasedTopologicalSortTests_WithEdgeListGraph : TopologicalSortTests Constructors | Improve this Doc View Source DfsOnEachVertexSinkBasedTopologicalSortTests_WithEdgeListGraph() Declaration public DfsOnEachVertexSinkBasedTopologicalSortTests_WithEdgeListGraph() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.Sorting.html": {
    "href": "api/MoreStructures.Tests.Graphs.Sorting.html",
    "title": "Namespace MoreStructures.Tests.Graphs.Sorting",
    "keywords": "Namespace MoreStructures.Tests.Graphs.Sorting Classes AnyPathToSinkBasedTopologicalSortTests_WithEdgeListGraph DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyListGraph DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyMatrixGraph DfsOnEachVertexSinkBasedTopologicalSortTests_WithEdgeListGraph SingleDfsSinkBasedTopologicalSortTests_WithEdgeListGraph TopologicalSortTests"
  },
  "api/MoreStructures.Tests.Graphs.Sorting.SingleDfsSinkBasedTopologicalSortTests_WithEdgeListGraph.html": {
    "href": "api/MoreStructures.Tests.Graphs.Sorting.SingleDfsSinkBasedTopologicalSortTests_WithEdgeListGraph.html",
    "title": "Class SingleDfsSinkBasedTopologicalSortTests_WithEdgeListGraph",
    "keywords": "Class SingleDfsSinkBasedTopologicalSortTests_WithEdgeListGraph Inheritance System.Object TopologicalSortTests SingleDfsSinkBasedTopologicalSortTests_WithEdgeListGraph Inherited Members TopologicalSortTests.GraphBuilder TopologicalSortTests.Sorter TopologicalSortTests.Sort_IsCorrectWhenSingleSolutionIsPossible(String, Int32, Int32[], Int32[], Int32[]) TopologicalSortTests.Sort_IsCorrectWhenMultipleSolutionsArePossible(String, Int32, Int32[], Int32[]) TopologicalSortTests.Sort_RaisesExceptionWhenNoDag(String, Int32, Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.Sorting Assembly : MoreStructures.Tests.dll Syntax public class SingleDfsSinkBasedTopologicalSortTests_WithEdgeListGraph : TopologicalSortTests Constructors | Improve this Doc View Source SingleDfsSinkBasedTopologicalSortTests_WithEdgeListGraph() Declaration public SingleDfsSinkBasedTopologicalSortTests_WithEdgeListGraph() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.Sorting.TopologicalSortTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.Sorting.TopologicalSortTests.html",
    "title": "Class TopologicalSortTests",
    "keywords": "Class TopologicalSortTests Inheritance System.Object TopologicalSortTests AnyPathToSinkBasedTopologicalSortTests_WithEdgeListGraph DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyListGraph DfsOnEachVertexSinkBasedTopologicalSortTests_WithAdjacencyMatrixGraph DfsOnEachVertexSinkBasedTopologicalSortTests_WithEdgeListGraph SingleDfsSinkBasedTopologicalSortTests_WithEdgeListGraph Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.Sorting Assembly : MoreStructures.Tests.dll Syntax public abstract class TopologicalSortTests Constructors | Improve this Doc View Source TopologicalSortTests(Func<Int32, IList<(Int32, Int32)>, IGraph>, ITopologicalSort) Declaration protected TopologicalSortTests(Func<int, IList<(int, int)>, IGraph> graphBuilder, ITopologicalSort sorter) Parameters Type Name Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > graphBuilder ITopologicalSort sorter Properties | Improve this Doc View Source GraphBuilder Declaration protected Func<int, IList<(int, int)>, IGraph> GraphBuilder { get; } Property Value Type Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > | Improve this Doc View Source Sorter Declaration protected ITopologicalSort Sorter { get; } Property Value Type Description ITopologicalSort Methods | Improve this Doc View Source Sort_IsCorrectWhenMultipleSolutionsArePossible(String, Int32, Int32[], Int32[]) Declaration public void Sort_IsCorrectWhenMultipleSolutionsArePossible(string graphDescription, int numberOfVertices, int[] starts, int[] ends) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends | Improve this Doc View Source Sort_IsCorrectWhenSingleSolutionIsPossible(String, Int32, Int32[], Int32[], Int32[]) Declaration public void Sort_IsCorrectWhenSingleSolutionIsPossible(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] expectedTopologicalSort) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] expectedTopologicalSort | Improve this Doc View Source Sort_RaisesExceptionWhenNoDag(String, Int32, Int32[], Int32[]) Declaration public void Sort_RaisesExceptionWhenNoDag(string graphDescription, int numberOfVertices, int[] starts, int[] ends) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.StronglyConnectedComponents.html": {
    "href": "api/MoreStructures.Tests.Graphs.StronglyConnectedComponents.html",
    "title": "Namespace MoreStructures.Tests.Graphs.StronglyConnectedComponents",
    "keywords": "Namespace MoreStructures.Tests.Graphs.StronglyConnectedComponents Classes NaiveSccFinderTests SccFinderTests SinkSccBasedSccFinderTests"
  },
  "api/MoreStructures.Tests.Graphs.StronglyConnectedComponents.NaiveSccFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.StronglyConnectedComponents.NaiveSccFinderTests.html",
    "title": "Class NaiveSccFinderTests",
    "keywords": "Class NaiveSccFinderTests Inheritance System.Object SccFinderTests NaiveSccFinderTests Inherited Members SccFinderTests.GraphBuilder SccFinderTests.FinderBuilder SccFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.StronglyConnectedComponents Assembly : MoreStructures.Tests.dll Syntax public class NaiveSccFinderTests : SccFinderTests Constructors | Improve this Doc View Source NaiveSccFinderTests() Declaration public NaiveSccFinderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.StronglyConnectedComponents.SccFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.StronglyConnectedComponents.SccFinderTests.html",
    "title": "Class SccFinderTests",
    "keywords": "Class SccFinderTests Inheritance System.Object SccFinderTests NaiveSccFinderTests SinkSccBasedSccFinderTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.StronglyConnectedComponents Assembly : MoreStructures.Tests.dll Syntax public abstract class SccFinderTests Constructors | Improve this Doc View Source SccFinderTests(Func<Int32, IList<(Int32, Int32)>, IGraph>, Func<ISccFinder>) Declaration protected SccFinderTests(Func<int, IList<(int, int)>, IGraph> graphBuilder, Func<ISccFinder> finderBuilder) Parameters Type Name Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > graphBuilder Func < ISccFinder > finderBuilder Properties | Improve this Doc View Source FinderBuilder Declaration protected Func<ISccFinder> FinderBuilder { get; } Property Value Type Description Func < ISccFinder > | Improve this Doc View Source GraphBuilder Declaration protected Func<int, IList<(int, int)>, IGraph> GraphBuilder { get; } Property Value Type Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > Methods | Improve this Doc View Source Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[]) Declaration public void Find_IsCorrect(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] expectedScc) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] expectedScc Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.StronglyConnectedComponents.SinkSccBasedSccFinderTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.StronglyConnectedComponents.SinkSccBasedSccFinderTests.html",
    "title": "Class SinkSccBasedSccFinderTests",
    "keywords": "Class SinkSccBasedSccFinderTests Inheritance System.Object SccFinderTests SinkSccBasedSccFinderTests Inherited Members SccFinderTests.GraphBuilder SccFinderTests.FinderBuilder SccFinderTests.Find_IsCorrect(String, Int32, Int32[], Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.StronglyConnectedComponents Assembly : MoreStructures.Tests.dll Syntax public class SinkSccBasedSccFinderTests : SccFinderTests Constructors | Improve this Doc View Source SinkSccBasedSccFinderTests() Declaration public SinkSccBasedSccFinderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.Visitor.FullyIterativeHashSetBasedGraphVisitTests_WithEdgeListGraph.html": {
    "href": "api/MoreStructures.Tests.Graphs.Visitor.FullyIterativeHashSetBasedGraphVisitTests_WithEdgeListGraph.html",
    "title": "Class FullyIterativeHashSetBasedGraphVisitTests_WithEdgeListGraph",
    "keywords": "Class FullyIterativeHashSetBasedGraphVisitTests_WithEdgeListGraph Inheritance System.Object VisitStrategyTests FullyIterativeHashSetBasedGraphVisitTests_WithEdgeListGraph Inherited Members VisitStrategyTests.GraphBuilder VisitStrategyTests.VisitorBuilder VisitStrategyTests.DepthFirstSearchFromVertex_IsCorrect(String, Int32, Int32[], Int32[], Int32, Int32[], Int32[]) VisitStrategyTests.BreadthSearchFromVertex_IsCorrect(String, Int32, Int32[], Int32[], Int32, Int32[], Int32[]) VisitStrategyTests.BreadthSearchFromVertices_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) VisitStrategyTests.DepthFirstSearchOfGraph_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[]) VisitStrategyTests.ConnectedComponents_IsCorrect(String, Int32, Int32[], Int32[], Int32[]) VisitStrategyTests.VisitEvents_BasicChecksInDepthFirstSearch() VisitStrategyTests.VisitEvents_BasicChecksInConnectedComponents() VisitStrategyTests.VisitEvents_BasicChecksInVisit() VisitStrategyTests.VisitingVertex_InDepthFirstSearchOfGraphIsAccordingToOutput(String, Int32, Int32[], Int32[]) VisitStrategyTests.VisitingAndVisitedVertex_InDepthFirstSearchOfGraph_AreCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) VisitStrategyTests.AlreadyVisitedVertex_InDepthFirstSearchOfGraph_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.Visitor Assembly : MoreStructures.Tests.dll Syntax public class FullyIterativeHashSetBasedGraphVisitTests_WithEdgeListGraph : VisitStrategyTests Constructors | Improve this Doc View Source FullyIterativeHashSetBasedGraphVisitTests_WithEdgeListGraph() Declaration public FullyIterativeHashSetBasedGraphVisitTests_WithEdgeListGraph() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.Visitor.FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyListGraph.html": {
    "href": "api/MoreStructures.Tests.Graphs.Visitor.FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyListGraph.html",
    "title": "Class FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyListGraph",
    "keywords": "Class FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyListGraph Inheritance System.Object VisitStrategyTests FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyListGraph Inherited Members VisitStrategyTests.GraphBuilder VisitStrategyTests.VisitorBuilder VisitStrategyTests.DepthFirstSearchFromVertex_IsCorrect(String, Int32, Int32[], Int32[], Int32, Int32[], Int32[]) VisitStrategyTests.BreadthSearchFromVertex_IsCorrect(String, Int32, Int32[], Int32[], Int32, Int32[], Int32[]) VisitStrategyTests.BreadthSearchFromVertices_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) VisitStrategyTests.DepthFirstSearchOfGraph_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[]) VisitStrategyTests.ConnectedComponents_IsCorrect(String, Int32, Int32[], Int32[], Int32[]) VisitStrategyTests.VisitEvents_BasicChecksInDepthFirstSearch() VisitStrategyTests.VisitEvents_BasicChecksInConnectedComponents() VisitStrategyTests.VisitEvents_BasicChecksInVisit() VisitStrategyTests.VisitingVertex_InDepthFirstSearchOfGraphIsAccordingToOutput(String, Int32, Int32[], Int32[]) VisitStrategyTests.VisitingAndVisitedVertex_InDepthFirstSearchOfGraph_AreCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) VisitStrategyTests.AlreadyVisitedVertex_InDepthFirstSearchOfGraph_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.Visitor Assembly : MoreStructures.Tests.dll Syntax public class FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyListGraph : VisitStrategyTests Constructors | Improve this Doc View Source FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyListGraph() Declaration public FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyListGraph() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.Visitor.FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyMatrixGraph.html": {
    "href": "api/MoreStructures.Tests.Graphs.Visitor.FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyMatrixGraph.html",
    "title": "Class FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyMatrixGraph",
    "keywords": "Class FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyMatrixGraph Inheritance System.Object VisitStrategyTests FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyMatrixGraph Inherited Members VisitStrategyTests.GraphBuilder VisitStrategyTests.VisitorBuilder VisitStrategyTests.DepthFirstSearchFromVertex_IsCorrect(String, Int32, Int32[], Int32[], Int32, Int32[], Int32[]) VisitStrategyTests.BreadthSearchFromVertex_IsCorrect(String, Int32, Int32[], Int32[], Int32, Int32[], Int32[]) VisitStrategyTests.BreadthSearchFromVertices_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) VisitStrategyTests.DepthFirstSearchOfGraph_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[]) VisitStrategyTests.ConnectedComponents_IsCorrect(String, Int32, Int32[], Int32[], Int32[]) VisitStrategyTests.VisitEvents_BasicChecksInDepthFirstSearch() VisitStrategyTests.VisitEvents_BasicChecksInConnectedComponents() VisitStrategyTests.VisitEvents_BasicChecksInVisit() VisitStrategyTests.VisitingVertex_InDepthFirstSearchOfGraphIsAccordingToOutput(String, Int32, Int32[], Int32[]) VisitStrategyTests.VisitingAndVisitedVertex_InDepthFirstSearchOfGraph_AreCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) VisitStrategyTests.AlreadyVisitedVertex_InDepthFirstSearchOfGraph_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.Visitor Assembly : MoreStructures.Tests.dll Syntax public class FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyMatrixGraph : VisitStrategyTests Constructors | Improve this Doc View Source FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyMatrixGraph() Declaration public FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyMatrixGraph() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.Visitor.FullyRecursiveHashSetBasedGraphVisitTests_WithEdgeListGraph.html": {
    "href": "api/MoreStructures.Tests.Graphs.Visitor.FullyRecursiveHashSetBasedGraphVisitTests_WithEdgeListGraph.html",
    "title": "Class FullyRecursiveHashSetBasedGraphVisitTests_WithEdgeListGraph",
    "keywords": "Class FullyRecursiveHashSetBasedGraphVisitTests_WithEdgeListGraph Inheritance System.Object VisitStrategyTests FullyRecursiveHashSetBasedGraphVisitTests_WithEdgeListGraph Inherited Members VisitStrategyTests.GraphBuilder VisitStrategyTests.VisitorBuilder VisitStrategyTests.DepthFirstSearchFromVertex_IsCorrect(String, Int32, Int32[], Int32[], Int32, Int32[], Int32[]) VisitStrategyTests.BreadthSearchFromVertex_IsCorrect(String, Int32, Int32[], Int32[], Int32, Int32[], Int32[]) VisitStrategyTests.BreadthSearchFromVertices_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) VisitStrategyTests.DepthFirstSearchOfGraph_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[]) VisitStrategyTests.ConnectedComponents_IsCorrect(String, Int32, Int32[], Int32[], Int32[]) VisitStrategyTests.VisitEvents_BasicChecksInDepthFirstSearch() VisitStrategyTests.VisitEvents_BasicChecksInConnectedComponents() VisitStrategyTests.VisitEvents_BasicChecksInVisit() VisitStrategyTests.VisitingVertex_InDepthFirstSearchOfGraphIsAccordingToOutput(String, Int32, Int32[], Int32[]) VisitStrategyTests.VisitingAndVisitedVertex_InDepthFirstSearchOfGraph_AreCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) VisitStrategyTests.AlreadyVisitedVertex_InDepthFirstSearchOfGraph_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.Visitor Assembly : MoreStructures.Tests.dll Syntax public class FullyRecursiveHashSetBasedGraphVisitTests_WithEdgeListGraph : VisitStrategyTests Constructors | Improve this Doc View Source FullyRecursiveHashSetBasedGraphVisitTests_WithEdgeListGraph() Declaration public FullyRecursiveHashSetBasedGraphVisitTests_WithEdgeListGraph() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Graphs.Visitor.html": {
    "href": "api/MoreStructures.Tests.Graphs.Visitor.html",
    "title": "Namespace MoreStructures.Tests.Graphs.Visitor",
    "keywords": "Namespace MoreStructures.Tests.Graphs.Visitor Classes FullyIterativeHashSetBasedGraphVisitTests_WithEdgeListGraph FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyListGraph FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyMatrixGraph FullyRecursiveHashSetBasedGraphVisitTests_WithEdgeListGraph VisitStrategyTests"
  },
  "api/MoreStructures.Tests.Graphs.Visitor.VisitStrategyTests.html": {
    "href": "api/MoreStructures.Tests.Graphs.Visitor.VisitStrategyTests.html",
    "title": "Class VisitStrategyTests",
    "keywords": "Class VisitStrategyTests Inheritance System.Object VisitStrategyTests FullyIterativeHashSetBasedGraphVisitTests_WithEdgeListGraph FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyListGraph FullyRecursiveHashSetBasedGraphVisitTests_WithAdjacencyMatrixGraph FullyRecursiveHashSetBasedGraphVisitTests_WithEdgeListGraph Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Graphs.Visitor Assembly : MoreStructures.Tests.dll Syntax public abstract class VisitStrategyTests Constructors | Improve this Doc View Source VisitStrategyTests(Func<Int32, IList<(Int32, Int32)>, IGraph>, Func<Boolean, IVisitStrategy>) Declaration protected VisitStrategyTests(Func<int, IList<(int, int)>, IGraph> graphBuilder, Func<bool, IVisitStrategy> visitorBuilder) Parameters Type Name Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > graphBuilder Func < System.Boolean , IVisitStrategy > visitorBuilder Properties | Improve this Doc View Source GraphBuilder Declaration protected Func<int, IList<(int, int)>, IGraph> GraphBuilder { get; } Property Value Type Description Func < System.Int32 , IList < System.ValueTuple < System.Int32 , System.Int32 >>, IGraph > | Improve this Doc View Source VisitorBuilder Declaration protected Func<bool, IVisitStrategy> VisitorBuilder { get; } Property Value Type Description Func < System.Boolean , IVisitStrategy > Methods | Improve this Doc View Source AlreadyVisitedVertex_InDepthFirstSearchOfGraph_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) Declaration public void AlreadyVisitedVertex_InDepthFirstSearchOfGraph_IsCorrect(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] expectedAlreadyVisitedVertices, int[] expectedAlreadyVisitedConnectedComponents, int[] expectedPreviousVertices) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] expectedAlreadyVisitedVertices System.Int32 [] expectedAlreadyVisitedConnectedComponents System.Int32 [] expectedPreviousVertices | Improve this Doc View Source BreadthSearchFromVertex_IsCorrect(String, Int32, Int32[], Int32[], Int32, Int32[], Int32[]) Declaration public void BreadthSearchFromVertex_IsCorrect(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int start, int[] expectedDirectedGraphResult, int[] expectedUndirectedGraphResult) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 start System.Int32 [] expectedDirectedGraphResult System.Int32 [] expectedUndirectedGraphResult | Improve this Doc View Source BreadthSearchFromVertices_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) Declaration public void BreadthSearchFromVertices_IsCorrect(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] vertices, int[] expectedDirectedGraphResult, int[] expectedUndirectedGraphResult) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] vertices System.Int32 [] expectedDirectedGraphResult System.Int32 [] expectedUndirectedGraphResult | Improve this Doc View Source ConnectedComponents_IsCorrect(String, Int32, Int32[], Int32[], Int32[]) Declaration public void ConnectedComponents_IsCorrect(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] expectedUndirectedGraphResult) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] expectedUndirectedGraphResult | Improve this Doc View Source DepthFirstSearchFromVertex_IsCorrect(String, Int32, Int32[], Int32[], Int32, Int32[], Int32[]) Declaration public void DepthFirstSearchFromVertex_IsCorrect(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int start, int[] expectedDirectedGraphResult, int[] expectedUndirectedGraphResult) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 start System.Int32 [] expectedDirectedGraphResult System.Int32 [] expectedUndirectedGraphResult | Improve this Doc View Source DepthFirstSearchOfGraph_IsCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[]) Declaration public void DepthFirstSearchOfGraph_IsCorrect(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] expectedDirectedGraphResult, int[] expectedUndirectedGraphResult) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] expectedDirectedGraphResult System.Int32 [] expectedUndirectedGraphResult | Improve this Doc View Source VisitEvents_BasicChecksInConnectedComponents() Declaration public void VisitEvents_BasicChecksInConnectedComponents() | Improve this Doc View Source VisitEvents_BasicChecksInDepthFirstSearch() Declaration public void VisitEvents_BasicChecksInDepthFirstSearch() | Improve this Doc View Source VisitEvents_BasicChecksInVisit() Declaration public void VisitEvents_BasicChecksInVisit() | Improve this Doc View Source VisitingAndVisitedVertex_InDepthFirstSearchOfGraph_AreCorrect(String, Int32, Int32[], Int32[], Int32[], Int32[], Int32[]) Declaration public void VisitingAndVisitedVertex_InDepthFirstSearchOfGraph_AreCorrect(string graphDescription, int numberOfVertices, int[] starts, int[] ends, int[] expectedPreVisitValues, int[] expectedPostVisitValues, int[] expectedPreviousVertices) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends System.Int32 [] expectedPreVisitValues System.Int32 [] expectedPostVisitValues System.Int32 [] expectedPreviousVertices | Improve this Doc View Source VisitingVertex_InDepthFirstSearchOfGraphIsAccordingToOutput(String, Int32, Int32[], Int32[]) Declaration public void VisitingVertex_InDepthFirstSearchOfGraphIsAccordingToOutput(string graphDescription, int numberOfVertices, int[] starts, int[] ends) Parameters Type Name Description System.String graphDescription System.Int32 numberOfVertices System.Int32 [] starts System.Int32 [] ends Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.html": {
    "href": "api/MoreStructures.Tests.html",
    "title": "Namespace MoreStructures.Tests",
    "keywords": "Namespace MoreStructures.Tests Classes RotatedTextWithTerminatorTests StringIncludingTerminatorComparerTests TextWithTerminatorExtensionsTests TextWithTerminatorTests VirtuallyRotatedTextWithTerminatorTests"
  },
  "api/MoreStructures.Tests.KnuthMorrisPratt.Borders.BordersExtractionTests.html": {
    "href": "api/MoreStructures.Tests.KnuthMorrisPratt.Borders.BordersExtractionTests.html",
    "title": "Class BordersExtractionTests",
    "keywords": "Class BordersExtractionTests Inheritance System.Object BordersExtractionTests NaiveBordersExtractionTests PrefixFunctionBasedBorderExtractionTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.KnuthMorrisPratt.Borders Assembly : MoreStructures.Tests.dll Syntax public abstract class BordersExtractionTests Constructors | Improve this Doc View Source BordersExtractionTests(IBordersExtraction) Declaration protected BordersExtractionTests(IBordersExtraction bordersExtraction) Parameters Type Name Description IBordersExtraction bordersExtraction Properties | Improve this Doc View Source BordersExtraction Declaration protected IBordersExtraction BordersExtraction { get; } Property Value Type Description IBordersExtraction Methods | Improve this Doc View Source GetAllBordersByDescLength_IsCorrect(String[], String) Declaration public void GetAllBordersByDescLength_IsCorrect(string[] expectedResult, string text) Parameters Type Name Description System.String [] expectedResult System.String text Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.KnuthMorrisPratt.Borders.html": {
    "href": "api/MoreStructures.Tests.KnuthMorrisPratt.Borders.html",
    "title": "Namespace MoreStructures.Tests.KnuthMorrisPratt.Borders",
    "keywords": "Namespace MoreStructures.Tests.KnuthMorrisPratt.Borders Classes BordersExtractionTests NaiveBordersExtractionTests PrefixFunctionBasedBorderExtractionTests"
  },
  "api/MoreStructures.Tests.KnuthMorrisPratt.Borders.NaiveBordersExtractionTests.html": {
    "href": "api/MoreStructures.Tests.KnuthMorrisPratt.Borders.NaiveBordersExtractionTests.html",
    "title": "Class NaiveBordersExtractionTests",
    "keywords": "Class NaiveBordersExtractionTests Inheritance System.Object BordersExtractionTests NaiveBordersExtractionTests Inherited Members BordersExtractionTests.BordersExtraction BordersExtractionTests.GetAllBordersByDescLength_IsCorrect(String[], String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.KnuthMorrisPratt.Borders Assembly : MoreStructures.Tests.dll Syntax public class NaiveBordersExtractionTests : BordersExtractionTests Constructors | Improve this Doc View Source NaiveBordersExtractionTests() Declaration public NaiveBordersExtractionTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.KnuthMorrisPratt.Borders.PrefixFunctionBasedBorderExtractionTests.html": {
    "href": "api/MoreStructures.Tests.KnuthMorrisPratt.Borders.PrefixFunctionBasedBorderExtractionTests.html",
    "title": "Class PrefixFunctionBasedBorderExtractionTests",
    "keywords": "Class PrefixFunctionBasedBorderExtractionTests Inheritance System.Object BordersExtractionTests PrefixFunctionBasedBorderExtractionTests Inherited Members BordersExtractionTests.BordersExtraction BordersExtractionTests.GetAllBordersByDescLength_IsCorrect(String[], String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.KnuthMorrisPratt.Borders Assembly : MoreStructures.Tests.dll Syntax public class PrefixFunctionBasedBorderExtractionTests : BordersExtractionTests Constructors | Improve this Doc View Source PrefixFunctionBasedBorderExtractionTests() Declaration public PrefixFunctionBasedBorderExtractionTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.KnuthMorrisPratt.Matching.html": {
    "href": "api/MoreStructures.Tests.KnuthMorrisPratt.Matching.html",
    "title": "Namespace MoreStructures.Tests.KnuthMorrisPratt.Matching",
    "keywords": "Namespace MoreStructures.Tests.KnuthMorrisPratt.Matching Classes MatcherTests"
  },
  "api/MoreStructures.Tests.KnuthMorrisPratt.Matching.MatcherTests.html": {
    "href": "api/MoreStructures.Tests.KnuthMorrisPratt.Matching.MatcherTests.html",
    "title": "Class MatcherTests",
    "keywords": "Class MatcherTests Inheritance System.Object MatcherTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.KnuthMorrisPratt.Matching Assembly : MoreStructures.Tests.dll Syntax public class MatcherTests Methods | Improve this Doc View Source Match_DoesntValidateTextAndPatternAgainstSeparatorByDefault() Declaration public void Match_DoesntValidateTextAndPatternAgainstSeparatorByDefault() | Improve this Doc View Source Match_IsCorrect(String, String, Int32[]) Declaration public void Match_IsCorrect(string text, string pattern, int[] startIndexes) Parameters Type Name Description System.String text System.String pattern System.Int32 [] startIndexes | Improve this Doc View Source Match_RaisesExceptionWhenTextAndPatternAreValidatedAgainstSeparator() Declaration public void Match_RaisesExceptionWhenTextAndPatternAreValidatedAgainstSeparator() | Improve this Doc View Source Match_ReturnsNoMatchWithEmptyText() Declaration public void Match_ReturnsNoMatchWithEmptyText() | Improve this Doc View Source Match_ThrowsExceptionWithEmptyPattern() Declaration public void Match_ThrowsExceptionWithEmptyPattern() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.KnuthMorrisPratt.PrefixFunction.FastPrefixFunctionCalculatorTests.html": {
    "href": "api/MoreStructures.Tests.KnuthMorrisPratt.PrefixFunction.FastPrefixFunctionCalculatorTests.html",
    "title": "Class FastPrefixFunctionCalculatorTests",
    "keywords": "Class FastPrefixFunctionCalculatorTests Inheritance System.Object PrefixFunctionCalculatorTests FastPrefixFunctionCalculatorTests Inherited Members PrefixFunctionCalculatorTests.PrefixFunctionCalculator PrefixFunctionCalculatorTests.GetAllBordersByDescLength_IsCorrect(Int32[], String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.KnuthMorrisPratt.PrefixFunction Assembly : MoreStructures.Tests.dll Syntax public class FastPrefixFunctionCalculatorTests : PrefixFunctionCalculatorTests Constructors | Improve this Doc View Source FastPrefixFunctionCalculatorTests() Declaration public FastPrefixFunctionCalculatorTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.KnuthMorrisPratt.PrefixFunction.html": {
    "href": "api/MoreStructures.Tests.KnuthMorrisPratt.PrefixFunction.html",
    "title": "Namespace MoreStructures.Tests.KnuthMorrisPratt.PrefixFunction",
    "keywords": "Namespace MoreStructures.Tests.KnuthMorrisPratt.PrefixFunction Classes FastPrefixFunctionCalculatorTests NaivePrefixFunctionCalculatorTests PrefixFunctionCalculatorTests"
  },
  "api/MoreStructures.Tests.KnuthMorrisPratt.PrefixFunction.NaivePrefixFunctionCalculatorTests.html": {
    "href": "api/MoreStructures.Tests.KnuthMorrisPratt.PrefixFunction.NaivePrefixFunctionCalculatorTests.html",
    "title": "Class NaivePrefixFunctionCalculatorTests",
    "keywords": "Class NaivePrefixFunctionCalculatorTests Inheritance System.Object PrefixFunctionCalculatorTests NaivePrefixFunctionCalculatorTests Inherited Members PrefixFunctionCalculatorTests.PrefixFunctionCalculator PrefixFunctionCalculatorTests.GetAllBordersByDescLength_IsCorrect(Int32[], String) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.KnuthMorrisPratt.PrefixFunction Assembly : MoreStructures.Tests.dll Syntax public class NaivePrefixFunctionCalculatorTests : PrefixFunctionCalculatorTests Constructors | Improve this Doc View Source NaivePrefixFunctionCalculatorTests() Declaration public NaivePrefixFunctionCalculatorTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.KnuthMorrisPratt.PrefixFunction.PrefixFunctionCalculatorTests.html": {
    "href": "api/MoreStructures.Tests.KnuthMorrisPratt.PrefixFunction.PrefixFunctionCalculatorTests.html",
    "title": "Class PrefixFunctionCalculatorTests",
    "keywords": "Class PrefixFunctionCalculatorTests Inheritance System.Object PrefixFunctionCalculatorTests FastPrefixFunctionCalculatorTests NaivePrefixFunctionCalculatorTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.KnuthMorrisPratt.PrefixFunction Assembly : MoreStructures.Tests.dll Syntax public abstract class PrefixFunctionCalculatorTests Constructors | Improve this Doc View Source PrefixFunctionCalculatorTests(IPrefixFunctionCalculator) Declaration protected PrefixFunctionCalculatorTests(IPrefixFunctionCalculator prefixFunctionCalculator) Parameters Type Name Description IPrefixFunctionCalculator prefixFunctionCalculator Properties | Improve this Doc View Source PrefixFunctionCalculator Declaration protected IPrefixFunctionCalculator PrefixFunctionCalculator { get; } Property Value Type Description IPrefixFunctionCalculator Methods | Improve this Doc View Source GetAllBordersByDescLength_IsCorrect(Int32[], String) Declaration public void GetAllBordersByDescLength_IsCorrect(int[] expectedResult, string text) Parameters Type Name Description System.Int32 [] expectedResult System.String text Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Counting.DictionaryBasedOccurrencesCounterTests.html": {
    "href": "api/MoreStructures.Tests.Lists.Counting.DictionaryBasedOccurrencesCounterTests.html",
    "title": "Class DictionaryBasedOccurrencesCounterTests",
    "keywords": "Class DictionaryBasedOccurrencesCounterTests Inheritance System.Object OccurrencesCounterTests DictionaryBasedOccurrencesCounterTests Inherited Members OccurrencesCounterTests.Counter OccurrencesCounterTests.Count_IsCorrect(OccurrencesCounterTests.TestCaseId) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Lists.Counting Assembly : MoreStructures.Tests.dll Syntax public class DictionaryBasedOccurrencesCounterTests : OccurrencesCounterTests Constructors | Improve this Doc View Source DictionaryBasedOccurrencesCounterTests() Declaration public DictionaryBasedOccurrencesCounterTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Counting.html": {
    "href": "api/MoreStructures.Tests.Lists.Counting.html",
    "title": "Namespace MoreStructures.Tests.Lists.Counting",
    "keywords": "Namespace MoreStructures.Tests.Lists.Counting Classes DictionaryBasedOccurrencesCounterTests OccurrencesCounterTests Enums OccurrencesCounterTests.TestCaseId"
  },
  "api/MoreStructures.Tests.Lists.Counting.OccurrencesCounterTests.html": {
    "href": "api/MoreStructures.Tests.Lists.Counting.OccurrencesCounterTests.html",
    "title": "Class OccurrencesCounterTests",
    "keywords": "Class OccurrencesCounterTests Inheritance System.Object OccurrencesCounterTests DictionaryBasedOccurrencesCounterTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Lists.Counting Assembly : MoreStructures.Tests.dll Syntax public abstract class OccurrencesCounterTests Constructors | Improve this Doc View Source OccurrencesCounterTests(IOccurrencesCounter) Declaration protected OccurrencesCounterTests(IOccurrencesCounter counter) Parameters Type Name Description IOccurrencesCounter counter Properties | Improve this Doc View Source Counter Declaration protected IOccurrencesCounter Counter { get; } Property Value Type Description IOccurrencesCounter Methods | Improve this Doc View Source Count_IsCorrect(OccurrencesCounterTests.TestCaseId) Declaration public void Count_IsCorrect(OccurrencesCounterTests.TestCaseId testCaseId) Parameters Type Name Description OccurrencesCounterTests.TestCaseId testCaseId Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Counting.OccurrencesCounterTests.TestCaseId.html": {
    "href": "api/MoreStructures.Tests.Lists.Counting.OccurrencesCounterTests.TestCaseId.html",
    "title": "Enum OccurrencesCounterTests.TestCaseId",
    "keywords": "Enum OccurrencesCounterTests.TestCaseId Namespace : MoreStructures.Tests.Lists.Counting Assembly : MoreStructures.Tests.dll Syntax public enum TestCaseId Fields Name Description EmptyArray EmptyEnumerable MultipleRepetedElements SingletonArray SingletonList ThreeElementsWithOneRepetitions ThreeElementsWithoutRepetitions ThreeElementsWithTwoRepetitions Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, OccurrencesCounterTests.TestCaseId>(TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Searching.BinarySearchTests.html": {
    "href": "api/MoreStructures.Tests.Lists.Searching.BinarySearchTests.html",
    "title": "Class BinarySearchTests",
    "keywords": "Class BinarySearchTests Inheritance System.Object SearchTests BinarySearchTests Inherited Members SearchTests.Search SearchTests.SearchMethods_OnListOfIntegers(SearchTests.TestCaseId) SearchTests.SearchMethods_OnCharArray(SearchTests.TestCaseId) SearchTests.SearchMethods_OnString(SearchTests.TestCaseId) SearchTests.SearchMethods_ItemtNotFound(Int32) SearchTests.SearchMethods_ItemNotFound_OnStrings() SearchTests.SearchMethods_OnEmptyEnumerable() SearchTests.SearchMethods_FromIndexAndToIndexNull() SearchTests.First_MiddleIndexOverflow() SearchTests.First_OutOfBoundsIndexes() SearchTests.Last_OutOfBoundsIndexes() SearchTests.FirstAll_OutOfBoundsIndexes() SearchTests.Nth_RaisesExceptionOnInvalidOccurrenceRank() SearchTests.FirstAll_OnCustomIntervals() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Lists.Searching Assembly : MoreStructures.Tests.dll Syntax public class BinarySearchTests : SearchTests Constructors | Improve this Doc View Source BinarySearchTests() Declaration public BinarySearchTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Searching.html": {
    "href": "api/MoreStructures.Tests.Lists.Searching.html",
    "title": "Namespace MoreStructures.Tests.Lists.Searching",
    "keywords": "Namespace MoreStructures.Tests.Lists.Searching Classes BinarySearchTests LinearSearchTests SearchTests Enums SearchTests.TestCaseId"
  },
  "api/MoreStructures.Tests.Lists.Searching.LinearSearchTests.html": {
    "href": "api/MoreStructures.Tests.Lists.Searching.LinearSearchTests.html",
    "title": "Class LinearSearchTests",
    "keywords": "Class LinearSearchTests Inheritance System.Object SearchTests LinearSearchTests Inherited Members SearchTests.Search SearchTests.SearchMethods_OnListOfIntegers(SearchTests.TestCaseId) SearchTests.SearchMethods_OnCharArray(SearchTests.TestCaseId) SearchTests.SearchMethods_OnString(SearchTests.TestCaseId) SearchTests.SearchMethods_ItemtNotFound(Int32) SearchTests.SearchMethods_ItemNotFound_OnStrings() SearchTests.SearchMethods_OnEmptyEnumerable() SearchTests.SearchMethods_FromIndexAndToIndexNull() SearchTests.First_MiddleIndexOverflow() SearchTests.First_OutOfBoundsIndexes() SearchTests.Last_OutOfBoundsIndexes() SearchTests.FirstAll_OutOfBoundsIndexes() SearchTests.Nth_RaisesExceptionOnInvalidOccurrenceRank() SearchTests.FirstAll_OnCustomIntervals() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Lists.Searching Assembly : MoreStructures.Tests.dll Syntax public class LinearSearchTests : SearchTests Constructors | Improve this Doc View Source LinearSearchTests() Declaration public LinearSearchTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Searching.SearchTests.html": {
    "href": "api/MoreStructures.Tests.Lists.Searching.SearchTests.html",
    "title": "Class SearchTests",
    "keywords": "Class SearchTests Inheritance System.Object SearchTests BinarySearchTests LinearSearchTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Lists.Searching Assembly : MoreStructures.Tests.dll Syntax public abstract class SearchTests Constructors | Improve this Doc View Source SearchTests(ISearch) Declaration protected SearchTests(ISearch search) Parameters Type Name Description ISearch search Properties | Improve this Doc View Source Search Declaration protected ISearch Search { get; } Property Value Type Description ISearch Methods | Improve this Doc View Source First_MiddleIndexOverflow() Declaration public void First_MiddleIndexOverflow() | Improve this Doc View Source First_OutOfBoundsIndexes() Declaration public void First_OutOfBoundsIndexes() | Improve this Doc View Source FirstAll_OnCustomIntervals() Declaration public void FirstAll_OnCustomIntervals() | Improve this Doc View Source FirstAll_OutOfBoundsIndexes() Declaration public void FirstAll_OutOfBoundsIndexes() | Improve this Doc View Source Last_OutOfBoundsIndexes() Declaration public void Last_OutOfBoundsIndexes() | Improve this Doc View Source Nth_RaisesExceptionOnInvalidOccurrenceRank() Declaration public void Nth_RaisesExceptionOnInvalidOccurrenceRank() | Improve this Doc View Source SearchMethods_FromIndexAndToIndexNull() Declaration public void SearchMethods_FromIndexAndToIndexNull() | Improve this Doc View Source SearchMethods_ItemNotFound_OnStrings() Declaration public void SearchMethods_ItemNotFound_OnStrings() | Improve this Doc View Source SearchMethods_ItemtNotFound(Int32) Declaration public void SearchMethods_ItemtNotFound(int length) Parameters Type Name Description System.Int32 length | Improve this Doc View Source SearchMethods_OnCharArray(SearchTests.TestCaseId) Declaration public void SearchMethods_OnCharArray(SearchTests.TestCaseId testCaseId) Parameters Type Name Description SearchTests.TestCaseId testCaseId | Improve this Doc View Source SearchMethods_OnEmptyEnumerable() Declaration public void SearchMethods_OnEmptyEnumerable() | Improve this Doc View Source SearchMethods_OnListOfIntegers(SearchTests.TestCaseId) Declaration public void SearchMethods_OnListOfIntegers(SearchTests.TestCaseId testCaseId) Parameters Type Name Description SearchTests.TestCaseId testCaseId | Improve this Doc View Source SearchMethods_OnString(SearchTests.TestCaseId) Declaration public void SearchMethods_OnString(SearchTests.TestCaseId testCaseId) Parameters Type Name Description SearchTests.TestCaseId testCaseId Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Searching.SearchTests.TestCaseId.html": {
    "href": "api/MoreStructures.Tests.Lists.Searching.SearchTests.TestCaseId.html",
    "title": "Enum SearchTests.TestCaseId",
    "keywords": "Enum SearchTests.TestCaseId Namespace : MoreStructures.Tests.Lists.Searching Assembly : MoreStructures.Tests.dll Syntax public enum TestCaseId Fields Name Description ArrayOfChars1 ListOfIntegers1 ListOfIntegers2 String1 String2 Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, SearchTests.TestCaseId>(TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Sorting.ExtensionsTests.html": {
    "href": "api/MoreStructures.Tests.Lists.Sorting.ExtensionsTests.html",
    "title": "Class ExtensionsTests",
    "keywords": "Class ExtensionsTests Inheritance System.Object ExtensionsTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Lists.Sorting Assembly : MoreStructures.Tests.dll Syntax public class ExtensionsTests Methods | Improve this Doc View Source IsSorted_WithComparable_IsCorrectWithBool() Declaration public void IsSorted_WithComparable_IsCorrectWithBool() | Improve this Doc View Source IsSorted_WithComparable_IsCorrectWithChars() Declaration public void IsSorted_WithComparable_IsCorrectWithChars() | Improve this Doc View Source IsSorted_WithComparable_IsCorrectWithNumbers() Declaration public void IsSorted_WithComparable_IsCorrectWithNumbers() | Improve this Doc View Source IsSorted_WithComparer_IsCorrect() Declaration public void IsSorted_WithComparer_IsCorrect() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Sorting.HeapSortTests.html": {
    "href": "api/MoreStructures.Tests.Lists.Sorting.HeapSortTests.html",
    "title": "Class HeapSortTests",
    "keywords": "Class HeapSortTests Inheritance System.Object InPlaceSortingTests HeapSortTests Inherited Members InPlaceSortingTests.Sorter InPlaceSortingTests.Sort_PlaceItemsInOrder() InPlaceSortingTests.Sort_WorksWithDuplicates() InPlaceSortingTests.Sort_WorksWithEmptyList() InPlaceSortingTests.Sort_WorksWithSingletonList() InPlaceSortingTests.Sort_WorksWithReferenceTypes() InPlaceSortingTests.Sort_WorksWithValueTypes() InPlaceSortingTests.Sort_TakesIntoAccountComparerWithReferenceTypes() InPlaceSortingTests.Sort_TakesIntoAccountComparerWithValueTypes() InPlaceSortingTests.CompareTo(InPlaceSortingTests.ValType1) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Lists.Sorting Assembly : MoreStructures.Tests.dll Syntax public class HeapSortTests : InPlaceSortingTests Constructors | Improve this Doc View Source HeapSortTests() Declaration public HeapSortTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Sorting.html": {
    "href": "api/MoreStructures.Tests.Lists.Sorting.html",
    "title": "Namespace MoreStructures.Tests.Lists.Sorting",
    "keywords": "Namespace MoreStructures.Tests.Lists.Sorting Classes ExtensionsTests HeapSortTests InPlaceSortingTests InsertionSortTests SelectionSortTests ShellSortTests_GapsCiura01 ShellSortTests_GapsPositiveInts ShellSortTests_GapsPowerOf2 ShellSortTests_GapsSedgewick82"
  },
  "api/MoreStructures.Tests.Lists.Sorting.InPlaceSortingTests.html": {
    "href": "api/MoreStructures.Tests.Lists.Sorting.InPlaceSortingTests.html",
    "title": "Class InPlaceSortingTests",
    "keywords": "Class InPlaceSortingTests Inheritance System.Object InPlaceSortingTests HeapSortTests InsertionSortTests SelectionSortTests ShellSortTests_GapsCiura01 ShellSortTests_GapsPositiveInts ShellSortTests_GapsPowerOf2 ShellSortTests_GapsSedgewick82 Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Lists.Sorting Assembly : MoreStructures.Tests.dll Syntax public abstract class InPlaceSortingTests Constructors | Improve this Doc View Source InPlaceSortingTests(Func<IInPlaceSorting>) Declaration protected InPlaceSortingTests(Func<IInPlaceSorting> sorter) Parameters Type Name Description Func < IInPlaceSorting > sorter Properties | Improve this Doc View Source Sorter Declaration protected Func<IInPlaceSorting> Sorter { get; } Property Value Type Description Func < IInPlaceSorting > Methods | Improve this Doc View Source CompareTo(InPlaceSortingTests.ValType1) Declaration public int CompareTo(InPlaceSortingTests.ValType1 other) Parameters Type Name Description MoreStructures.Tests.Lists.Sorting.InPlaceSortingTests.ValType1 other Returns Type Description System.Int32 | Improve this Doc View Source Sort_PlaceItemsInOrder() Declaration public void Sort_PlaceItemsInOrder() | Improve this Doc View Source Sort_TakesIntoAccountComparerWithReferenceTypes() Declaration public void Sort_TakesIntoAccountComparerWithReferenceTypes() | Improve this Doc View Source Sort_TakesIntoAccountComparerWithValueTypes() Declaration public void Sort_TakesIntoAccountComparerWithValueTypes() | Improve this Doc View Source Sort_WorksWithDuplicates() Declaration public void Sort_WorksWithDuplicates() | Improve this Doc View Source Sort_WorksWithEmptyList() Declaration public void Sort_WorksWithEmptyList() | Improve this Doc View Source Sort_WorksWithReferenceTypes() Declaration public void Sort_WorksWithReferenceTypes() | Improve this Doc View Source Sort_WorksWithSingletonList() Declaration public void Sort_WorksWithSingletonList() | Improve this Doc View Source Sort_WorksWithValueTypes() Declaration public void Sort_WorksWithValueTypes() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Sorting.InsertionSortTests.html": {
    "href": "api/MoreStructures.Tests.Lists.Sorting.InsertionSortTests.html",
    "title": "Class InsertionSortTests",
    "keywords": "Class InsertionSortTests Inheritance System.Object InPlaceSortingTests InsertionSortTests Inherited Members InPlaceSortingTests.Sorter InPlaceSortingTests.Sort_PlaceItemsInOrder() InPlaceSortingTests.Sort_WorksWithDuplicates() InPlaceSortingTests.Sort_WorksWithEmptyList() InPlaceSortingTests.Sort_WorksWithSingletonList() InPlaceSortingTests.Sort_WorksWithReferenceTypes() InPlaceSortingTests.Sort_WorksWithValueTypes() InPlaceSortingTests.Sort_TakesIntoAccountComparerWithReferenceTypes() InPlaceSortingTests.Sort_TakesIntoAccountComparerWithValueTypes() InPlaceSortingTests.CompareTo(InPlaceSortingTests.ValType1) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Lists.Sorting Assembly : MoreStructures.Tests.dll Syntax public class InsertionSortTests : InPlaceSortingTests Constructors | Improve this Doc View Source InsertionSortTests() Declaration public InsertionSortTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Sorting.SelectionSortTests.html": {
    "href": "api/MoreStructures.Tests.Lists.Sorting.SelectionSortTests.html",
    "title": "Class SelectionSortTests",
    "keywords": "Class SelectionSortTests Inheritance System.Object InPlaceSortingTests SelectionSortTests Inherited Members InPlaceSortingTests.Sorter InPlaceSortingTests.Sort_PlaceItemsInOrder() InPlaceSortingTests.Sort_WorksWithDuplicates() InPlaceSortingTests.Sort_WorksWithEmptyList() InPlaceSortingTests.Sort_WorksWithSingletonList() InPlaceSortingTests.Sort_WorksWithReferenceTypes() InPlaceSortingTests.Sort_WorksWithValueTypes() InPlaceSortingTests.Sort_TakesIntoAccountComparerWithReferenceTypes() InPlaceSortingTests.Sort_TakesIntoAccountComparerWithValueTypes() InPlaceSortingTests.CompareTo(InPlaceSortingTests.ValType1) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Lists.Sorting Assembly : MoreStructures.Tests.dll Syntax public class SelectionSortTests : InPlaceSortingTests Constructors | Improve this Doc View Source SelectionSortTests() Declaration public SelectionSortTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Sorting.ShellSortTests_GapsCiura01.html": {
    "href": "api/MoreStructures.Tests.Lists.Sorting.ShellSortTests_GapsCiura01.html",
    "title": "Class ShellSortTests_GapsCiura01",
    "keywords": "Class ShellSortTests_GapsCiura01 Inheritance System.Object InPlaceSortingTests ShellSortTests_GapsCiura01 Inherited Members InPlaceSortingTests.Sorter InPlaceSortingTests.Sort_PlaceItemsInOrder() InPlaceSortingTests.Sort_WorksWithDuplicates() InPlaceSortingTests.Sort_WorksWithEmptyList() InPlaceSortingTests.Sort_WorksWithSingletonList() InPlaceSortingTests.Sort_WorksWithReferenceTypes() InPlaceSortingTests.Sort_WorksWithValueTypes() InPlaceSortingTests.Sort_TakesIntoAccountComparerWithReferenceTypes() InPlaceSortingTests.Sort_TakesIntoAccountComparerWithValueTypes() InPlaceSortingTests.CompareTo(InPlaceSortingTests.ValType1) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Lists.Sorting Assembly : MoreStructures.Tests.dll Syntax public class ShellSortTests_GapsCiura01 : InPlaceSortingTests Constructors | Improve this Doc View Source ShellSortTests_GapsCiura01() Declaration public ShellSortTests_GapsCiura01() Methods | Improve this Doc View Source Sequence() Declaration public static IEnumerable<int> Sequence() Returns Type Description IEnumerable < System.Int32 > Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Sorting.ShellSortTests_GapsPositiveInts.html": {
    "href": "api/MoreStructures.Tests.Lists.Sorting.ShellSortTests_GapsPositiveInts.html",
    "title": "Class ShellSortTests_GapsPositiveInts",
    "keywords": "Class ShellSortTests_GapsPositiveInts Inheritance System.Object InPlaceSortingTests ShellSortTests_GapsPositiveInts Inherited Members InPlaceSortingTests.Sorter InPlaceSortingTests.Sort_PlaceItemsInOrder() InPlaceSortingTests.Sort_WorksWithDuplicates() InPlaceSortingTests.Sort_WorksWithEmptyList() InPlaceSortingTests.Sort_WorksWithSingletonList() InPlaceSortingTests.Sort_WorksWithReferenceTypes() InPlaceSortingTests.Sort_WorksWithValueTypes() InPlaceSortingTests.Sort_TakesIntoAccountComparerWithReferenceTypes() InPlaceSortingTests.Sort_TakesIntoAccountComparerWithValueTypes() InPlaceSortingTests.CompareTo(InPlaceSortingTests.ValType1) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Lists.Sorting Assembly : MoreStructures.Tests.dll Syntax public class ShellSortTests_GapsPositiveInts : InPlaceSortingTests Constructors | Improve this Doc View Source ShellSortTests_GapsPositiveInts() Declaration public ShellSortTests_GapsPositiveInts() Methods | Improve this Doc View Source Sequence() Declaration public static IEnumerable<int> Sequence() Returns Type Description IEnumerable < System.Int32 > Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Sorting.ShellSortTests_GapsPowerOf2.html": {
    "href": "api/MoreStructures.Tests.Lists.Sorting.ShellSortTests_GapsPowerOf2.html",
    "title": "Class ShellSortTests_GapsPowerOf2",
    "keywords": "Class ShellSortTests_GapsPowerOf2 Inheritance System.Object InPlaceSortingTests ShellSortTests_GapsPowerOf2 Inherited Members InPlaceSortingTests.Sorter InPlaceSortingTests.Sort_PlaceItemsInOrder() InPlaceSortingTests.Sort_WorksWithDuplicates() InPlaceSortingTests.Sort_WorksWithEmptyList() InPlaceSortingTests.Sort_WorksWithSingletonList() InPlaceSortingTests.Sort_WorksWithReferenceTypes() InPlaceSortingTests.Sort_WorksWithValueTypes() InPlaceSortingTests.Sort_TakesIntoAccountComparerWithReferenceTypes() InPlaceSortingTests.Sort_TakesIntoAccountComparerWithValueTypes() InPlaceSortingTests.CompareTo(InPlaceSortingTests.ValType1) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Lists.Sorting Assembly : MoreStructures.Tests.dll Syntax public class ShellSortTests_GapsPowerOf2 : InPlaceSortingTests Constructors | Improve this Doc View Source ShellSortTests_GapsPowerOf2() Declaration public ShellSortTests_GapsPowerOf2() Methods | Improve this Doc View Source Sequence() Declaration public static IEnumerable<int> Sequence() Returns Type Description IEnumerable < System.Int32 > Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Lists.Sorting.ShellSortTests_GapsSedgewick82.html": {
    "href": "api/MoreStructures.Tests.Lists.Sorting.ShellSortTests_GapsSedgewick82.html",
    "title": "Class ShellSortTests_GapsSedgewick82",
    "keywords": "Class ShellSortTests_GapsSedgewick82 Inheritance System.Object InPlaceSortingTests ShellSortTests_GapsSedgewick82 Inherited Members InPlaceSortingTests.Sorter InPlaceSortingTests.Sort_PlaceItemsInOrder() InPlaceSortingTests.Sort_WorksWithDuplicates() InPlaceSortingTests.Sort_WorksWithEmptyList() InPlaceSortingTests.Sort_WorksWithSingletonList() InPlaceSortingTests.Sort_WorksWithReferenceTypes() InPlaceSortingTests.Sort_WorksWithValueTypes() InPlaceSortingTests.Sort_TakesIntoAccountComparerWithReferenceTypes() InPlaceSortingTests.Sort_TakesIntoAccountComparerWithValueTypes() InPlaceSortingTests.CompareTo(InPlaceSortingTests.ValType1) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Lists.Sorting Assembly : MoreStructures.Tests.dll Syntax public class ShellSortTests_GapsSedgewick82 : InPlaceSortingTests Constructors | Improve this Doc View Source ShellSortTests_GapsSedgewick82() Declaration public ShellSortTests_GapsSedgewick82() Methods | Improve this Doc View Source Sequence() Declaration public static IEnumerable<int> Sequence() Returns Type Description IEnumerable < System.Int32 > Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues..html": {
    "href": "api/MoreStructures.Tests.PriorityQueues..html",
    "title": "Class",
    "keywords": "Class Inheritance System.Object Implements System.IEquatable < MoreStructures.Tests.PriorityQueues. > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues Assembly : MoreStructures.Tests.dll Syntax public class : IEquatable<> Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.ArrayList.ArrayListPriorityQueueTests_AsBasicQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.ArrayList.ArrayListPriorityQueueTests_AsBasicQueue.html",
    "title": "Class ArrayListPriorityQueueTests_AsBasicQueue",
    "keywords": "Class ArrayListPriorityQueueTests_AsBasicQueue Inheritance System.Object PriorityQueueTests ArrayListPriorityQueueTests_AsBasicQueue Inherited Members PriorityQueueTests.IntQueueBuilder PriorityQueueTests.RefTypeQueueBuilder PriorityQueueTests.ValTypeQueueBuilder PriorityQueueTests.Pop_RaisesExceptionOnEmptyQueue() PriorityQueueTests.Pop_RespectsPriorities() PriorityQueueTests.PushAndPop_WorkWithReferenceTypes() PriorityQueueTests.PushAndPop_WorkWithValueTypes() PriorityQueueTests.PushAndPop_WithPrioritiesPartiallyOrdered() PriorityQueueTests.PushAndPop_ComplexScenario() PriorityQueueTests.PushAndPop_AllPermutations() PriorityQueueTests.PushAndPop_AreStable() PriorityQueueTests.Count_IsCorrect() PriorityQueueTests.Count_IsCorrectWithDuplicates() PriorityQueueTests.Peek_RaisesExceptionOnEmptyQueue() PriorityQueueTests.Peek_IsCorrect() PriorityQueueTests.Peek_DoesntChangeTheContentOfTheQueue() PriorityQueueTests.GetEnumerator_RetrievesAllItemsAccordingToPriority() PriorityQueueTests.GetEnumerator_DoesntAlterQueueWhenIterated() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.ArrayList Assembly : MoreStructures.Tests.dll Syntax public class ArrayListPriorityQueueTests_AsBasicQueue : PriorityQueueTests Constructors | Improve this Doc View Source ArrayListPriorityQueueTests_AsBasicQueue() Declaration public ArrayListPriorityQueueTests_AsBasicQueue() Methods | Improve this Doc View Source Ctor_WithEnumerable() Declaration public void Ctor_WithEnumerable() | Improve this Doc View Source Ctor_WithProvidedList() Declaration public void Ctor_WithProvidedList() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.ArrayList.ArrayListPriorityQueueTests_AsMergeableAndUpdatable.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.ArrayList.ArrayListPriorityQueueTests_AsMergeableAndUpdatable.html",
    "title": "Class ArrayListPriorityQueueTests_AsMergeableAndUpdatable",
    "keywords": "Class ArrayListPriorityQueueTests_AsMergeableAndUpdatable Inheritance System.Object MergeablePriorityQueueTests < ArrayListPriorityQueue < System.Int32 >> MergeableAndUpdatablePriorityQueueTests < ArrayListPriorityQueue < System.Int32 >> ArrayListPriorityQueueTests_AsMergeableAndUpdatable Inherited Members MergeableAndUpdatablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_QueueUpdatesKeepWorkingOnSourceAfter() MergeableAndUpdatablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_QueueUpdatesKeepWorkingOnTargetAfter() MergeableAndUpdatablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Clear_QueueUpdatesKeepWorkingAfter() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.IntBuilder MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_WithEmptySource() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_WithEmptyTarget() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_ContainsElementsFromBothQueues() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_WorksWithManyItems() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_WorksWithDuplicates() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_CanBeRepeatedWithMultipleTargets() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_RemoveAllItemsFromTheTarget() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_TargetIsUsableAfterMerge() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_TargetChangesDontInterfereWithSource() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_KeepsPushTimestampsUniqueWithinEras() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_IfSamePriorityTakeItemsComingFromTargetAfterSource() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_IfDifferentPrioritySortByItNoMatterIfFromSourceOrTarget() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_IfSamePriorityTakeItemsAfterMergeAfterTarget() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_SourceOfAMergeCanBeUsedAsTargetOfAnotherMerge() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Merge_TargetOfAMergeCanBeUsedAsSourceOfAnotherMerge() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.MergeAndClear_ComplexScenario() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Clear_WipesAllItemsOut() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Clear_QueueKeepsWorkingAfter() MergeablePriorityQueueTests<ArrayListPriorityQueue<Int32>>.Clear_DoesntResetPushTimestamps() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.ArrayList Assembly : MoreStructures.Tests.dll Syntax public class ArrayListPriorityQueueTests_AsMergeableAndUpdatable : MergeableAndUpdatablePriorityQueueTests<ArrayListPriorityQueue<int>> Constructors | Improve this Doc View Source ArrayListPriorityQueueTests_AsMergeableAndUpdatable() Declaration public ArrayListPriorityQueueTests_AsMergeableAndUpdatable() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.ArrayList.ArrayListPriorityQueueTests_AsPeekKthQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.ArrayList.ArrayListPriorityQueueTests_AsPeekKthQueue.html",
    "title": "Class ArrayListPriorityQueueTests_AsPeekKthQueue",
    "keywords": "Class ArrayListPriorityQueueTests_AsPeekKthQueue Inheritance System.Object PeekKthPriorityQueueTests ArrayListPriorityQueueTests_AsPeekKthQueue Inherited Members PeekKthPriorityQueueTests.IntQueueBuilder PeekKthPriorityQueueTests.PeekKth_ThrowsExceptionOnInvalidK() PeekKthPriorityQueueTests.PeekKth_IsCorrect() PeekKthPriorityQueueTests.PeekKth_IsStable() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.ArrayList Assembly : MoreStructures.Tests.dll Syntax public class ArrayListPriorityQueueTests_AsPeekKthQueue : PeekKthPriorityQueueTests Constructors | Improve this Doc View Source ArrayListPriorityQueueTests_AsPeekKthQueue() Declaration public ArrayListPriorityQueueTests_AsPeekKthQueue() Methods | Improve this Doc View Source PeekKth_WorstQuickFindPivot() Declaration public void PeekKth_WorstQuickFindPivot() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.ArrayList.ArrayListPriorityQueueTests_AsUpdatableQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.ArrayList.ArrayListPriorityQueueTests_AsUpdatableQueue.html",
    "title": "Class ArrayListPriorityQueueTests_AsUpdatableQueue",
    "keywords": "Class ArrayListPriorityQueueTests_AsUpdatableQueue Inheritance System.Object UpdatablePriorityQueueTests ArrayListPriorityQueueTests_AsUpdatableQueue Inherited Members UpdatablePriorityQueueTests.IntUpdatableQueueBuilder UpdatablePriorityQueueTests.RefTypeUpdatableQueueBuilder UpdatablePriorityQueueTests.ValTypeUpdatableQueueBuilder UpdatablePriorityQueueTests.GetPrioritiesOf_FirstIsCorrect() UpdatablePriorityQueueTests.GetPrioritiesOf_IsCorrect() UpdatablePriorityQueueTests.UpdatePriority_RaisesExceptionOnItemNonPresent() UpdatablePriorityQueueTests.UpdatePriority_IsStableWithInt() UpdatablePriorityQueueTests.UpdatePriority_IsStableWithReferenceTypes() UpdatablePriorityQueueTests.UpdatePriority_IsCorrect() UpdatablePriorityQueueTests.UpdatePriority_AllPermutations() UpdatablePriorityQueueTests.UpdatePriority_LongChainOfUpdates(Int32[], Int32[], Int32[]) UpdatablePriorityQueueTests.UpdatePriority_StalePushTimestamps() UpdatablePriorityQueueTests.UpdatePriority_WorksWhenNewPriorityIsTheSame() UpdatablePriorityQueueTests.Remove_IsCorrect() UpdatablePriorityQueueTests.Remove_WorksWithReferenceTypes() UpdatablePriorityQueueTests.Remove_WorksWithValueTypes() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.ArrayList Assembly : MoreStructures.Tests.dll Syntax public class ArrayListPriorityQueueTests_AsUpdatableQueue : UpdatablePriorityQueueTests Constructors | Improve this Doc View Source ArrayListPriorityQueueTests_AsUpdatableQueue() Declaration public ArrayListPriorityQueueTests_AsUpdatableQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.ArrayList.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.ArrayList.html",
    "title": "Namespace MoreStructures.Tests.PriorityQueues.ArrayList",
    "keywords": "Namespace MoreStructures.Tests.PriorityQueues.ArrayList Classes ArrayListPriorityQueueTests_AsBasicQueue ArrayListPriorityQueueTests_AsMergeableAndUpdatable ArrayListPriorityQueueTests_AsPeekKthQueue ArrayListPriorityQueueTests_AsUpdatableQueue"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.BinaryHeapListWrapperTests.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.BinaryHeapListWrapperTests.html",
    "title": "Class BinaryHeapListWrapperTests",
    "keywords": "Class BinaryHeapListWrapperTests Inheritance System.Object BinaryHeapListWrapperTests BinaryHeapListWrapperTests_HeapAtTheBeginning BinaryHeapListWrapperTests_HeapAtTheEnd Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinaryHeap Assembly : MoreStructures.Tests.dll Syntax public abstract class BinaryHeapListWrapperTests Constructors | Improve this Doc View Source BinaryHeapListWrapperTests(Boolean, Int32) Declaration protected BinaryHeapListWrapperTests(bool storeHeapAtTheEnd, int indexDelta) Parameters Type Name Description System.Boolean storeHeapAtTheEnd System.Int32 indexDelta Methods | Improve this Doc View Source Clear_JustResetsHeapCountWithReadOnlyLists() Declaration public void Clear_JustResetsHeapCountWithReadOnlyLists() | Improve this Doc View Source Clear_WipesAllItemsOutWithNonReadOnlyLists() Declaration public void Clear_WipesAllItemsOutWithNonReadOnlyLists() | Improve this Doc View Source Ctor_DoesntTouchItemsInBufferArea() Declaration public void Ctor_DoesntTouchItemsInBufferArea() | Improve this Doc View Source Ctor_EnforcesHeapCountToBeAtMostListCount() Declaration public void Ctor_EnforcesHeapCountToBeAtMostListCount() | Improve this Doc View Source Ctor_EnforcesIndexDeltaToBeAtMostListCount() Declaration public void Ctor_EnforcesIndexDeltaToBeAtMostListCount() | Improve this Doc View Source Ctor_RestoresHeapPropertyWithSpecifiedComparer() Declaration public void Ctor_RestoresHeapPropertyWithSpecifiedComparer() | Improve this Doc View Source Ctor_WorksOnEmptyHeap() Declaration public void Ctor_WorksOnEmptyHeap() | Improve this Doc View Source GetEnumerator_EnumeratesItemsFromHeapAndBuffer() Declaration public void GetEnumerator_EnumeratesItemsFromHeapAndBuffer() | Improve this Doc View Source HeapCount_IsIncreasedWhenPushMakesRoomInTheList() Declaration public void HeapCount_IsIncreasedWhenPushMakesRoomInTheList() | Improve this Doc View Source HeapCount_IsInstantiatedToTheSpecifiedValue() Declaration public void HeapCount_IsInstantiatedToTheSpecifiedValue() | Improve this Doc View Source HeapCount_IsNotChangedByPeekOrPeekKth() Declaration public void HeapCount_IsNotChangedByPeekOrPeekKth() | Improve this Doc View Source HeapCount_IsUpdatedOnPushAndPop() Declaration public void HeapCount_IsUpdatedOnPushAndPop() | Improve this Doc View Source Index_AccessItemsFromHeapAndBuffer() Declaration public void Index_AccessItemsFromHeapAndBuffer() | Improve this Doc View Source Pop_DoesntLoseItems() Declaration public void Pop_DoesntLoseItems() | Improve this Doc View Source Push_BeyondListCountRaisesException_WhenHeapAtTheEnd() Declaration public void Push_BeyondListCountRaisesException_WhenHeapAtTheEnd() | Improve this Doc View Source Push_BeyondListCountUpdatesListCount_WhenHeapAtTheBeginning() Declaration public void Push_BeyondListCountUpdatesListCount_WhenHeapAtTheBeginning() | Improve this Doc View Source RaiseEvents_AreInvoked() Declaration public void RaiseEvents_AreInvoked() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.BinaryHeapListWrapperTests_HeapAtTheBeginning.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.BinaryHeapListWrapperTests_HeapAtTheBeginning.html",
    "title": "Class BinaryHeapListWrapperTests_HeapAtTheBeginning",
    "keywords": "Class BinaryHeapListWrapperTests_HeapAtTheBeginning Inheritance System.Object BinaryHeapListWrapperTests BinaryHeapListWrapperTests_HeapAtTheBeginning Inherited Members BinaryHeapListWrapperTests.Ctor_EnforcesHeapCountToBeAtMostListCount() BinaryHeapListWrapperTests.Ctor_EnforcesIndexDeltaToBeAtMostListCount() BinaryHeapListWrapperTests.Ctor_RestoresHeapPropertyWithSpecifiedComparer() BinaryHeapListWrapperTests.Ctor_WorksOnEmptyHeap() BinaryHeapListWrapperTests.Ctor_DoesntTouchItemsInBufferArea() BinaryHeapListWrapperTests.RaiseEvents_AreInvoked() BinaryHeapListWrapperTests.HeapCount_IsInstantiatedToTheSpecifiedValue() BinaryHeapListWrapperTests.HeapCount_IsUpdatedOnPushAndPop() BinaryHeapListWrapperTests.HeapCount_IsIncreasedWhenPushMakesRoomInTheList() BinaryHeapListWrapperTests.HeapCount_IsNotChangedByPeekOrPeekKth() BinaryHeapListWrapperTests.Push_BeyondListCountUpdatesListCount_WhenHeapAtTheBeginning() BinaryHeapListWrapperTests.Push_BeyondListCountRaisesException_WhenHeapAtTheEnd() BinaryHeapListWrapperTests.Pop_DoesntLoseItems() BinaryHeapListWrapperTests.Clear_WipesAllItemsOutWithNonReadOnlyLists() BinaryHeapListWrapperTests.Clear_JustResetsHeapCountWithReadOnlyLists() BinaryHeapListWrapperTests.Index_AccessItemsFromHeapAndBuffer() BinaryHeapListWrapperTests.GetEnumerator_EnumeratesItemsFromHeapAndBuffer() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinaryHeap Assembly : MoreStructures.Tests.dll Syntax public class BinaryHeapListWrapperTests_HeapAtTheBeginning : BinaryHeapListWrapperTests Constructors | Improve this Doc View Source BinaryHeapListWrapperTests_HeapAtTheBeginning() Declaration public BinaryHeapListWrapperTests_HeapAtTheBeginning() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.BinaryHeapListWrapperTests_HeapAtTheEnd.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.BinaryHeapListWrapperTests_HeapAtTheEnd.html",
    "title": "Class BinaryHeapListWrapperTests_HeapAtTheEnd",
    "keywords": "Class BinaryHeapListWrapperTests_HeapAtTheEnd Inheritance System.Object BinaryHeapListWrapperTests BinaryHeapListWrapperTests_HeapAtTheEnd Inherited Members BinaryHeapListWrapperTests.Ctor_EnforcesHeapCountToBeAtMostListCount() BinaryHeapListWrapperTests.Ctor_EnforcesIndexDeltaToBeAtMostListCount() BinaryHeapListWrapperTests.Ctor_RestoresHeapPropertyWithSpecifiedComparer() BinaryHeapListWrapperTests.Ctor_WorksOnEmptyHeap() BinaryHeapListWrapperTests.Ctor_DoesntTouchItemsInBufferArea() BinaryHeapListWrapperTests.RaiseEvents_AreInvoked() BinaryHeapListWrapperTests.HeapCount_IsInstantiatedToTheSpecifiedValue() BinaryHeapListWrapperTests.HeapCount_IsUpdatedOnPushAndPop() BinaryHeapListWrapperTests.HeapCount_IsIncreasedWhenPushMakesRoomInTheList() BinaryHeapListWrapperTests.HeapCount_IsNotChangedByPeekOrPeekKth() BinaryHeapListWrapperTests.Push_BeyondListCountUpdatesListCount_WhenHeapAtTheBeginning() BinaryHeapListWrapperTests.Push_BeyondListCountRaisesException_WhenHeapAtTheEnd() BinaryHeapListWrapperTests.Pop_DoesntLoseItems() BinaryHeapListWrapperTests.Clear_WipesAllItemsOutWithNonReadOnlyLists() BinaryHeapListWrapperTests.Clear_JustResetsHeapCountWithReadOnlyLists() BinaryHeapListWrapperTests.Index_AccessItemsFromHeapAndBuffer() BinaryHeapListWrapperTests.GetEnumerator_EnumeratesItemsFromHeapAndBuffer() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinaryHeap Assembly : MoreStructures.Tests.dll Syntax public class BinaryHeapListWrapperTests_HeapAtTheEnd : BinaryHeapListWrapperTests Constructors | Improve this Doc View Source BinaryHeapListWrapperTests_HeapAtTheEnd() Declaration public BinaryHeapListWrapperTests_HeapAtTheEnd() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.BinaryHeapListWrapperTests_WithIndexDelta.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.BinaryHeapListWrapperTests_WithIndexDelta.html",
    "title": "Class BinaryHeapListWrapperTests_WithIndexDelta",
    "keywords": "Class BinaryHeapListWrapperTests_WithIndexDelta Inheritance System.Object BinaryHeapListWrapperTests_WithIndexDelta Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinaryHeap Assembly : MoreStructures.Tests.dll Syntax public class BinaryHeapListWrapperTests_WithIndexDelta Methods | Improve this Doc View Source IndexDelta_IsTakenIntoAccountWhenHeapAtTheBeginning() Declaration public void IndexDelta_IsTakenIntoAccountWhenHeapAtTheBeginning() | Improve this Doc View Source IndexDelta_IsTakenIntoAccountWhenHeapAtTheEnd() Declaration public void IndexDelta_IsTakenIntoAccountWhenHeapAtTheEnd() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.BinaryHeapPriorityQueueTests_AsBasicQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.BinaryHeapPriorityQueueTests_AsBasicQueue.html",
    "title": "Class BinaryHeapPriorityQueueTests_AsBasicQueue",
    "keywords": "Class BinaryHeapPriorityQueueTests_AsBasicQueue Inheritance System.Object PriorityQueueTests BinaryHeapPriorityQueueTests_AsBasicQueue Inherited Members PriorityQueueTests.IntQueueBuilder PriorityQueueTests.RefTypeQueueBuilder PriorityQueueTests.ValTypeQueueBuilder PriorityQueueTests.Pop_RaisesExceptionOnEmptyQueue() PriorityQueueTests.Pop_RespectsPriorities() PriorityQueueTests.PushAndPop_WorkWithReferenceTypes() PriorityQueueTests.PushAndPop_WorkWithValueTypes() PriorityQueueTests.PushAndPop_WithPrioritiesPartiallyOrdered() PriorityQueueTests.PushAndPop_ComplexScenario() PriorityQueueTests.PushAndPop_AllPermutations() PriorityQueueTests.PushAndPop_AreStable() PriorityQueueTests.Count_IsCorrect() PriorityQueueTests.Count_IsCorrectWithDuplicates() PriorityQueueTests.Peek_RaisesExceptionOnEmptyQueue() PriorityQueueTests.Peek_IsCorrect() PriorityQueueTests.Peek_DoesntChangeTheContentOfTheQueue() PriorityQueueTests.GetEnumerator_RetrievesAllItemsAccordingToPriority() PriorityQueueTests.GetEnumerator_DoesntAlterQueueWhenIterated() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinaryHeap Assembly : MoreStructures.Tests.dll Syntax public class BinaryHeapPriorityQueueTests_AsBasicQueue : PriorityQueueTests Constructors | Improve this Doc View Source BinaryHeapPriorityQueueTests_AsBasicQueue() Declaration public BinaryHeapPriorityQueueTests_AsBasicQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.BinaryHeapPriorityQueueTests_AsMergeable.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.BinaryHeapPriorityQueueTests_AsMergeable.html",
    "title": "Class BinaryHeapPriorityQueueTests_AsMergeable",
    "keywords": "Class BinaryHeapPriorityQueueTests_AsMergeable Inheritance System.Object MergeablePriorityQueueTests < BinaryHeapPriorityQueue < System.Int32 >> BinaryHeapPriorityQueueTests_AsMergeable Inherited Members MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.IntBuilder MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_WithEmptySource() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_WithEmptyTarget() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_ContainsElementsFromBothQueues() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_WorksWithManyItems() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_WorksWithDuplicates() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_CanBeRepeatedWithMultipleTargets() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_RemoveAllItemsFromTheTarget() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_TargetIsUsableAfterMerge() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_TargetChangesDontInterfereWithSource() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_KeepsPushTimestampsUniqueWithinEras() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_IfSamePriorityTakeItemsComingFromTargetAfterSource() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_IfDifferentPrioritySortByItNoMatterIfFromSourceOrTarget() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_IfSamePriorityTakeItemsAfterMergeAfterTarget() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_SourceOfAMergeCanBeUsedAsTargetOfAnotherMerge() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Merge_TargetOfAMergeCanBeUsedAsSourceOfAnotherMerge() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.MergeAndClear_ComplexScenario() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Clear_WipesAllItemsOut() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Clear_QueueKeepsWorkingAfter() MergeablePriorityQueueTests<BinaryHeapPriorityQueue<Int32>>.Clear_DoesntResetPushTimestamps() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinaryHeap Assembly : MoreStructures.Tests.dll Syntax public class BinaryHeapPriorityQueueTests_AsMergeable : MergeablePriorityQueueTests<BinaryHeapPriorityQueue<int>> Constructors | Improve this Doc View Source BinaryHeapPriorityQueueTests_AsMergeable() Declaration public BinaryHeapPriorityQueueTests_AsMergeable() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.BinaryHeapPriorityQueueTests_AsPeekKthQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.BinaryHeapPriorityQueueTests_AsPeekKthQueue.html",
    "title": "Class BinaryHeapPriorityQueueTests_AsPeekKthQueue",
    "keywords": "Class BinaryHeapPriorityQueueTests_AsPeekKthQueue Inheritance System.Object PeekKthPriorityQueueTests BinaryHeapPriorityQueueTests_AsPeekKthQueue Inherited Members PeekKthPriorityQueueTests.IntQueueBuilder PeekKthPriorityQueueTests.PeekKth_ThrowsExceptionOnInvalidK() PeekKthPriorityQueueTests.PeekKth_IsCorrect() PeekKthPriorityQueueTests.PeekKth_IsStable() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinaryHeap Assembly : MoreStructures.Tests.dll Syntax public class BinaryHeapPriorityQueueTests_AsPeekKthQueue : PeekKthPriorityQueueTests Constructors | Improve this Doc View Source BinaryHeapPriorityQueueTests_AsPeekKthQueue() Declaration public BinaryHeapPriorityQueueTests_AsPeekKthQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.html",
    "title": "Namespace MoreStructures.Tests.PriorityQueues.BinaryHeap",
    "keywords": "Namespace MoreStructures.Tests.PriorityQueues.BinaryHeap Classes BinaryHeapListWrapperTests BinaryHeapListWrapperTests_HeapAtTheBeginning BinaryHeapListWrapperTests_HeapAtTheEnd BinaryHeapListWrapperTests_WithIndexDelta BinaryHeapPriorityQueueTests_AsBasicQueue BinaryHeapPriorityQueueTests_AsMergeable BinaryHeapPriorityQueueTests_AsPeekKthQueue UpdatableBinaryHeapPriorityQueueTests_AsBasicQueue UpdatableBinaryHeapPriorityQueueTests_AsMergeableAndUpdatableQueue UpdatableBinaryHeapPriorityQueueTests_AsUpdatableQueue"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.UpdatableBinaryHeapPriorityQueueTests_AsBasicQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.UpdatableBinaryHeapPriorityQueueTests_AsBasicQueue.html",
    "title": "Class UpdatableBinaryHeapPriorityQueueTests_AsBasicQueue",
    "keywords": "Class UpdatableBinaryHeapPriorityQueueTests_AsBasicQueue Inheritance System.Object PriorityQueueTests UpdatableBinaryHeapPriorityQueueTests_AsBasicQueue Inherited Members PriorityQueueTests.IntQueueBuilder PriorityQueueTests.RefTypeQueueBuilder PriorityQueueTests.ValTypeQueueBuilder PriorityQueueTests.Pop_RaisesExceptionOnEmptyQueue() PriorityQueueTests.Pop_RespectsPriorities() PriorityQueueTests.PushAndPop_WorkWithReferenceTypes() PriorityQueueTests.PushAndPop_WorkWithValueTypes() PriorityQueueTests.PushAndPop_WithPrioritiesPartiallyOrdered() PriorityQueueTests.PushAndPop_ComplexScenario() PriorityQueueTests.PushAndPop_AllPermutations() PriorityQueueTests.PushAndPop_AreStable() PriorityQueueTests.Count_IsCorrect() PriorityQueueTests.Count_IsCorrectWithDuplicates() PriorityQueueTests.Peek_RaisesExceptionOnEmptyQueue() PriorityQueueTests.Peek_IsCorrect() PriorityQueueTests.Peek_DoesntChangeTheContentOfTheQueue() PriorityQueueTests.GetEnumerator_RetrievesAllItemsAccordingToPriority() PriorityQueueTests.GetEnumerator_DoesntAlterQueueWhenIterated() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinaryHeap Assembly : MoreStructures.Tests.dll Syntax public class UpdatableBinaryHeapPriorityQueueTests_AsBasicQueue : PriorityQueueTests Constructors | Improve this Doc View Source UpdatableBinaryHeapPriorityQueueTests_AsBasicQueue() Declaration public UpdatableBinaryHeapPriorityQueueTests_AsBasicQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.UpdatableBinaryHeapPriorityQueueTests_AsMergeableAndUpdatableQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.UpdatableBinaryHeapPriorityQueueTests_AsMergeableAndUpdatableQueue.html",
    "title": "Class UpdatableBinaryHeapPriorityQueueTests_AsMergeableAndUpdatableQueue",
    "keywords": "Class UpdatableBinaryHeapPriorityQueueTests_AsMergeableAndUpdatableQueue Inheritance System.Object MergeablePriorityQueueTests < UpdatableBinaryHeapPriorityQueue < System.Int32 >> MergeableAndUpdatablePriorityQueueTests < UpdatableBinaryHeapPriorityQueue < System.Int32 >> UpdatableBinaryHeapPriorityQueueTests_AsMergeableAndUpdatableQueue Inherited Members MergeableAndUpdatablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_QueueUpdatesKeepWorkingOnSourceAfter() MergeableAndUpdatablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_QueueUpdatesKeepWorkingOnTargetAfter() MergeableAndUpdatablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Clear_QueueUpdatesKeepWorkingAfter() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.IntBuilder MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_WithEmptySource() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_WithEmptyTarget() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_ContainsElementsFromBothQueues() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_WorksWithManyItems() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_WorksWithDuplicates() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_CanBeRepeatedWithMultipleTargets() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_RemoveAllItemsFromTheTarget() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_TargetIsUsableAfterMerge() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_TargetChangesDontInterfereWithSource() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_KeepsPushTimestampsUniqueWithinEras() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_IfSamePriorityTakeItemsComingFromTargetAfterSource() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_IfDifferentPrioritySortByItNoMatterIfFromSourceOrTarget() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_IfSamePriorityTakeItemsAfterMergeAfterTarget() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_SourceOfAMergeCanBeUsedAsTargetOfAnotherMerge() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Merge_TargetOfAMergeCanBeUsedAsSourceOfAnotherMerge() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.MergeAndClear_ComplexScenario() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Clear_WipesAllItemsOut() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Clear_QueueKeepsWorkingAfter() MergeablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<Int32>>.Clear_DoesntResetPushTimestamps() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinaryHeap Assembly : MoreStructures.Tests.dll Syntax public class UpdatableBinaryHeapPriorityQueueTests_AsMergeableAndUpdatableQueue : MergeableAndUpdatablePriorityQueueTests<UpdatableBinaryHeapPriorityQueue<int>> Constructors | Improve this Doc View Source UpdatableBinaryHeapPriorityQueueTests_AsMergeableAndUpdatableQueue() Declaration public UpdatableBinaryHeapPriorityQueueTests_AsMergeableAndUpdatableQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.UpdatableBinaryHeapPriorityQueueTests_AsUpdatableQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinaryHeap.UpdatableBinaryHeapPriorityQueueTests_AsUpdatableQueue.html",
    "title": "Class UpdatableBinaryHeapPriorityQueueTests_AsUpdatableQueue",
    "keywords": "Class UpdatableBinaryHeapPriorityQueueTests_AsUpdatableQueue Inheritance System.Object UpdatablePriorityQueueTests UpdatableBinaryHeapPriorityQueueTests_AsUpdatableQueue Inherited Members UpdatablePriorityQueueTests.IntUpdatableQueueBuilder UpdatablePriorityQueueTests.RefTypeUpdatableQueueBuilder UpdatablePriorityQueueTests.ValTypeUpdatableQueueBuilder UpdatablePriorityQueueTests.GetPrioritiesOf_FirstIsCorrect() UpdatablePriorityQueueTests.GetPrioritiesOf_IsCorrect() UpdatablePriorityQueueTests.UpdatePriority_RaisesExceptionOnItemNonPresent() UpdatablePriorityQueueTests.UpdatePriority_IsStableWithInt() UpdatablePriorityQueueTests.UpdatePriority_IsStableWithReferenceTypes() UpdatablePriorityQueueTests.UpdatePriority_IsCorrect() UpdatablePriorityQueueTests.UpdatePriority_AllPermutations() UpdatablePriorityQueueTests.UpdatePriority_LongChainOfUpdates(Int32[], Int32[], Int32[]) UpdatablePriorityQueueTests.UpdatePriority_StalePushTimestamps() UpdatablePriorityQueueTests.UpdatePriority_WorksWhenNewPriorityIsTheSame() UpdatablePriorityQueueTests.Remove_IsCorrect() UpdatablePriorityQueueTests.Remove_WorksWithReferenceTypes() UpdatablePriorityQueueTests.Remove_WorksWithValueTypes() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinaryHeap Assembly : MoreStructures.Tests.dll Syntax public class UpdatableBinaryHeapPriorityQueueTests_AsUpdatableQueue : UpdatablePriorityQueueTests Constructors | Improve this Doc View Source UpdatableBinaryHeapPriorityQueueTests_AsUpdatableQueue() Declaration public UpdatableBinaryHeapPriorityQueueTests_AsUpdatableQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueueTests_AsBasicQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueueTests_AsBasicQueue.html",
    "title": "Class BinomialHeapPriorityQueueTests_AsBasicQueue",
    "keywords": "Class BinomialHeapPriorityQueueTests_AsBasicQueue Inheritance System.Object PriorityQueueTests BinomialHeapPriorityQueueTests_AsBasicQueue Inherited Members PriorityQueueTests.IntQueueBuilder PriorityQueueTests.RefTypeQueueBuilder PriorityQueueTests.ValTypeQueueBuilder PriorityQueueTests.Pop_RaisesExceptionOnEmptyQueue() PriorityQueueTests.Pop_RespectsPriorities() PriorityQueueTests.PushAndPop_WorkWithReferenceTypes() PriorityQueueTests.PushAndPop_WorkWithValueTypes() PriorityQueueTests.PushAndPop_WithPrioritiesPartiallyOrdered() PriorityQueueTests.PushAndPop_ComplexScenario() PriorityQueueTests.PushAndPop_AllPermutations() PriorityQueueTests.PushAndPop_AreStable() PriorityQueueTests.Count_IsCorrect() PriorityQueueTests.Count_IsCorrectWithDuplicates() PriorityQueueTests.Peek_RaisesExceptionOnEmptyQueue() PriorityQueueTests.Peek_IsCorrect() PriorityQueueTests.Peek_DoesntChangeTheContentOfTheQueue() PriorityQueueTests.GetEnumerator_RetrievesAllItemsAccordingToPriority() PriorityQueueTests.GetEnumerator_DoesntAlterQueueWhenIterated() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinomialHeap Assembly : MoreStructures.Tests.dll Syntax public class BinomialHeapPriorityQueueTests_AsBasicQueue : PriorityQueueTests Constructors | Improve this Doc View Source BinomialHeapPriorityQueueTests_AsBasicQueue() Declaration public BinomialHeapPriorityQueueTests_AsBasicQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueueTests_AsMergeableQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.BinomialHeapPriorityQueueTests_AsMergeableQueue.html",
    "title": "Class BinomialHeapPriorityQueueTests_AsMergeableQueue",
    "keywords": "Class BinomialHeapPriorityQueueTests_AsMergeableQueue Inheritance System.Object MergeablePriorityQueueTests < BinomialHeapPriorityQueue < System.Int32 >> BinomialHeapPriorityQueueTests_AsMergeableQueue Inherited Members MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.IntBuilder MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_WithEmptySource() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_WithEmptyTarget() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_ContainsElementsFromBothQueues() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_WorksWithManyItems() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_WorksWithDuplicates() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_CanBeRepeatedWithMultipleTargets() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_RemoveAllItemsFromTheTarget() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_TargetIsUsableAfterMerge() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_TargetChangesDontInterfereWithSource() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_KeepsPushTimestampsUniqueWithinEras() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_IfSamePriorityTakeItemsComingFromTargetAfterSource() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_IfDifferentPrioritySortByItNoMatterIfFromSourceOrTarget() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_IfSamePriorityTakeItemsAfterMergeAfterTarget() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_SourceOfAMergeCanBeUsedAsTargetOfAnotherMerge() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Merge_TargetOfAMergeCanBeUsedAsSourceOfAnotherMerge() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.MergeAndClear_ComplexScenario() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Clear_WipesAllItemsOut() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Clear_QueueKeepsWorkingAfter() MergeablePriorityQueueTests<BinomialHeapPriorityQueue<Int32>>.Clear_DoesntResetPushTimestamps() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinomialHeap Assembly : MoreStructures.Tests.dll Syntax public class BinomialHeapPriorityQueueTests_AsMergeableQueue : MergeablePriorityQueueTests<BinomialHeapPriorityQueue<int>> Constructors | Improve this Doc View Source BinomialHeapPriorityQueueTests_AsMergeableQueue() Declaration public BinomialHeapPriorityQueueTests_AsMergeableQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.DuplicatedItemsResolutionTests.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.DuplicatedItemsResolutionTests.html",
    "title": "Class DuplicatedItemsResolutionTests",
    "keywords": "Class DuplicatedItemsResolutionTests Inheritance System.Object DuplicatedItemsResolutionTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinomialHeap Assembly : MoreStructures.Tests.dll Syntax public class DuplicatedItemsResolutionTests Methods | Improve this Doc View Source Clear_WipesContentOut() Declaration public void Clear_WipesContentOut() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.html",
    "title": "Namespace MoreStructures.Tests.PriorityQueues.BinomialHeap",
    "keywords": "Namespace MoreStructures.Tests.PriorityQueues.BinomialHeap Classes BinomialHeapPriorityQueueTests_AsBasicQueue BinomialHeapPriorityQueueTests_AsMergeableQueue DuplicatedItemsResolutionTests TreeNodeTests TreeNodeTests.TreeNodeMock UpdatableBinomialHeapPriorityQueueTests_AsBasicQueue UpdatableBinomialHeapPriorityQueueTests_AsMergeableAndUpdatableQueue UpdatableBinomialHeapPriorityQueueTests_AsUpdatableQueue"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.TreeNodeTests.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.TreeNodeTests.html",
    "title": "Class TreeNodeTests",
    "keywords": "Class TreeNodeTests Inheritance System.Object TreeNodeTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinomialHeap Assembly : MoreStructures.Tests.dll Syntax public class TreeNodeTests Methods | Improve this Doc View Source AddChild_AddsToTheChildrenOfTheParentAndSetBackreferences() Declaration public void AddChild_AddsToTheChildrenOfTheParentAndSetBackreferences() | Improve this Doc View Source AddChild_ThrowsExceptionIfNodeIsAlreadyChildOfTheParent() Declaration public void AddChild_ThrowsExceptionIfNodeIsAlreadyChildOfTheParent() | Improve this Doc View Source AddChild_ThrowsExceptionIfNodeIsARoot() Declaration public void AddChild_ThrowsExceptionIfNodeIsARoot() | Improve this Doc View Source AddChild_ThrowsExceptionIfNodeIsChildOfAnotherNode() Declaration public void AddChild_ThrowsExceptionIfNodeIsChildOfAnotherNode() | Improve this Doc View Source AddChild_ThrowsExceptionIfNodeParentPropertiesAreIncoherent() Declaration public void AddChild_ThrowsExceptionIfNodeParentPropertiesAreIncoherent() | Improve this Doc View Source DeepCopy_PointsToSamePrioritizedItem() Declaration public void DeepCopy_PointsToSamePrioritizedItem() | Improve this Doc View Source DeepCopy_PreservesParentChildStructure() Declaration public void DeepCopy_PreservesParentChildStructure() | Improve this Doc View Source DeepCopy_PreservesParentChildStructureAtMultipleLevels() Declaration public void DeepCopy_PreservesParentChildStructureAtMultipleLevels() | Improve this Doc View Source DeepCopy_WorksWithLeaves() Declaration public void DeepCopy_WorksWithLeaves() | Improve this Doc View Source DetachFromParent_ThrowsExceptionIfNodeIsARoot() Declaration public void DetachFromParent_ThrowsExceptionIfNodeIsARoot() | Improve this Doc View Source DetachFromParent_ThrowsExceptionOnOrphan() Declaration public void DetachFromParent_ThrowsExceptionOnOrphan() | Improve this Doc View Source DetachFromParent_ThrowsExceptionWhenParentPropertiesAreIncoherent() Declaration public void DetachFromParent_ThrowsExceptionWhenParentPropertiesAreIncoherent() | Improve this Doc View Source DetachFromParent_UpdateParentPropertiesOnChild() Declaration public void DetachFromParent_UpdateParentPropertiesOnChild() | Improve this Doc View Source DetachFromParent_UpdatesParentChildren() Declaration public void DetachFromParent_UpdatesParentChildren() | Improve this Doc View Source IsInAHeap_IsTrueWhenAChild() Declaration public void IsInAHeap_IsTrueWhenAChild() | Improve this Doc View Source IsInAHeap_IsTrueWhenARoot() Declaration public void IsInAHeap_IsTrueWhenARoot() | Improve this Doc View Source ToString_IncludesIsALoser() Declaration public void ToString_IncludesIsALoser() | Improve this Doc View Source ToString_IncludesIsInHeap() Declaration public void ToString_IncludesIsInHeap() | Improve this Doc View Source ToString_IncludesPrioritizedItem() Declaration public void ToString_IncludesPrioritizedItem() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.TreeNodeTests.TreeNodeMock.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.TreeNodeTests.TreeNodeMock.html",
    "title": "Class TreeNodeTests.TreeNodeMock",
    "keywords": "Class TreeNodeTests.TreeNodeMock Inheritance System.Object TreeNode < System.String > TreeNodeTests.TreeNodeMock Inherited Members TreeNode<String>.PrioritizedItem TreeNode<String>.Children TreeNode<String>.Parent TreeNode<String>.RootsListNode TreeNode<String>.ParentListNode TreeNode<String>.IsALoser TreeNode<String>.IsInAHeap TreeNode<String>.AddChild(TreeNode<String>) TreeNode<String>.DetachFromParent() TreeNode<String>.DeepCopy() TreeNode<String>.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.Tests.PriorityQueues.BinomialHeap Assembly : MoreStructures.Tests.dll Syntax protected class TreeNodeMock : TreeNode<string> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.UpdatableBinomialHeapPriorityQueueTests_AsBasicQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.UpdatableBinomialHeapPriorityQueueTests_AsBasicQueue.html",
    "title": "Class UpdatableBinomialHeapPriorityQueueTests_AsBasicQueue",
    "keywords": "Class UpdatableBinomialHeapPriorityQueueTests_AsBasicQueue Inheritance System.Object PriorityQueueTests UpdatableBinomialHeapPriorityQueueTests_AsBasicQueue Inherited Members PriorityQueueTests.IntQueueBuilder PriorityQueueTests.RefTypeQueueBuilder PriorityQueueTests.ValTypeQueueBuilder PriorityQueueTests.Pop_RaisesExceptionOnEmptyQueue() PriorityQueueTests.Pop_RespectsPriorities() PriorityQueueTests.PushAndPop_WorkWithReferenceTypes() PriorityQueueTests.PushAndPop_WorkWithValueTypes() PriorityQueueTests.PushAndPop_WithPrioritiesPartiallyOrdered() PriorityQueueTests.PushAndPop_ComplexScenario() PriorityQueueTests.PushAndPop_AllPermutations() PriorityQueueTests.PushAndPop_AreStable() PriorityQueueTests.Count_IsCorrect() PriorityQueueTests.Count_IsCorrectWithDuplicates() PriorityQueueTests.Peek_RaisesExceptionOnEmptyQueue() PriorityQueueTests.Peek_IsCorrect() PriorityQueueTests.Peek_DoesntChangeTheContentOfTheQueue() PriorityQueueTests.GetEnumerator_RetrievesAllItemsAccordingToPriority() PriorityQueueTests.GetEnumerator_DoesntAlterQueueWhenIterated() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinomialHeap Assembly : MoreStructures.Tests.dll Syntax public class UpdatableBinomialHeapPriorityQueueTests_AsBasicQueue : PriorityQueueTests Constructors | Improve this Doc View Source UpdatableBinomialHeapPriorityQueueTests_AsBasicQueue() Declaration public UpdatableBinomialHeapPriorityQueueTests_AsBasicQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.UpdatableBinomialHeapPriorityQueueTests_AsMergeableAndUpdatableQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.UpdatableBinomialHeapPriorityQueueTests_AsMergeableAndUpdatableQueue.html",
    "title": "Class UpdatableBinomialHeapPriorityQueueTests_AsMergeableAndUpdatableQueue",
    "keywords": "Class UpdatableBinomialHeapPriorityQueueTests_AsMergeableAndUpdatableQueue Inheritance System.Object MergeablePriorityQueueTests < UpdatableBinomialHeapPriorityQueue < System.Int32 >> UpdatableBinomialHeapPriorityQueueTests_AsMergeableAndUpdatableQueue Inherited Members MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.IntBuilder MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_WithEmptySource() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_WithEmptyTarget() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_ContainsElementsFromBothQueues() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_WorksWithManyItems() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_WorksWithDuplicates() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_CanBeRepeatedWithMultipleTargets() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_RemoveAllItemsFromTheTarget() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_TargetIsUsableAfterMerge() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_TargetChangesDontInterfereWithSource() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_KeepsPushTimestampsUniqueWithinEras() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_IfSamePriorityTakeItemsComingFromTargetAfterSource() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_IfDifferentPrioritySortByItNoMatterIfFromSourceOrTarget() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_IfSamePriorityTakeItemsAfterMergeAfterTarget() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_SourceOfAMergeCanBeUsedAsTargetOfAnotherMerge() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Merge_TargetOfAMergeCanBeUsedAsSourceOfAnotherMerge() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.MergeAndClear_ComplexScenario() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Clear_WipesAllItemsOut() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Clear_QueueKeepsWorkingAfter() MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<Int32>>.Clear_DoesntResetPushTimestamps() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinomialHeap Assembly : MoreStructures.Tests.dll Syntax public class UpdatableBinomialHeapPriorityQueueTests_AsMergeableAndUpdatableQueue : MergeablePriorityQueueTests<UpdatableBinomialHeapPriorityQueue<int>> Constructors | Improve this Doc View Source UpdatableBinomialHeapPriorityQueueTests_AsMergeableAndUpdatableQueue() Declaration public UpdatableBinomialHeapPriorityQueueTests_AsMergeableAndUpdatableQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.UpdatableBinomialHeapPriorityQueueTests_AsUpdatableQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.BinomialHeap.UpdatableBinomialHeapPriorityQueueTests_AsUpdatableQueue.html",
    "title": "Class UpdatableBinomialHeapPriorityQueueTests_AsUpdatableQueue",
    "keywords": "Class UpdatableBinomialHeapPriorityQueueTests_AsUpdatableQueue Inheritance System.Object UpdatablePriorityQueueTests UpdatableBinomialHeapPriorityQueueTests_AsUpdatableQueue Inherited Members UpdatablePriorityQueueTests.IntUpdatableQueueBuilder UpdatablePriorityQueueTests.RefTypeUpdatableQueueBuilder UpdatablePriorityQueueTests.ValTypeUpdatableQueueBuilder UpdatablePriorityQueueTests.GetPrioritiesOf_FirstIsCorrect() UpdatablePriorityQueueTests.GetPrioritiesOf_IsCorrect() UpdatablePriorityQueueTests.UpdatePriority_RaisesExceptionOnItemNonPresent() UpdatablePriorityQueueTests.UpdatePriority_IsStableWithInt() UpdatablePriorityQueueTests.UpdatePriority_IsStableWithReferenceTypes() UpdatablePriorityQueueTests.UpdatePriority_IsCorrect() UpdatablePriorityQueueTests.UpdatePriority_AllPermutations() UpdatablePriorityQueueTests.UpdatePriority_LongChainOfUpdates(Int32[], Int32[], Int32[]) UpdatablePriorityQueueTests.UpdatePriority_StalePushTimestamps() UpdatablePriorityQueueTests.UpdatePriority_WorksWhenNewPriorityIsTheSame() UpdatablePriorityQueueTests.Remove_IsCorrect() UpdatablePriorityQueueTests.Remove_WorksWithReferenceTypes() UpdatablePriorityQueueTests.Remove_WorksWithValueTypes() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.BinomialHeap Assembly : MoreStructures.Tests.dll Syntax public class UpdatableBinomialHeapPriorityQueueTests_AsUpdatableQueue : UpdatablePriorityQueueTests Constructors | Improve this Doc View Source UpdatableBinomialHeapPriorityQueueTests_AsUpdatableQueue() Declaration public UpdatableBinomialHeapPriorityQueueTests_AsUpdatableQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.Extensions.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.Extensions.html",
    "title": "Namespace MoreStructures.Tests.PriorityQueues.Extensions",
    "keywords": "Namespace MoreStructures.Tests.PriorityQueues.Extensions Classes UpdatablePriorityQueueExtensionsTests UpdatablePriorityQueueExtensionsTests_WithArrayListPriorityQueue UpdatablePriorityQueueExtensionsTests_WithUpdatableBinaryHeapPriorityQueue"
  },
  "api/MoreStructures.Tests.PriorityQueues.Extensions.UpdatablePriorityQueueExtensionsTests.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.Extensions.UpdatablePriorityQueueExtensionsTests.html",
    "title": "Class UpdatablePriorityQueueExtensionsTests",
    "keywords": "Class UpdatablePriorityQueueExtensionsTests Inheritance System.Object UpdatablePriorityQueueExtensionsTests UpdatablePriorityQueueExtensionsTests_WithArrayListPriorityQueue UpdatablePriorityQueueExtensionsTests_WithUpdatableBinaryHeapPriorityQueue Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.Extensions Assembly : MoreStructures.Tests.dll Syntax public abstract class UpdatablePriorityQueueExtensionsTests Constructors | Improve this Doc View Source UpdatablePriorityQueueExtensionsTests(Func<IUpdatablePriorityQueue<Int32>>) Declaration protected UpdatablePriorityQueueExtensionsTests(Func<IUpdatablePriorityQueue<int>> intQueueBuilder) Parameters Type Name Description Func < IUpdatablePriorityQueue < System.Int32 >> intQueueBuilder Properties | Improve this Doc View Source IntQueueBuilder Declaration protected Func<IUpdatablePriorityQueue<int>> IntQueueBuilder { get; } Property Value Type Description Func < IUpdatablePriorityQueue < System.Int32 >> Methods | Improve this Doc View Source PopAll_ExtractsAllItems() Declaration public void PopAll_ExtractsAllItems() | Improve this Doc View Source PushOrUpdate_IsCorrect() Declaration public void PushOrUpdate_IsCorrect() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.Extensions.UpdatablePriorityQueueExtensionsTests_WithArrayListPriorityQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.Extensions.UpdatablePriorityQueueExtensionsTests_WithArrayListPriorityQueue.html",
    "title": "Class UpdatablePriorityQueueExtensionsTests_WithArrayListPriorityQueue",
    "keywords": "Class UpdatablePriorityQueueExtensionsTests_WithArrayListPriorityQueue Inheritance System.Object UpdatablePriorityQueueExtensionsTests UpdatablePriorityQueueExtensionsTests_WithArrayListPriorityQueue Inherited Members UpdatablePriorityQueueExtensionsTests.IntQueueBuilder UpdatablePriorityQueueExtensionsTests.PushOrUpdate_IsCorrect() UpdatablePriorityQueueExtensionsTests.PopAll_ExtractsAllItems() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.Extensions Assembly : MoreStructures.Tests.dll Syntax public class UpdatablePriorityQueueExtensionsTests_WithArrayListPriorityQueue : UpdatablePriorityQueueExtensionsTests Constructors | Improve this Doc View Source UpdatablePriorityQueueExtensionsTests_WithArrayListPriorityQueue() Declaration public UpdatablePriorityQueueExtensionsTests_WithArrayListPriorityQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.Extensions.UpdatablePriorityQueueExtensionsTests_WithUpdatableBinaryHeapPriorityQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.Extensions.UpdatablePriorityQueueExtensionsTests_WithUpdatableBinaryHeapPriorityQueue.html",
    "title": "Class UpdatablePriorityQueueExtensionsTests_WithUpdatableBinaryHeapPriorityQueue",
    "keywords": "Class UpdatablePriorityQueueExtensionsTests_WithUpdatableBinaryHeapPriorityQueue Inheritance System.Object UpdatablePriorityQueueExtensionsTests UpdatablePriorityQueueExtensionsTests_WithUpdatableBinaryHeapPriorityQueue Inherited Members UpdatablePriorityQueueExtensionsTests.IntQueueBuilder UpdatablePriorityQueueExtensionsTests.PushOrUpdate_IsCorrect() UpdatablePriorityQueueExtensionsTests.PopAll_ExtractsAllItems() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.Extensions Assembly : MoreStructures.Tests.dll Syntax public class UpdatablePriorityQueueExtensionsTests_WithUpdatableBinaryHeapPriorityQueue : UpdatablePriorityQueueExtensionsTests Constructors | Improve this Doc View Source UpdatablePriorityQueueExtensionsTests_WithUpdatableBinaryHeapPriorityQueue() Declaration public UpdatablePriorityQueueExtensionsTests_WithUpdatableBinaryHeapPriorityQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.FibonacciHeap.FibonacciHeapPriorityQueueTests_AsBasicQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.FibonacciHeap.FibonacciHeapPriorityQueueTests_AsBasicQueue.html",
    "title": "Class FibonacciHeapPriorityQueueTests_AsBasicQueue",
    "keywords": "Class FibonacciHeapPriorityQueueTests_AsBasicQueue Inheritance System.Object PriorityQueueTests FibonacciHeapPriorityQueueTests_AsBasicQueue Inherited Members PriorityQueueTests.IntQueueBuilder PriorityQueueTests.RefTypeQueueBuilder PriorityQueueTests.ValTypeQueueBuilder PriorityQueueTests.Pop_RaisesExceptionOnEmptyQueue() PriorityQueueTests.Pop_RespectsPriorities() PriorityQueueTests.PushAndPop_WorkWithReferenceTypes() PriorityQueueTests.PushAndPop_WorkWithValueTypes() PriorityQueueTests.PushAndPop_WithPrioritiesPartiallyOrdered() PriorityQueueTests.PushAndPop_ComplexScenario() PriorityQueueTests.PushAndPop_AllPermutations() PriorityQueueTests.PushAndPop_AreStable() PriorityQueueTests.Count_IsCorrect() PriorityQueueTests.Count_IsCorrectWithDuplicates() PriorityQueueTests.Peek_RaisesExceptionOnEmptyQueue() PriorityQueueTests.Peek_IsCorrect() PriorityQueueTests.Peek_DoesntChangeTheContentOfTheQueue() PriorityQueueTests.GetEnumerator_RetrievesAllItemsAccordingToPriority() PriorityQueueTests.GetEnumerator_DoesntAlterQueueWhenIterated() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.FibonacciHeap Assembly : MoreStructures.Tests.dll Syntax public class FibonacciHeapPriorityQueueTests_AsBasicQueue : PriorityQueueTests Constructors | Improve this Doc View Source FibonacciHeapPriorityQueueTests_AsBasicQueue() Declaration public FibonacciHeapPriorityQueueTests_AsBasicQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.FibonacciHeap.FibonacciHeapPriorityQueueTests_AsMergeableQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.FibonacciHeap.FibonacciHeapPriorityQueueTests_AsMergeableQueue.html",
    "title": "Class FibonacciHeapPriorityQueueTests_AsMergeableQueue",
    "keywords": "Class FibonacciHeapPriorityQueueTests_AsMergeableQueue Inheritance System.Object MergeablePriorityQueueTests < FibonacciHeapPriorityQueue < System.Int32 >> FibonacciHeapPriorityQueueTests_AsMergeableQueue Inherited Members MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.IntBuilder MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_WithEmptySource() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_WithEmptyTarget() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_ContainsElementsFromBothQueues() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_WorksWithManyItems() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_WorksWithDuplicates() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_CanBeRepeatedWithMultipleTargets() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_RemoveAllItemsFromTheTarget() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_TargetIsUsableAfterMerge() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_TargetChangesDontInterfereWithSource() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_KeepsPushTimestampsUniqueWithinEras() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_IfSamePriorityTakeItemsComingFromTargetAfterSource() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_IfDifferentPrioritySortByItNoMatterIfFromSourceOrTarget() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_IfSamePriorityTakeItemsAfterMergeAfterTarget() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_SourceOfAMergeCanBeUsedAsTargetOfAnotherMerge() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Merge_TargetOfAMergeCanBeUsedAsSourceOfAnotherMerge() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.MergeAndClear_ComplexScenario() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Clear_WipesAllItemsOut() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Clear_QueueKeepsWorkingAfter() MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<Int32>>.Clear_DoesntResetPushTimestamps() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.FibonacciHeap Assembly : MoreStructures.Tests.dll Syntax public class FibonacciHeapPriorityQueueTests_AsMergeableQueue : MergeablePriorityQueueTests<FibonacciHeapPriorityQueue<int>> Constructors | Improve this Doc View Source FibonacciHeapPriorityQueueTests_AsMergeableQueue() Declaration public FibonacciHeapPriorityQueueTests_AsMergeableQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.FibonacciHeap.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.FibonacciHeap.html",
    "title": "Namespace MoreStructures.Tests.PriorityQueues.FibonacciHeap",
    "keywords": "Namespace MoreStructures.Tests.PriorityQueues.FibonacciHeap Classes FibonacciHeapPriorityQueueTests_AsBasicQueue FibonacciHeapPriorityQueueTests_AsMergeableQueue UpdatableFibonacciHeapPriorityQueueTests_AsBasicQueue UpdatableFibonacciHeapPriorityQueueTests_AsMergeableAndUpdatableQueue UpdatableFibonacciHeapPriorityQueueTests_AsUpdatableQueue"
  },
  "api/MoreStructures.Tests.PriorityQueues.FibonacciHeap.UpdatableFibonacciHeapPriorityQueueTests_AsBasicQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.FibonacciHeap.UpdatableFibonacciHeapPriorityQueueTests_AsBasicQueue.html",
    "title": "Class UpdatableFibonacciHeapPriorityQueueTests_AsBasicQueue",
    "keywords": "Class UpdatableFibonacciHeapPriorityQueueTests_AsBasicQueue Inheritance System.Object PriorityQueueTests UpdatableFibonacciHeapPriorityQueueTests_AsBasicQueue Inherited Members PriorityQueueTests.IntQueueBuilder PriorityQueueTests.RefTypeQueueBuilder PriorityQueueTests.ValTypeQueueBuilder PriorityQueueTests.Pop_RaisesExceptionOnEmptyQueue() PriorityQueueTests.Pop_RespectsPriorities() PriorityQueueTests.PushAndPop_WorkWithReferenceTypes() PriorityQueueTests.PushAndPop_WorkWithValueTypes() PriorityQueueTests.PushAndPop_WithPrioritiesPartiallyOrdered() PriorityQueueTests.PushAndPop_ComplexScenario() PriorityQueueTests.PushAndPop_AllPermutations() PriorityQueueTests.PushAndPop_AreStable() PriorityQueueTests.Count_IsCorrect() PriorityQueueTests.Count_IsCorrectWithDuplicates() PriorityQueueTests.Peek_RaisesExceptionOnEmptyQueue() PriorityQueueTests.Peek_IsCorrect() PriorityQueueTests.Peek_DoesntChangeTheContentOfTheQueue() PriorityQueueTests.GetEnumerator_RetrievesAllItemsAccordingToPriority() PriorityQueueTests.GetEnumerator_DoesntAlterQueueWhenIterated() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.FibonacciHeap Assembly : MoreStructures.Tests.dll Syntax public class UpdatableFibonacciHeapPriorityQueueTests_AsBasicQueue : PriorityQueueTests Constructors | Improve this Doc View Source UpdatableFibonacciHeapPriorityQueueTests_AsBasicQueue() Declaration public UpdatableFibonacciHeapPriorityQueueTests_AsBasicQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.FibonacciHeap.UpdatableFibonacciHeapPriorityQueueTests_AsMergeableAndUpdatableQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.FibonacciHeap.UpdatableFibonacciHeapPriorityQueueTests_AsMergeableAndUpdatableQueue.html",
    "title": "Class UpdatableFibonacciHeapPriorityQueueTests_AsMergeableAndUpdatableQueue",
    "keywords": "Class UpdatableFibonacciHeapPriorityQueueTests_AsMergeableAndUpdatableQueue Inheritance System.Object MergeablePriorityQueueTests < UpdatableFibonacciHeapPriorityQueue < System.Int32 >> UpdatableFibonacciHeapPriorityQueueTests_AsMergeableAndUpdatableQueue Inherited Members MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.IntBuilder MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_WithEmptySource() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_WithEmptyTarget() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_ContainsElementsFromBothQueues() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_WorksWithManyItems() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_WorksWithDuplicates() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_CanBeRepeatedWithMultipleTargets() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_RemoveAllItemsFromTheTarget() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_TargetIsUsableAfterMerge() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_TargetChangesDontInterfereWithSource() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_KeepsPushTimestampsUniqueWithinEras() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_IfSamePriorityTakeItemsComingFromTargetAfterSource() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_IfDifferentPrioritySortByItNoMatterIfFromSourceOrTarget() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_IfSamePriorityTakeItemsAfterMergeAfterTarget() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_SourceOfAMergeCanBeUsedAsTargetOfAnotherMerge() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Merge_TargetOfAMergeCanBeUsedAsSourceOfAnotherMerge() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.MergeAndClear_ComplexScenario() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Clear_WipesAllItemsOut() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Clear_QueueKeepsWorkingAfter() MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<Int32>>.Clear_DoesntResetPushTimestamps() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.FibonacciHeap Assembly : MoreStructures.Tests.dll Syntax public class UpdatableFibonacciHeapPriorityQueueTests_AsMergeableAndUpdatableQueue : MergeablePriorityQueueTests<UpdatableFibonacciHeapPriorityQueue<int>> Constructors | Improve this Doc View Source UpdatableFibonacciHeapPriorityQueueTests_AsMergeableAndUpdatableQueue() Declaration public UpdatableFibonacciHeapPriorityQueueTests_AsMergeableAndUpdatableQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.FibonacciHeap.UpdatableFibonacciHeapPriorityQueueTests_AsUpdatableQueue.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.FibonacciHeap.UpdatableFibonacciHeapPriorityQueueTests_AsUpdatableQueue.html",
    "title": "Class UpdatableFibonacciHeapPriorityQueueTests_AsUpdatableQueue",
    "keywords": "Class UpdatableFibonacciHeapPriorityQueueTests_AsUpdatableQueue Inheritance System.Object UpdatablePriorityQueueTests UpdatableFibonacciHeapPriorityQueueTests_AsUpdatableQueue Inherited Members UpdatablePriorityQueueTests.IntUpdatableQueueBuilder UpdatablePriorityQueueTests.RefTypeUpdatableQueueBuilder UpdatablePriorityQueueTests.ValTypeUpdatableQueueBuilder UpdatablePriorityQueueTests.GetPrioritiesOf_FirstIsCorrect() UpdatablePriorityQueueTests.GetPrioritiesOf_IsCorrect() UpdatablePriorityQueueTests.UpdatePriority_RaisesExceptionOnItemNonPresent() UpdatablePriorityQueueTests.UpdatePriority_IsStableWithInt() UpdatablePriorityQueueTests.UpdatePriority_IsStableWithReferenceTypes() UpdatablePriorityQueueTests.UpdatePriority_IsCorrect() UpdatablePriorityQueueTests.UpdatePriority_AllPermutations() UpdatablePriorityQueueTests.UpdatePriority_LongChainOfUpdates(Int32[], Int32[], Int32[]) UpdatablePriorityQueueTests.UpdatePriority_StalePushTimestamps() UpdatablePriorityQueueTests.UpdatePriority_WorksWhenNewPriorityIsTheSame() UpdatablePriorityQueueTests.Remove_IsCorrect() UpdatablePriorityQueueTests.Remove_WorksWithReferenceTypes() UpdatablePriorityQueueTests.Remove_WorksWithValueTypes() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues.FibonacciHeap Assembly : MoreStructures.Tests.dll Syntax public class UpdatableFibonacciHeapPriorityQueueTests_AsUpdatableQueue : UpdatablePriorityQueueTests Constructors | Improve this Doc View Source UpdatableFibonacciHeapPriorityQueueTests_AsUpdatableQueue() Declaration public UpdatableFibonacciHeapPriorityQueueTests_AsUpdatableQueue() Methods | Improve this Doc View Source UpdatePriority_TriggersAChainOfLosers() Declaration public void UpdatePriority_TriggersAChainOfLosers() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.html",
    "title": "Namespace MoreStructures.Tests.PriorityQueues",
    "keywords": "Namespace MoreStructures.Tests.PriorityQueues Classes MoreStructures.Tests.PriorityQueues. MergeableAndUpdatablePriorityQueueTests<TPriorityQueue> MergeablePriorityQueueTests<TIntPriorityQueue> PeekKthPriorityQueueTests PrioritizedItemTests PriorityQueueTests RefType UpdatablePriorityQueueTests"
  },
  "api/MoreStructures.Tests.PriorityQueues.MergeableAndUpdatablePriorityQueueTests-1.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.MergeableAndUpdatablePriorityQueueTests-1.html",
    "title": "Class MergeableAndUpdatablePriorityQueueTests<TPriorityQueue>",
    "keywords": "Class MergeableAndUpdatablePriorityQueueTests<TPriorityQueue> Inheritance System.Object MergeablePriorityQueueTests <TPriorityQueue> MergeableAndUpdatablePriorityQueueTests<TPriorityQueue> ArrayListPriorityQueueTests_AsMergeableAndUpdatable UpdatableBinaryHeapPriorityQueueTests_AsMergeableAndUpdatableQueue Inherited Members MergeablePriorityQueueTests<TPriorityQueue>.IntBuilder MergeablePriorityQueueTests<TPriorityQueue>.Merge_WithEmptySource() MergeablePriorityQueueTests<TPriorityQueue>.Merge_WithEmptyTarget() MergeablePriorityQueueTests<TPriorityQueue>.Merge_ContainsElementsFromBothQueues() MergeablePriorityQueueTests<TPriorityQueue>.Merge_WorksWithManyItems() MergeablePriorityQueueTests<TPriorityQueue>.Merge_WorksWithDuplicates() MergeablePriorityQueueTests<TPriorityQueue>.Merge_CanBeRepeatedWithMultipleTargets() MergeablePriorityQueueTests<TPriorityQueue>.Merge_RemoveAllItemsFromTheTarget() MergeablePriorityQueueTests<TPriorityQueue>.Merge_TargetIsUsableAfterMerge() MergeablePriorityQueueTests<TPriorityQueue>.Merge_TargetChangesDontInterfereWithSource() MergeablePriorityQueueTests<TPriorityQueue>.Merge_KeepsPushTimestampsUniqueWithinEras() MergeablePriorityQueueTests<TPriorityQueue>.Merge_IfSamePriorityTakeItemsComingFromTargetAfterSource() MergeablePriorityQueueTests<TPriorityQueue>.Merge_IfDifferentPrioritySortByItNoMatterIfFromSourceOrTarget() MergeablePriorityQueueTests<TPriorityQueue>.Merge_IfSamePriorityTakeItemsAfterMergeAfterTarget() MergeablePriorityQueueTests<TPriorityQueue>.Merge_SourceOfAMergeCanBeUsedAsTargetOfAnotherMerge() MergeablePriorityQueueTests<TPriorityQueue>.Merge_TargetOfAMergeCanBeUsedAsSourceOfAnotherMerge() MergeablePriorityQueueTests<TPriorityQueue>.MergeAndClear_ComplexScenario() MergeablePriorityQueueTests<TPriorityQueue>.Clear_WipesAllItemsOut() MergeablePriorityQueueTests<TPriorityQueue>.Clear_QueueKeepsWorkingAfter() MergeablePriorityQueueTests<TPriorityQueue>.Clear_DoesntResetPushTimestamps() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues Assembly : MoreStructures.Tests.dll Syntax public abstract class MergeableAndUpdatablePriorityQueueTests<TPriorityQueue> : MergeablePriorityQueueTests<TPriorityQueue> where TPriorityQueue : IMergeablePriorityQueue<int, TPriorityQueue>, IUpdatablePriorityQueue<int> Type Parameters Name Description TPriorityQueue Constructors | Improve this Doc View Source MergeableAndUpdatablePriorityQueueTests(Func<TPriorityQueue>) Declaration protected MergeableAndUpdatablePriorityQueueTests(Func<TPriorityQueue> builder) Parameters Type Name Description Func <TPriorityQueue> builder Methods | Improve this Doc View Source Clear_QueueUpdatesKeepWorkingAfter() Declaration public void Clear_QueueUpdatesKeepWorkingAfter() | Improve this Doc View Source Merge_QueueUpdatesKeepWorkingOnSourceAfter() Declaration public void Merge_QueueUpdatesKeepWorkingOnSourceAfter() | Improve this Doc View Source Merge_QueueUpdatesKeepWorkingOnTargetAfter() Declaration public void Merge_QueueUpdatesKeepWorkingOnTargetAfter() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.MergeablePriorityQueueTests-1.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.MergeablePriorityQueueTests-1.html",
    "title": "Class MergeablePriorityQueueTests<TIntPriorityQueue>",
    "keywords": "Class MergeablePriorityQueueTests<TIntPriorityQueue> Inheritance System.Object MergeablePriorityQueueTests<TIntPriorityQueue> BinaryHeapPriorityQueueTests_AsMergeable BinomialHeapPriorityQueueTests_AsMergeableQueue UpdatableBinomialHeapPriorityQueueTests_AsMergeableAndUpdatableQueue FibonacciHeapPriorityQueueTests_AsMergeableQueue UpdatableFibonacciHeapPriorityQueueTests_AsMergeableAndUpdatableQueue MergeableAndUpdatablePriorityQueueTests<TPriorityQueue> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues Assembly : MoreStructures.Tests.dll Syntax public abstract class MergeablePriorityQueueTests<TIntPriorityQueue> where TIntPriorityQueue : IMergeablePriorityQueue<int, TIntPriorityQueue> Type Parameters Name Description TIntPriorityQueue Constructors | Improve this Doc View Source MergeablePriorityQueueTests(Func<TIntPriorityQueue>) Declaration protected MergeablePriorityQueueTests(Func<TIntPriorityQueue> intBuilder) Parameters Type Name Description Func <TIntPriorityQueue> intBuilder Properties | Improve this Doc View Source IntBuilder Declaration protected Func<TIntPriorityQueue> IntBuilder { get; } Property Value Type Description Func <TIntPriorityQueue> Methods | Improve this Doc View Source Clear_DoesntResetPushTimestamps() Declaration public void Clear_DoesntResetPushTimestamps() | Improve this Doc View Source Clear_QueueKeepsWorkingAfter() Declaration public void Clear_QueueKeepsWorkingAfter() | Improve this Doc View Source Clear_WipesAllItemsOut() Declaration public void Clear_WipesAllItemsOut() | Improve this Doc View Source Merge_CanBeRepeatedWithMultipleTargets() Declaration public void Merge_CanBeRepeatedWithMultipleTargets() | Improve this Doc View Source Merge_ContainsElementsFromBothQueues() Declaration public void Merge_ContainsElementsFromBothQueues() | Improve this Doc View Source Merge_IfDifferentPrioritySortByItNoMatterIfFromSourceOrTarget() Declaration public void Merge_IfDifferentPrioritySortByItNoMatterIfFromSourceOrTarget() | Improve this Doc View Source Merge_IfSamePriorityTakeItemsAfterMergeAfterTarget() Declaration public void Merge_IfSamePriorityTakeItemsAfterMergeAfterTarget() | Improve this Doc View Source Merge_IfSamePriorityTakeItemsComingFromTargetAfterSource() Declaration public void Merge_IfSamePriorityTakeItemsComingFromTargetAfterSource() | Improve this Doc View Source Merge_KeepsPushTimestampsUniqueWithinEras() Declaration public void Merge_KeepsPushTimestampsUniqueWithinEras() | Improve this Doc View Source Merge_RemoveAllItemsFromTheTarget() Declaration public void Merge_RemoveAllItemsFromTheTarget() | Improve this Doc View Source Merge_SourceOfAMergeCanBeUsedAsTargetOfAnotherMerge() Declaration public void Merge_SourceOfAMergeCanBeUsedAsTargetOfAnotherMerge() | Improve this Doc View Source Merge_TargetChangesDontInterfereWithSource() Declaration public void Merge_TargetChangesDontInterfereWithSource() | Improve this Doc View Source Merge_TargetIsUsableAfterMerge() Declaration public void Merge_TargetIsUsableAfterMerge() | Improve this Doc View Source Merge_TargetOfAMergeCanBeUsedAsSourceOfAnotherMerge() Declaration public void Merge_TargetOfAMergeCanBeUsedAsSourceOfAnotherMerge() | Improve this Doc View Source Merge_WithEmptySource() Declaration public void Merge_WithEmptySource() | Improve this Doc View Source Merge_WithEmptyTarget() Declaration public void Merge_WithEmptyTarget() | Improve this Doc View Source Merge_WorksWithDuplicates() Declaration public void Merge_WorksWithDuplicates() | Improve this Doc View Source Merge_WorksWithManyItems() Declaration public void Merge_WorksWithManyItems() | Improve this Doc View Source MergeAndClear_ComplexScenario() Declaration public void MergeAndClear_ComplexScenario() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.PeekKthPriorityQueueTests.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.PeekKthPriorityQueueTests.html",
    "title": "Class PeekKthPriorityQueueTests",
    "keywords": "Class PeekKthPriorityQueueTests Inheritance System.Object PeekKthPriorityQueueTests ArrayListPriorityQueueTests_AsPeekKthQueue BinaryHeapPriorityQueueTests_AsPeekKthQueue Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues Assembly : MoreStructures.Tests.dll Syntax public abstract class PeekKthPriorityQueueTests Constructors | Improve this Doc View Source PeekKthPriorityQueueTests(Func<IPeekKthPriorityQueue<Int32>>) Declaration protected PeekKthPriorityQueueTests(Func<IPeekKthPriorityQueue<int>> intQueueBuilder) Parameters Type Name Description Func < IPeekKthPriorityQueue < System.Int32 >> intQueueBuilder Properties | Improve this Doc View Source IntQueueBuilder Declaration protected Func<IPeekKthPriorityQueue<int>> IntQueueBuilder { get; } Property Value Type Description Func < IPeekKthPriorityQueue < System.Int32 >> Methods | Improve this Doc View Source PeekKth_IsCorrect() Declaration public void PeekKth_IsCorrect() | Improve this Doc View Source PeekKth_IsStable() Declaration public void PeekKth_IsStable() | Improve this Doc View Source PeekKth_ThrowsExceptionOnInvalidK() Declaration public void PeekKth_ThrowsExceptionOnInvalidK() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.PrioritizedItemTests.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.PrioritizedItemTests.html",
    "title": "Class PrioritizedItemTests",
    "keywords": "Class PrioritizedItemTests Inheritance System.Object PrioritizedItemTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues Assembly : MoreStructures.Tests.dll Syntax public class PrioritizedItemTests Methods | Improve this Doc View Source CompareTo_IsCorrect() Declaration public void CompareTo_IsCorrect() | Improve this Doc View Source CompareTo_TakesIntoAccountEras() Declaration public void CompareTo_TakesIntoAccountEras() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.PriorityQueueTests.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.PriorityQueueTests.html",
    "title": "Class PriorityQueueTests",
    "keywords": "Class PriorityQueueTests Inheritance System.Object PriorityQueueTests ArrayListPriorityQueueTests_AsBasicQueue BinaryHeapPriorityQueueTests_AsBasicQueue UpdatableBinaryHeapPriorityQueueTests_AsBasicQueue BinomialHeapPriorityQueueTests_AsBasicQueue UpdatableBinomialHeapPriorityQueueTests_AsBasicQueue FibonacciHeapPriorityQueueTests_AsBasicQueue UpdatableFibonacciHeapPriorityQueueTests_AsBasicQueue Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues Assembly : MoreStructures.Tests.dll Syntax public abstract class PriorityQueueTests Constructors | Improve this Doc View Source PriorityQueueTests(Func<IPriorityQueue<Int32>>, Func<IPriorityQueue<RefType>>, Func<IPriorityQueue<ValType>>) Declaration protected PriorityQueueTests(Func<IPriorityQueue<int>> intQueueBuilder, Func<IPriorityQueue<RefType>> refTypeQueueBuilder, Func<IPriorityQueue<ValType>> valTypeQueueBuilder) Parameters Type Name Description Func < IPriorityQueue < System.Int32 >> intQueueBuilder Func < IPriorityQueue < RefType >> refTypeQueueBuilder Func < IPriorityQueue < MoreStructures.Tests.PriorityQueues.ValType >> valTypeQueueBuilder Properties | Improve this Doc View Source IntQueueBuilder Declaration protected Func<IPriorityQueue<int>> IntQueueBuilder { get; } Property Value Type Description Func < IPriorityQueue < System.Int32 >> | Improve this Doc View Source RefTypeQueueBuilder Declaration protected Func<IPriorityQueue<RefType>> RefTypeQueueBuilder { get; } Property Value Type Description Func < IPriorityQueue < RefType >> | Improve this Doc View Source ValTypeQueueBuilder Declaration protected Func<IPriorityQueue<ValType>> ValTypeQueueBuilder { get; } Property Value Type Description Func < IPriorityQueue < MoreStructures.Tests.PriorityQueues.ValType >> Methods | Improve this Doc View Source Count_IsCorrect() Declaration public void Count_IsCorrect() | Improve this Doc View Source Count_IsCorrectWithDuplicates() Declaration public void Count_IsCorrectWithDuplicates() | Improve this Doc View Source GetEnumerator_DoesntAlterQueueWhenIterated() Declaration public void GetEnumerator_DoesntAlterQueueWhenIterated() | Improve this Doc View Source GetEnumerator_RetrievesAllItemsAccordingToPriority() Declaration public void GetEnumerator_RetrievesAllItemsAccordingToPriority() | Improve this Doc View Source Peek_DoesntChangeTheContentOfTheQueue() Declaration public void Peek_DoesntChangeTheContentOfTheQueue() | Improve this Doc View Source Peek_IsCorrect() Declaration public void Peek_IsCorrect() | Improve this Doc View Source Peek_RaisesExceptionOnEmptyQueue() Declaration public void Peek_RaisesExceptionOnEmptyQueue() | Improve this Doc View Source Pop_RaisesExceptionOnEmptyQueue() Declaration public void Pop_RaisesExceptionOnEmptyQueue() | Improve this Doc View Source Pop_RespectsPriorities() Declaration public void Pop_RespectsPriorities() | Improve this Doc View Source PushAndPop_AllPermutations() Declaration public void PushAndPop_AllPermutations() | Improve this Doc View Source PushAndPop_AreStable() Declaration public void PushAndPop_AreStable() | Improve this Doc View Source PushAndPop_ComplexScenario() Declaration public void PushAndPop_ComplexScenario() | Improve this Doc View Source PushAndPop_WithPrioritiesPartiallyOrdered() Declaration public void PushAndPop_WithPrioritiesPartiallyOrdered() | Improve this Doc View Source PushAndPop_WorkWithReferenceTypes() Declaration public void PushAndPop_WorkWithReferenceTypes() | Improve this Doc View Source PushAndPop_WorkWithValueTypes() Declaration public void PushAndPop_WorkWithValueTypes() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.RefType.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.RefType.html",
    "title": "Class RefType",
    "keywords": "Class RefType Inheritance System.Object RefType Implements System.IEquatable < RefType > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues Assembly : MoreStructures.Tests.dll Syntax public class RefType : IEquatable<RefType> Constructors | Improve this Doc View Source RefType(Int32, Object) Declaration public RefType(int Field1, object Field2) Parameters Type Name Description System.Int32 Field1 System.Object Field2 Properties | Improve this Doc View Source Field1 Declaration public int Field1 { get; set; } Property Value Type Description System.Int32 | Improve this Doc View Source Field2 Declaration public object Field2 { get; set; } Property Value Type Description System.Object Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.PriorityQueues.UpdatablePriorityQueueTests.html": {
    "href": "api/MoreStructures.Tests.PriorityQueues.UpdatablePriorityQueueTests.html",
    "title": "Class UpdatablePriorityQueueTests",
    "keywords": "Class UpdatablePriorityQueueTests Inheritance System.Object UpdatablePriorityQueueTests ArrayListPriorityQueueTests_AsUpdatableQueue UpdatableBinaryHeapPriorityQueueTests_AsUpdatableQueue UpdatableBinomialHeapPriorityQueueTests_AsUpdatableQueue UpdatableFibonacciHeapPriorityQueueTests_AsUpdatableQueue Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.PriorityQueues Assembly : MoreStructures.Tests.dll Syntax public abstract class UpdatablePriorityQueueTests Constructors | Improve this Doc View Source UpdatablePriorityQueueTests(Func<IUpdatablePriorityQueue<Int32>>, Func<IUpdatablePriorityQueue<RefType>>, Func<IUpdatablePriorityQueue<ValType>>) Declaration protected UpdatablePriorityQueueTests(Func<IUpdatablePriorityQueue<int>> intUpdatableQueueBuilder, Func<IUpdatablePriorityQueue<RefType>> refTypeUpdatableQueueBuilder, Func<IUpdatablePriorityQueue<ValType>> valTypeUpdatableQueueBuilder) Parameters Type Name Description Func < IUpdatablePriorityQueue < System.Int32 >> intUpdatableQueueBuilder Func < IUpdatablePriorityQueue < RefType >> refTypeUpdatableQueueBuilder Func < IUpdatablePriorityQueue < MoreStructures.Tests.PriorityQueues.ValType >> valTypeUpdatableQueueBuilder Properties | Improve this Doc View Source IntUpdatableQueueBuilder Declaration protected Func<IUpdatablePriorityQueue<int>> IntUpdatableQueueBuilder { get; } Property Value Type Description Func < IUpdatablePriorityQueue < System.Int32 >> | Improve this Doc View Source RefTypeUpdatableQueueBuilder Declaration protected Func<IUpdatablePriorityQueue<RefType>> RefTypeUpdatableQueueBuilder { get; } Property Value Type Description Func < IUpdatablePriorityQueue < RefType >> | Improve this Doc View Source ValTypeUpdatableQueueBuilder Declaration protected Func<IUpdatablePriorityQueue<ValType>> ValTypeUpdatableQueueBuilder { get; } Property Value Type Description Func < IUpdatablePriorityQueue < MoreStructures.Tests.PriorityQueues.ValType >> Methods | Improve this Doc View Source GetPrioritiesOf_FirstIsCorrect() Declaration public void GetPrioritiesOf_FirstIsCorrect() | Improve this Doc View Source GetPrioritiesOf_IsCorrect() Declaration public void GetPrioritiesOf_IsCorrect() | Improve this Doc View Source Remove_IsCorrect() Declaration public void Remove_IsCorrect() | Improve this Doc View Source Remove_WorksWithReferenceTypes() Declaration public void Remove_WorksWithReferenceTypes() | Improve this Doc View Source Remove_WorksWithValueTypes() Declaration public void Remove_WorksWithValueTypes() | Improve this Doc View Source UpdatePriority_AllPermutations() Declaration public void UpdatePriority_AllPermutations() | Improve this Doc View Source UpdatePriority_IsCorrect() Declaration public void UpdatePriority_IsCorrect() | Improve this Doc View Source UpdatePriority_IsStableWithInt() Declaration public void UpdatePriority_IsStableWithInt() | Improve this Doc View Source UpdatePriority_IsStableWithReferenceTypes() Declaration public void UpdatePriority_IsStableWithReferenceTypes() | Improve this Doc View Source UpdatePriority_LongChainOfUpdates(Int32[], Int32[], Int32[]) Declaration public void UpdatePriority_LongChainOfUpdates(int[] values, int[] priorities, int[] updatePriorities) Parameters Type Name Description System.Int32 [] values System.Int32 [] priorities System.Int32 [] updatePriorities | Improve this Doc View Source UpdatePriority_RaisesExceptionOnItemNonPresent() Declaration public void UpdatePriority_RaisesExceptionOnItemNonPresent() | Improve this Doc View Source UpdatePriority_StalePushTimestamps() Declaration public void UpdatePriority_StalePushTimestamps() | Improve this Doc View Source UpdatePriority_WorksWhenNewPriorityIsTheSame() Declaration public void UpdatePriority_WorksWhenNewPriorityIsTheSame() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Queues.ArrayListQueueTests.html": {
    "href": "api/MoreStructures.Tests.Queues.ArrayListQueueTests.html",
    "title": "Class ArrayListQueueTests",
    "keywords": "Class ArrayListQueueTests Inheritance System.Object QueueTests ArrayListQueueTests Inherited Members QueueTests.Peek_RaisesExceptionOnEmptyQueue() QueueTests.Dequeue_RaisesExceptionOnEmptyQueue() QueueTests.Peek_IsCorrect() QueueTests.Count_IsCorrect() QueueTests.EnqueueAndDequeue_AreCorrect() QueueTests.EnqueueAndDequeue_WorkWhenExecutedInBursts() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Queues Assembly : MoreStructures.Tests.dll Syntax public class ArrayListQueueTests : QueueTests Methods | Improve this Doc View Source Build<T>() Declaration protected override IQueue<T> Build<T>() Returns Type Description IQueue <T> Type Parameters Name Description T Overrides QueueTests.Build<T>() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Queues.html": {
    "href": "api/MoreStructures.Tests.Queues.html",
    "title": "Namespace MoreStructures.Tests.Queues",
    "keywords": "Namespace MoreStructures.Tests.Queues Classes ArrayListQueueTests LinkedListQueueTests QueueTests"
  },
  "api/MoreStructures.Tests.Queues.LinkedListQueueTests.html": {
    "href": "api/MoreStructures.Tests.Queues.LinkedListQueueTests.html",
    "title": "Class LinkedListQueueTests",
    "keywords": "Class LinkedListQueueTests Inheritance System.Object QueueTests LinkedListQueueTests Inherited Members QueueTests.Peek_RaisesExceptionOnEmptyQueue() QueueTests.Dequeue_RaisesExceptionOnEmptyQueue() QueueTests.Peek_IsCorrect() QueueTests.Count_IsCorrect() QueueTests.EnqueueAndDequeue_AreCorrect() QueueTests.EnqueueAndDequeue_WorkWhenExecutedInBursts() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Queues Assembly : MoreStructures.Tests.dll Syntax public class LinkedListQueueTests : QueueTests Methods | Improve this Doc View Source Build<T>() Declaration protected override IQueue<T> Build<T>() Returns Type Description IQueue <T> Type Parameters Name Description T Overrides QueueTests.Build<T>() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Queues.QueueTests.html": {
    "href": "api/MoreStructures.Tests.Queues.QueueTests.html",
    "title": "Class QueueTests",
    "keywords": "Class QueueTests Inheritance System.Object QueueTests ArrayListQueueTests LinkedListQueueTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Queues Assembly : MoreStructures.Tests.dll Syntax public abstract class QueueTests Methods | Improve this Doc View Source Build<T>() Declaration protected abstract IQueue<T> Build<T>() Returns Type Description IQueue <T> Type Parameters Name Description T | Improve this Doc View Source Count_IsCorrect() Declaration public void Count_IsCorrect() | Improve this Doc View Source Dequeue_RaisesExceptionOnEmptyQueue() Declaration public void Dequeue_RaisesExceptionOnEmptyQueue() | Improve this Doc View Source EnqueueAndDequeue_AreCorrect() Declaration public void EnqueueAndDequeue_AreCorrect() | Improve this Doc View Source EnqueueAndDequeue_WorkWhenExecutedInBursts() Declaration public void EnqueueAndDequeue_WorkWhenExecutedInBursts() | Improve this Doc View Source Peek_IsCorrect() Declaration public void Peek_IsCorrect() | Improve this Doc View Source Peek_RaisesExceptionOnEmptyQueue() Declaration public void Peek_RaisesExceptionOnEmptyQueue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.Conversions.FullyIterativeStringifierTests.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Conversions.FullyIterativeStringifierTests.html",
    "title": "Class FullyIterativeStringifierTests",
    "keywords": "Class FullyIterativeStringifierTests Inheritance System.Object StringifierTests FullyIterativeStringifierTests Inherited Members StringifierTests.Stringifier StringifierTests.NL StringifierTests.I StringifierTests.DefaultNewLine StringifierTests.DefaultIndent StringifierTests.DefaultPathSeparator StringifierTests.DefaultRootStringifier StringifierTests.DefaultEdgeAndNodeStringifier StringifierTests.Stringify_OfLeaf() StringifierTests.Stringify_OfTwoLevelsTree() StringifierTests.Stringify_OfThreeLevelsTree() StringifierTests.Stringify_OfFourLevelsTree() StringifierTests.Stringify_OfEmptyPath() StringifierTests.Stringify_OfSingletonPath() StringifierTests.Stringify_OfMultistepPath() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees.Conversions Assembly : MoreStructures.Tests.dll Syntax public class FullyIterativeStringifierTests : StringifierTests Constructors | Improve this Doc View Source FullyIterativeStringifierTests() Declaration public FullyIterativeStringifierTests() Methods | Improve this Doc View Source PrependLevelAfterStopIndenting_RendersLevelWhenStopIndentingLevelIsReached() Declaration public void PrependLevelAfterStopIndenting_RendersLevelWhenStopIndentingLevelIsReached() | Improve this Doc View Source StopIndentingLevel_StopsIndentingWhenReached_WithOne() Declaration public void StopIndentingLevel_StopsIndentingWhenReached_WithOne() | Improve this Doc View Source StopIndentingLevel_StopsIndentingWhenReached_WithTwo() Declaration public void StopIndentingLevel_StopsIndentingWhenReached_WithTwo() | Improve this Doc View Source StopIndentingLevel_StopsIndentingWhenReached_WithZero() Declaration public void StopIndentingLevel_StopsIndentingWhenReached_WithZero() | Improve this Doc View Source Stringify_DoesntStackOverflowWithDeepStructures() Declaration public void Stringify_DoesntStackOverflowWithDeepStructures() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.Conversions.FullyRecursiveStringifierTests.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Conversions.FullyRecursiveStringifierTests.html",
    "title": "Class FullyRecursiveStringifierTests",
    "keywords": "Class FullyRecursiveStringifierTests Inheritance System.Object StringifierTests StringifierBaseTests FullyRecursiveStringifierTests Inherited Members StringifierBaseTests.CustomNewLine_IsReflectedIntoOutput() StringifierBaseTests.CustomIndent_IsReflectedIntoOutput() StringifierTests.Stringifier StringifierTests.NL StringifierTests.I StringifierTests.DefaultNewLine StringifierTests.DefaultIndent StringifierTests.DefaultPathSeparator StringifierTests.DefaultRootStringifier StringifierTests.DefaultEdgeAndNodeStringifier StringifierTests.Stringify_OfLeaf() StringifierTests.Stringify_OfTwoLevelsTree() StringifierTests.Stringify_OfThreeLevelsTree() StringifierTests.Stringify_OfFourLevelsTree() StringifierTests.Stringify_OfEmptyPath() StringifierTests.Stringify_OfSingletonPath() StringifierTests.Stringify_OfMultistepPath() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees.Conversions Assembly : MoreStructures.Tests.dll Syntax public class FullyRecursiveStringifierTests : StringifierBaseTests Constructors | Improve this Doc View Source FullyRecursiveStringifierTests() Declaration public FullyRecursiveStringifierTests() Methods | Improve this Doc View Source Stringify_DoesntStackOverflowWithNotSoDeepStructures() Declaration public void Stringify_DoesntStackOverflowWithNotSoDeepStructures() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.Conversions.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Conversions.html",
    "title": "Namespace MoreStructures.Tests.RecImmTrees.Conversions",
    "keywords": "Namespace MoreStructures.Tests.RecImmTrees.Conversions Classes FullyIterativeStringifierTests FullyRecursiveStringifierTests StringifierBaseTests StringifierTests"
  },
  "api/MoreStructures.Tests.RecImmTrees.Conversions.StringifierBaseTests.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Conversions.StringifierBaseTests.html",
    "title": "Class StringifierBaseTests",
    "keywords": "Class StringifierBaseTests Inheritance System.Object StringifierTests StringifierBaseTests FullyRecursiveStringifierTests Inherited Members StringifierTests.Stringifier StringifierTests.NL StringifierTests.I StringifierTests.DefaultNewLine StringifierTests.DefaultIndent StringifierTests.DefaultPathSeparator StringifierTests.DefaultRootStringifier StringifierTests.DefaultEdgeAndNodeStringifier StringifierTests.Stringify_OfLeaf() StringifierTests.Stringify_OfTwoLevelsTree() StringifierTests.Stringify_OfThreeLevelsTree() StringifierTests.Stringify_OfFourLevelsTree() StringifierTests.Stringify_OfEmptyPath() StringifierTests.Stringify_OfSingletonPath() StringifierTests.Stringify_OfMultistepPath() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees.Conversions Assembly : MoreStructures.Tests.dll Syntax public abstract class StringifierBaseTests : StringifierTests Constructors | Improve this Doc View Source StringifierBaseTests(IStringifier<TreeMock.Edge, TreeMock.Node>) Declaration public StringifierBaseTests(IStringifier<TreeMock.Edge, TreeMock.Node> stringifier) Parameters Type Name Description IStringifier < TreeMock.Edge , TreeMock.Node > stringifier Methods | Improve this Doc View Source CustomIndent_IsReflectedIntoOutput() Declaration public void CustomIndent_IsReflectedIntoOutput() | Improve this Doc View Source CustomNewLine_IsReflectedIntoOutput() Declaration public void CustomNewLine_IsReflectedIntoOutput() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.Conversions.StringifierTests.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Conversions.StringifierTests.html",
    "title": "Class StringifierTests",
    "keywords": "Class StringifierTests Inheritance System.Object StringifierTests FullyIterativeStringifierTests StringifierBaseTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees.Conversions Assembly : MoreStructures.Tests.dll Syntax public abstract class StringifierTests Constructors | Improve this Doc View Source StringifierTests(IStringifier<TreeMock.Edge, TreeMock.Node>) Declaration public StringifierTests(IStringifier<TreeMock.Edge, TreeMock.Node> stringifier) Parameters Type Name Description IStringifier < TreeMock.Edge , TreeMock.Node > stringifier Fields | Improve this Doc View Source DefaultEdgeAndNodeStringifier Declaration protected static readonly Func<TreeMock.Edge, TreeMock.Node, string> DefaultEdgeAndNodeStringifier Field Value Type Description Func < TreeMock.Edge , TreeMock.Node , System.String > | Improve this Doc View Source DefaultIndent Declaration protected static readonly string DefaultIndent Field Value Type Description System.String | Improve this Doc View Source DefaultNewLine Declaration protected static readonly string DefaultNewLine Field Value Type Description System.String | Improve this Doc View Source DefaultPathSeparator Declaration protected static readonly string DefaultPathSeparator Field Value Type Description System.String | Improve this Doc View Source DefaultRootStringifier Declaration protected static readonly Func<TreeMock.Node, string> DefaultRootStringifier Field Value Type Description Func < TreeMock.Node , System.String > Properties | Improve this Doc View Source I Declaration protected string I { get; } Property Value Type Description System.String | Improve this Doc View Source NL Declaration protected string NL { get; } Property Value Type Description System.String | Improve this Doc View Source Stringifier Declaration protected IStringifier<TreeMock.Edge, TreeMock.Node> Stringifier { get; set; } Property Value Type Description IStringifier < TreeMock.Edge , TreeMock.Node > Methods | Improve this Doc View Source Stringify_OfEmptyPath() Declaration public void Stringify_OfEmptyPath() | Improve this Doc View Source Stringify_OfFourLevelsTree() Declaration public void Stringify_OfFourLevelsTree() | Improve this Doc View Source Stringify_OfLeaf() Declaration public void Stringify_OfLeaf() | Improve this Doc View Source Stringify_OfMultistepPath() Declaration public void Stringify_OfMultistepPath() | Improve this Doc View Source Stringify_OfSingletonPath() Declaration public void Stringify_OfSingletonPath() | Improve this Doc View Source Stringify_OfThreeLevelsTree() Declaration public void Stringify_OfThreeLevelsTree() | Improve this Doc View Source Stringify_OfTwoLevelsTree() Declaration public void Stringify_OfTwoLevelsTree() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.html",
    "title": "Namespace MoreStructures.Tests.RecImmTrees",
    "keywords": "Namespace MoreStructures.Tests.RecImmTrees Classes RecImmDictIndexedTreeNodeExtensionsTests TreeMock TreeMock.Edge TreeMock.Node TreePathExtensionsTests TreePathTests"
  },
  "api/MoreStructures.Tests.RecImmTrees.Paths.FullyIterativeNodeToLeafPathsBuilderTests.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Paths.FullyIterativeNodeToLeafPathsBuilderTests.html",
    "title": "Class FullyIterativeNodeToLeafPathsBuilderTests",
    "keywords": "Class FullyIterativeNodeToLeafPathsBuilderTests Inheritance System.Object NodeToLeafPathsBuilderTests FullyIterativeNodeToLeafPathsBuilderTests Inherited Members NodeToLeafPathsBuilderTests.Builder NodeToLeafPathsBuilderTests.GetAllNodeToLeafPaths__DocExample() NodeToLeafPathsBuilderTests.GetAllNodeToLeafPaths_IsCorrectWithTries() NodeToLeafPathsBuilderTests.GetAllNodeToLeafPaths_IsCorrectWithTrees() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees.Paths Assembly : MoreStructures.Tests.dll Syntax public class FullyIterativeNodeToLeafPathsBuilderTests : NodeToLeafPathsBuilderTests Constructors | Improve this Doc View Source FullyIterativeNodeToLeafPathsBuilderTests() Declaration public FullyIterativeNodeToLeafPathsBuilderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.Paths.FullyRecursiveNodeToLeafPathsBuilderTests.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Paths.FullyRecursiveNodeToLeafPathsBuilderTests.html",
    "title": "Class FullyRecursiveNodeToLeafPathsBuilderTests",
    "keywords": "Class FullyRecursiveNodeToLeafPathsBuilderTests Inheritance System.Object NodeToLeafPathsBuilderTests FullyRecursiveNodeToLeafPathsBuilderTests Inherited Members NodeToLeafPathsBuilderTests.Builder NodeToLeafPathsBuilderTests.GetAllNodeToLeafPaths__DocExample() NodeToLeafPathsBuilderTests.GetAllNodeToLeafPaths_IsCorrectWithTries() NodeToLeafPathsBuilderTests.GetAllNodeToLeafPaths_IsCorrectWithTrees() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees.Paths Assembly : MoreStructures.Tests.dll Syntax public class FullyRecursiveNodeToLeafPathsBuilderTests : NodeToLeafPathsBuilderTests Constructors | Improve this Doc View Source FullyRecursiveNodeToLeafPathsBuilderTests() Declaration public FullyRecursiveNodeToLeafPathsBuilderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.Paths.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Paths.html",
    "title": "Namespace MoreStructures.Tests.RecImmTrees.Paths",
    "keywords": "Namespace MoreStructures.Tests.RecImmTrees.Paths Classes FullyIterativeNodeToLeafPathsBuilderTests FullyRecursiveNodeToLeafPathsBuilderTests NodeToLeafPathsBuilderTests"
  },
  "api/MoreStructures.Tests.RecImmTrees.Paths.NodeToLeafPathsBuilderTests.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Paths.NodeToLeafPathsBuilderTests.html",
    "title": "Class NodeToLeafPathsBuilderTests",
    "keywords": "Class NodeToLeafPathsBuilderTests Inheritance System.Object NodeToLeafPathsBuilderTests FullyIterativeNodeToLeafPathsBuilderTests FullyRecursiveNodeToLeafPathsBuilderTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees.Paths Assembly : MoreStructures.Tests.dll Syntax public abstract class NodeToLeafPathsBuilderTests Constructors | Improve this Doc View Source NodeToLeafPathsBuilderTests(INodeToLeafPathsBuilder) Declaration protected NodeToLeafPathsBuilderTests(INodeToLeafPathsBuilder builder) Parameters Type Name Description INodeToLeafPathsBuilder builder Properties | Improve this Doc View Source Builder Declaration protected INodeToLeafPathsBuilder Builder { get; } Property Value Type Description INodeToLeafPathsBuilder Methods | Improve this Doc View Source GetAllNodeToLeafPaths__DocExample() Declaration public void GetAllNodeToLeafPaths__DocExample() | Improve this Doc View Source GetAllNodeToLeafPaths_IsCorrectWithTrees() Declaration public void GetAllNodeToLeafPaths_IsCorrectWithTrees() | Improve this Doc View Source GetAllNodeToLeafPaths_IsCorrectWithTries() Declaration public void GetAllNodeToLeafPaths_IsCorrectWithTries() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.RecImmDictIndexedTreeNodeExtensionsTests.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.RecImmDictIndexedTreeNodeExtensionsTests.html",
    "title": "Class RecImmDictIndexedTreeNodeExtensionsTests",
    "keywords": "Class RecImmDictIndexedTreeNodeExtensionsTests Inheritance System.Object RecImmDictIndexedTreeNodeExtensionsTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees Assembly : MoreStructures.Tests.dll Syntax public class RecImmDictIndexedTreeNodeExtensionsTests Methods | Improve this Doc View Source IsLeaf_IsCorrectForSuffixTree() Declaration public void IsLeaf_IsCorrectForSuffixTree() | Improve this Doc View Source IsLeaf_IsCorrectForSuffixTrie() Declaration public void IsLeaf_IsCorrectForSuffixTrie() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.TreeMock.Edge.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.TreeMock.Edge.html",
    "title": "Class TreeMock.Edge",
    "keywords": "Class TreeMock.Edge Inheritance System.Object TreeMock.Edge Implements IRecImmDictIndexedTreeEdge < TreeMock.Edge , TreeMock.Node > IComparable < TreeMock.Edge > System.IEquatable < TreeMock.Edge > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.Tests.RecImmTrees Assembly : MoreStructures.Tests.dll Syntax public class Edge : IRecImmDictIndexedTreeEdge<TreeMock.Edge, TreeMock.Node>, IEquatable<TreeMock.Edge> Constructors | Improve this Doc View Source Edge(Int32) Declaration public Edge(int Id) Parameters Type Name Description System.Int32 Id Properties | Improve this Doc View Source Id Declaration public int Id { get; set; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source CompareTo(TreeMock.Edge) Declaration public int CompareTo(TreeMock.Edge other) Parameters Type Name Description TreeMock.Edge other Returns Type Description System.Int32 | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Implements IRecImmDictIndexedTreeEdge<TEdge, TNode> IComparable<> System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.TreeMock.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.TreeMock.html",
    "title": "Class TreeMock",
    "keywords": "Class TreeMock Inheritance System.Object TreeMock Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees Assembly : MoreStructures.Tests.dll Syntax public static class TreeMock Methods | Improve this Doc View Source BuildDocExample() Declaration public static TreeMock.Node BuildDocExample() Returns Type Description TreeMock.Node | Improve this Doc View Source BuildExampleTree() Declaration public static TreeMock.Node BuildExampleTree() Returns Type Description TreeMock.Node | Improve this Doc View Source BuildMostUnbalancedTree(Int32) Declaration public static TreeMock.Node BuildMostUnbalancedTree(int numberOfIntermediateNodes) Parameters Type Name Description System.Int32 numberOfIntermediateNodes Returns Type Description TreeMock.Node | Improve this Doc View Source BuildMultiLevelsBacktrackTree() Declaration public static TreeMock.Node BuildMultiLevelsBacktrackTree() Returns Type Description TreeMock.Node | Improve this Doc View Source EdgeIdBasedChildrenSorter(TreeTraversalVisit<TreeMock.Edge, TreeMock.Node>) Declaration public static IEnumerable<KeyValuePair<TreeMock.Edge, TreeMock.Node>> EdgeIdBasedChildrenSorter(TreeTraversalVisit<TreeMock.Edge, TreeMock.Node> visit) Parameters Type Name Description TreeTraversalVisit < TreeMock.Edge , TreeMock.Node > visit Returns Type Description IEnumerable < KeyValuePair < TreeMock.Edge , TreeMock.Node >> | Improve this Doc View Source EdgeIdDescBasedChildrenSorter(TreeTraversalVisit<TreeMock.Edge, TreeMock.Node>) Declaration public static IEnumerable<KeyValuePair<TreeMock.Edge, TreeMock.Node>> EdgeIdDescBasedChildrenSorter(TreeTraversalVisit<TreeMock.Edge, TreeMock.Node> visit) Parameters Type Name Description TreeTraversalVisit < TreeMock.Edge , TreeMock.Node > visit Returns Type Description IEnumerable < KeyValuePair < TreeMock.Edge , TreeMock.Node >> | Improve this Doc View Source EdgeIdMedianBasedChildrenSorter(TreeTraversalVisit<TreeMock.Edge, TreeMock.Node>) Declaration public static IEnumerable<KeyValuePair<TreeMock.Edge, TreeMock.Node>> EdgeIdMedianBasedChildrenSorter(TreeTraversalVisit<TreeMock.Edge, TreeMock.Node> visit) Parameters Type Name Description TreeTraversalVisit < TreeMock.Edge , TreeMock.Node > visit Returns Type Description IEnumerable < KeyValuePair < TreeMock.Edge , TreeMock.Node >>"
  },
  "api/MoreStructures.Tests.RecImmTrees.TreeMock.Node.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.TreeMock.Node.html",
    "title": "Class TreeMock.Node",
    "keywords": "Class TreeMock.Node Inheritance System.Object TreeMock.Node Implements IRecImmDictIndexedTreeNode < TreeMock.Edge , TreeMock.Node > System.IEquatable < TreeMock.Node > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.Tests.RecImmTrees Assembly : MoreStructures.Tests.dll Syntax public class Node : IRecImmDictIndexedTreeNode<TreeMock.Edge, TreeMock.Node>, IEquatable<TreeMock.Node> Constructors | Improve this Doc View Source Node(Int32) Declaration public Node(int id) Parameters Type Name Description System.Int32 id | Improve this Doc View Source Node(Int32, IDictionary<TreeMock.Edge, TreeMock.Node>) Declaration public Node(int Id, IDictionary<TreeMock.Edge, TreeMock.Node> Children) Parameters Type Name Description System.Int32 Id IDictionary < TreeMock.Edge , TreeMock.Node > Children Properties | Improve this Doc View Source Children Declaration public IDictionary<TreeMock.Edge, TreeMock.Node> Children { get; set; } Property Value Type Description IDictionary < TreeMock.Edge , TreeMock.Node > | Improve this Doc View Source Id Declaration public int Id { get; set; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Implements IRecImmDictIndexedTreeNode<TEdge, TNode> System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.TreePathExtensionsTests.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.TreePathExtensionsTests.html",
    "title": "Class TreePathExtensionsTests",
    "keywords": "Class TreePathExtensionsTests Inheritance System.Object TreePathExtensionsTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees Assembly : MoreStructures.Tests.dll Syntax public class TreePathExtensionsTests Methods | Improve this Doc View Source Append_IsCorrect() Declaration public void Append_IsCorrect() | Improve this Doc View Source Concat_IsCorrectAppendingEmptyPath() Declaration public void Concat_IsCorrectAppendingEmptyPath() | Improve this Doc View Source Concat_IsCorrectPrependingEmptyPath() Declaration public void Concat_IsCorrectPrependingEmptyPath() | Improve this Doc View Source Concat_IsCorrectWithTwoNonEmptyPaths() Declaration public void Concat_IsCorrectWithTwoNonEmptyPaths() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.TreePathTests.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.TreePathTests.html",
    "title": "Class TreePathTests",
    "keywords": "Class TreePathTests Inheritance System.Object TreePathTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees Assembly : MoreStructures.Tests.dll Syntax public class TreePathTests Methods | Improve this Doc View Source Ctor_OfSuffixTree_EmptyPath_IsCorrect() Declaration public void Ctor_OfSuffixTree_EmptyPath_IsCorrect() | Improve this Doc View Source Ctor_OfSuffixTree_MultistepPath_IsCorrectWithEnumerable() Declaration public void Ctor_OfSuffixTree_MultistepPath_IsCorrectWithEnumerable() | Improve this Doc View Source Ctor_OfSuffixTree_MultistepPath_IsCorrectWithParams() Declaration public void Ctor_OfSuffixTree_MultistepPath_IsCorrectWithParams() | Improve this Doc View Source Ctor_OfSuffixTree_SingletonPath_IsCorrect() Declaration public void Ctor_OfSuffixTree_SingletonPath_IsCorrect() | Improve this Doc View Source Ctor_OfSuffixTrie_EmptyPath_IsCorrect() Declaration public void Ctor_OfSuffixTrie_EmptyPath_IsCorrect() | Improve this Doc View Source Ctor_OfSuffixTrie_MultistepPath_IsCorrectWithEnumerable() Declaration public void Ctor_OfSuffixTrie_MultistepPath_IsCorrectWithEnumerable() | Improve this Doc View Source Ctor_OfSuffixTrie_MultistepPath_IsCorrectWithParams() Declaration public void Ctor_OfSuffixTrie_MultistepPath_IsCorrectWithParams() | Improve this Doc View Source Ctor_OfSuffixTrie_SingletonPath_IsCorrect() Declaration public void Ctor_OfSuffixTrie_SingletonPath_IsCorrect() | Improve this Doc View Source Equals_ByValue() Declaration public void Equals_ByValue() | Improve this Doc View Source Equals_TakesIntoAccountPathNodesOrder() Declaration public void Equals_TakesIntoAccountPathNodesOrder() | Improve this Doc View Source GetHashCode_ByValue() Declaration public void GetHashCode_ByValue() | Improve this Doc View Source PathNodes_OfSuffixTree_ImmutabilityOnCtorParam() Declaration public void PathNodes_OfSuffixTree_ImmutabilityOnCtorParam() | Improve this Doc View Source PathNodes_OfSuffixTree_ImmutabilityOnGet() Declaration public void PathNodes_OfSuffixTree_ImmutabilityOnGet() | Improve this Doc View Source PathNodes_OfSuffixTrie_ImmutabilityOnCtorParam() Declaration public void PathNodes_OfSuffixTrie_ImmutabilityOnCtorParam() | Improve this Doc View Source PathNodes_OfSuffixTrie_ImmutabilityOnGet() Declaration public void PathNodes_OfSuffixTrie_ImmutabilityOnGet() | Improve this Doc View Source ToString_IsTheSameOnEquivalentPaths() Declaration public void ToString_IsTheSameOnEquivalentPaths() | Improve this Doc View Source ToString_OfEmptyPathIsEmptyString() Declaration public void ToString_OfEmptyPathIsEmptyString() | Improve this Doc View Source ToString_OfNonEmptyPathIsNonEmptyString() Declaration public void ToString_OfNonEmptyPathIsNonEmptyString() | Improve this Doc View Source ToString_OfPathContainsToStringOfSubPath() Declaration public void ToString_OfPathContainsToStringOfSubPath() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.Visitor.BreadthFirstTraversalTests-1.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Visitor.BreadthFirstTraversalTests-1.html",
    "title": "Class BreadthFirstTraversalTests<TBreadthFirstTraversal>",
    "keywords": "Class BreadthFirstTraversalTests<TBreadthFirstTraversal> Inheritance System.Object TreeTraversalTests <TBreadthFirstTraversal> BreadthFirstTraversalTests<TBreadthFirstTraversal> FullyIterativeBreadthFirstTraversalTests FullyRecursiveBreadthFirstTraversalTests Inherited Members TreeTraversalTests<TBreadthFirstTraversal>.Visit_ParentIsCorrect() TreeTraversalTests<TBreadthFirstTraversal>.Visit_IncomingEdgeIsCorrect() TreeTraversalTests<TBreadthFirstTraversal>.Visit_LevelIsCorrect() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees.Visitor Assembly : MoreStructures.Tests.dll Syntax public abstract class BreadthFirstTraversalTests<TBreadthFirstTraversal> : TreeTraversalTests<TBreadthFirstTraversal> where TBreadthFirstTraversal : BreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>, new() Type Parameters Name Description TBreadthFirstTraversal Methods | Improve this Doc View Source Visit_ChildrenSorter_IsApplied() Declaration public void Visit_ChildrenSorter_IsApplied() | Improve this Doc View Source Visit_DocExamples_ChildrenFirst() Declaration public void Visit_DocExamples_ChildrenFirst() | Improve this Doc View Source Visit_DocExamples_ParentFirst() Declaration public void Visit_DocExamples_ParentFirst() | Improve this Doc View Source Visit_TraversalOrderChildrenFirst() Declaration public void Visit_TraversalOrderChildrenFirst() | Improve this Doc View Source Visit_TraversalOrderChildrenFirst_MultiLevelsBacktrackTree() Declaration public void Visit_TraversalOrderChildrenFirst_MultiLevelsBacktrackTree() | Improve this Doc View Source Visit_TraversalOrderNotSupported_OnSingleton() Declaration public void Visit_TraversalOrderNotSupported_OnSingleton() | Improve this Doc View Source Visit_TraversalOrderNotSupported_OnTreeWithMultipleNodes() Declaration public void Visit_TraversalOrderNotSupported_OnTreeWithMultipleNodes() | Improve this Doc View Source Visit_TraversalOrderParentFirst() Declaration public void Visit_TraversalOrderParentFirst() | Improve this Doc View Source Visit_TraversalOrderParentFirst_MultiLevelsBacktrackTree() Declaration public void Visit_TraversalOrderParentFirst_MultiLevelsBacktrackTree() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.Visitor.DepthFirstTraversalTests-1.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Visitor.DepthFirstTraversalTests-1.html",
    "title": "Class DepthFirstTraversalTests<TDepthFirstTraversal>",
    "keywords": "Class DepthFirstTraversalTests<TDepthFirstTraversal> Inheritance System.Object TreeTraversalTests <TDepthFirstTraversal> DepthFirstTraversalTests<TDepthFirstTraversal> FullyIterativeDepthFirstTraversalTests FullyRecursiveDepthFirstTraversalTests Inherited Members TreeTraversalTests<TDepthFirstTraversal>.Visit_ParentIsCorrect() TreeTraversalTests<TDepthFirstTraversal>.Visit_IncomingEdgeIsCorrect() TreeTraversalTests<TDepthFirstTraversal>.Visit_LevelIsCorrect() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees.Visitor Assembly : MoreStructures.Tests.dll Syntax public abstract class DepthFirstTraversalTests<TDepthFirstTraversal> : TreeTraversalTests<TDepthFirstTraversal> where TDepthFirstTraversal : DepthFirstTraversal<TreeMock.Edge, TreeMock.Node>, new() Type Parameters Name Description TDepthFirstTraversal Methods | Improve this Doc View Source Visit_ChildrenSorter_IsApplied() Declaration public void Visit_ChildrenSorter_IsApplied() | Improve this Doc View Source Visit_DocExamples_ChildrenFirst() Declaration public void Visit_DocExamples_ChildrenFirst() | Improve this Doc View Source Visit_DocExamples_ParentFirst() Declaration public void Visit_DocExamples_ParentFirst() | Improve this Doc View Source Visit_MultiLevelsBacktrackTree() Declaration public void Visit_MultiLevelsBacktrackTree() | Improve this Doc View Source Visit_TraversalOrderChildrenFirst() Declaration public void Visit_TraversalOrderChildrenFirst() | Improve this Doc View Source Visit_TraversalOrderNotSupported_OnSingleton() Declaration public void Visit_TraversalOrderNotSupported_OnSingleton() | Improve this Doc View Source Visit_TraversalOrderNotSupported_OnTreeWithMultipleNodes() Declaration public void Visit_TraversalOrderNotSupported_OnTreeWithMultipleNodes() | Improve this Doc View Source Visit_TraversalOrderParentFirst() Declaration public void Visit_TraversalOrderParentFirst() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.Visitor.FullyIterativeBreadthFirstTraversalTests.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Visitor.FullyIterativeBreadthFirstTraversalTests.html",
    "title": "Class FullyIterativeBreadthFirstTraversalTests",
    "keywords": "Class FullyIterativeBreadthFirstTraversalTests Inheritance System.Object TreeTraversalTests < FullyIterativeBreadthFirstTraversal < TreeMock.Edge , TreeMock.Node >> BreadthFirstTraversalTests < FullyIterativeBreadthFirstTraversal < TreeMock.Edge , TreeMock.Node >> FullyIterativeBreadthFirstTraversalTests Inherited Members BreadthFirstTraversalTests<FullyIterativeBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_DocExamples_ParentFirst() BreadthFirstTraversalTests<FullyIterativeBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_DocExamples_ChildrenFirst() BreadthFirstTraversalTests<FullyIterativeBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderParentFirst() BreadthFirstTraversalTests<FullyIterativeBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderChildrenFirst() BreadthFirstTraversalTests<FullyIterativeBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderNotSupported_OnSingleton() BreadthFirstTraversalTests<FullyIterativeBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderNotSupported_OnTreeWithMultipleNodes() BreadthFirstTraversalTests<FullyIterativeBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_ChildrenSorter_IsApplied() BreadthFirstTraversalTests<FullyIterativeBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderParentFirst_MultiLevelsBacktrackTree() BreadthFirstTraversalTests<FullyIterativeBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderChildrenFirst_MultiLevelsBacktrackTree() TreeTraversalTests<FullyIterativeBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_ParentIsCorrect() TreeTraversalTests<FullyIterativeBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_IncomingEdgeIsCorrect() TreeTraversalTests<FullyIterativeBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_LevelIsCorrect() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees.Visitor Assembly : MoreStructures.Tests.dll Syntax public class FullyIterativeBreadthFirstTraversalTests : BreadthFirstTraversalTests<FullyIterativeBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>> Methods | Improve this Doc View Source Visit_DoesntOverflowWithDeepStructures() Declaration public void Visit_DoesntOverflowWithDeepStructures() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.Visitor.FullyIterativeDepthFirstTraversalTests.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Visitor.FullyIterativeDepthFirstTraversalTests.html",
    "title": "Class FullyIterativeDepthFirstTraversalTests",
    "keywords": "Class FullyIterativeDepthFirstTraversalTests Inheritance System.Object TreeTraversalTests < FullyIterativeDepthFirstTraversal < TreeMock.Edge , TreeMock.Node >> DepthFirstTraversalTests < FullyIterativeDepthFirstTraversal < TreeMock.Edge , TreeMock.Node >> FullyIterativeDepthFirstTraversalTests Inherited Members DepthFirstTraversalTests<FullyIterativeDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_DocExamples_ParentFirst() DepthFirstTraversalTests<FullyIterativeDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_DocExamples_ChildrenFirst() DepthFirstTraversalTests<FullyIterativeDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderParentFirst() DepthFirstTraversalTests<FullyIterativeDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderChildrenFirst() DepthFirstTraversalTests<FullyIterativeDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderNotSupported_OnSingleton() DepthFirstTraversalTests<FullyIterativeDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderNotSupported_OnTreeWithMultipleNodes() DepthFirstTraversalTests<FullyIterativeDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_ChildrenSorter_IsApplied() DepthFirstTraversalTests<FullyIterativeDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_MultiLevelsBacktrackTree() TreeTraversalTests<FullyIterativeDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_ParentIsCorrect() TreeTraversalTests<FullyIterativeDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_IncomingEdgeIsCorrect() TreeTraversalTests<FullyIterativeDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_LevelIsCorrect() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees.Visitor Assembly : MoreStructures.Tests.dll Syntax public class FullyIterativeDepthFirstTraversalTests : DepthFirstTraversalTests<FullyIterativeDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>> Methods | Improve this Doc View Source Visit_DoesntOverflowWithDeepStructures() Declaration public void Visit_DoesntOverflowWithDeepStructures() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.Visitor.FullyRecursiveBreadthFirstTraversalTests.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Visitor.FullyRecursiveBreadthFirstTraversalTests.html",
    "title": "Class FullyRecursiveBreadthFirstTraversalTests",
    "keywords": "Class FullyRecursiveBreadthFirstTraversalTests Inheritance System.Object TreeTraversalTests < FullyRecursiveBreadthFirstTraversal < TreeMock.Edge , TreeMock.Node >> BreadthFirstTraversalTests < FullyRecursiveBreadthFirstTraversal < TreeMock.Edge , TreeMock.Node >> FullyRecursiveBreadthFirstTraversalTests Inherited Members BreadthFirstTraversalTests<FullyRecursiveBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_DocExamples_ParentFirst() BreadthFirstTraversalTests<FullyRecursiveBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_DocExamples_ChildrenFirst() BreadthFirstTraversalTests<FullyRecursiveBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderParentFirst() BreadthFirstTraversalTests<FullyRecursiveBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderChildrenFirst() BreadthFirstTraversalTests<FullyRecursiveBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderNotSupported_OnSingleton() BreadthFirstTraversalTests<FullyRecursiveBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderNotSupported_OnTreeWithMultipleNodes() BreadthFirstTraversalTests<FullyRecursiveBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_ChildrenSorter_IsApplied() BreadthFirstTraversalTests<FullyRecursiveBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderParentFirst_MultiLevelsBacktrackTree() BreadthFirstTraversalTests<FullyRecursiveBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderChildrenFirst_MultiLevelsBacktrackTree() TreeTraversalTests<FullyRecursiveBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_ParentIsCorrect() TreeTraversalTests<FullyRecursiveBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_IncomingEdgeIsCorrect() TreeTraversalTests<FullyRecursiveBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_LevelIsCorrect() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees.Visitor Assembly : MoreStructures.Tests.dll Syntax public class FullyRecursiveBreadthFirstTraversalTests : BreadthFirstTraversalTests<FullyRecursiveBreadthFirstTraversal<TreeMock.Edge, TreeMock.Node>> Methods | Improve this Doc View Source Visit_DoesntStackOverflowWithNotSoDeepStructures() Declaration public void Visit_DoesntStackOverflowWithNotSoDeepStructures() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.Visitor.FullyRecursiveDepthFirstTraversalTests.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Visitor.FullyRecursiveDepthFirstTraversalTests.html",
    "title": "Class FullyRecursiveDepthFirstTraversalTests",
    "keywords": "Class FullyRecursiveDepthFirstTraversalTests Inheritance System.Object TreeTraversalTests < FullyRecursiveDepthFirstTraversal < TreeMock.Edge , TreeMock.Node >> DepthFirstTraversalTests < FullyRecursiveDepthFirstTraversal < TreeMock.Edge , TreeMock.Node >> FullyRecursiveDepthFirstTraversalTests Inherited Members DepthFirstTraversalTests<FullyRecursiveDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_DocExamples_ParentFirst() DepthFirstTraversalTests<FullyRecursiveDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_DocExamples_ChildrenFirst() DepthFirstTraversalTests<FullyRecursiveDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderParentFirst() DepthFirstTraversalTests<FullyRecursiveDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderChildrenFirst() DepthFirstTraversalTests<FullyRecursiveDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderNotSupported_OnSingleton() DepthFirstTraversalTests<FullyRecursiveDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_TraversalOrderNotSupported_OnTreeWithMultipleNodes() DepthFirstTraversalTests<FullyRecursiveDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_ChildrenSorter_IsApplied() DepthFirstTraversalTests<FullyRecursiveDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_MultiLevelsBacktrackTree() TreeTraversalTests<FullyRecursiveDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_ParentIsCorrect() TreeTraversalTests<FullyRecursiveDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_IncomingEdgeIsCorrect() TreeTraversalTests<FullyRecursiveDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>>.Visit_LevelIsCorrect() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees.Visitor Assembly : MoreStructures.Tests.dll Syntax public class FullyRecursiveDepthFirstTraversalTests : DepthFirstTraversalTests<FullyRecursiveDepthFirstTraversal<TreeMock.Edge, TreeMock.Node>> Methods | Improve this Doc View Source Visit_DoesntStackOverflowWithNotSoDeepStructures() Declaration public void Visit_DoesntStackOverflowWithNotSoDeepStructures() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RecImmTrees.Visitor.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Visitor.html",
    "title": "Namespace MoreStructures.Tests.RecImmTrees.Visitor",
    "keywords": "Namespace MoreStructures.Tests.RecImmTrees.Visitor Classes BreadthFirstTraversalTests<TBreadthFirstTraversal> DepthFirstTraversalTests<TDepthFirstTraversal> FullyIterativeBreadthFirstTraversalTests FullyIterativeDepthFirstTraversalTests FullyRecursiveBreadthFirstTraversalTests FullyRecursiveDepthFirstTraversalTests TreeTraversalTests<TTreeTraversal>"
  },
  "api/MoreStructures.Tests.RecImmTrees.Visitor.TreeTraversalTests-1.html": {
    "href": "api/MoreStructures.Tests.RecImmTrees.Visitor.TreeTraversalTests-1.html",
    "title": "Class TreeTraversalTests<TTreeTraversal>",
    "keywords": "Class TreeTraversalTests<TTreeTraversal> Inheritance System.Object TreeTraversalTests<TTreeTraversal> BreadthFirstTraversalTests<TBreadthFirstTraversal> DepthFirstTraversalTests<TDepthFirstTraversal> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.RecImmTrees.Visitor Assembly : MoreStructures.Tests.dll Syntax public abstract class TreeTraversalTests<TTreeTraversal> where TTreeTraversal : TreeTraversal<TreeMock.Edge, TreeMock.Node>, new() Type Parameters Name Description TTreeTraversal Methods | Improve this Doc View Source Visit_IncomingEdgeIsCorrect() Declaration public void Visit_IncomingEdgeIsCorrect() | Improve this Doc View Source Visit_LevelIsCorrect() Declaration public void Visit_LevelIsCorrect() | Improve this Doc View Source Visit_ParentIsCorrect() Declaration public void Visit_ParentIsCorrect() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.RotatedTextWithTerminatorTests.html": {
    "href": "api/MoreStructures.Tests.RotatedTextWithTerminatorTests.html",
    "title": "Class RotatedTextWithTerminatorTests",
    "keywords": "Class RotatedTextWithTerminatorTests Inheritance System.Object RotatedTextWithTerminatorTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests Assembly : MoreStructures.Tests.dll Syntax public class RotatedTextWithTerminatorTests Methods | Improve this Doc View Source Ctor_Preconditions() Declaration public void Ctor_Preconditions() | Improve this Doc View Source EndsWith_IsCorrectWithEnumerable() Declaration public void EndsWith_IsCorrectWithEnumerable() | Improve this Doc View Source EndsWith_IsCorrectWithString() Declaration public void EndsWith_IsCorrectWithString() | Improve this Doc View Source Equals_IsByValueWithEnumerableOfChar() Declaration public void Equals_IsByValueWithEnumerableOfChar() | Improve this Doc View Source Equals_IsByValueWithListOfChar() Declaration public void Equals_IsByValueWithListOfChar() | Improve this Doc View Source Equals_IsByValueWithStrings() Declaration public void Equals_IsByValueWithStrings() | Improve this Doc View Source GetEnumerator_Generic_IsCorrect() Declaration public void GetEnumerator_Generic_IsCorrect() | Improve this Doc View Source GetEnumerator_Generic_WorksWithLinq() Declaration public void GetEnumerator_Generic_WorksWithLinq() | Improve this Doc View Source GetEnumerator_NonGeneric_IsCorrect() Declaration public void GetEnumerator_NonGeneric_IsCorrect() | Improve this Doc View Source Indexer_WithIndexOfEnumerable() Declaration public void Indexer_WithIndexOfEnumerable() | Improve this Doc View Source Indexer_WithIndexOfString() Declaration public void Indexer_WithIndexOfString() | Improve this Doc View Source Indexer_WithRangeOfEnumerable() Declaration public void Indexer_WithRangeOfEnumerable() | Improve this Doc View Source Indexer_WithRangeOfString() Declaration public void Indexer_WithRangeOfString() | Improve this Doc View Source Indexer_WithSelector() Declaration public void Indexer_WithSelector() | Improve this Doc View Source Length_IsCorrect() Declaration public void Length_IsCorrect() | Improve this Doc View Source StartsWith_IsCorrectWithEnumerable() Declaration public void StartsWith_IsCorrectWithEnumerable() | Improve this Doc View Source StartsWith_IsCorrectWithString() Declaration public void StartsWith_IsCorrectWithString() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Stack.ArrayListStackTests.html": {
    "href": "api/MoreStructures.Tests.Stack.ArrayListStackTests.html",
    "title": "Class ArrayListStackTests",
    "keywords": "Class ArrayListStackTests Inheritance System.Object StackTests ArrayListStackTests Inherited Members StackTests.Builder StackTests.Ctor_CreatesAnEmptyStack() StackTests.Peek_RaisesExceptionOnEmptyStack() StackTests.Peek_ReturnsTheLastPushedItem() StackTests.Peek_DoesntAlterTheStack() StackTests.Pop_RaisesExceptionOnEmptyStack() StackTests.PushAndPop_AreCorrect() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Stack Assembly : MoreStructures.Tests.dll Syntax public class ArrayListStackTests : StackTests Constructors | Improve this Doc View Source ArrayListStackTests() Declaration public ArrayListStackTests() Methods | Improve this Doc View Source Ctor_RaisesExceptionOnInvalidParams() Declaration public void Ctor_RaisesExceptionOnInvalidParams() | Improve this Doc View Source Ctor_SetsTheIncreasingFactor() Declaration public void Ctor_SetsTheIncreasingFactor() | Improve this Doc View Source Push_ResizesEnoughEvenWithLowIncreasingFactor() Declaration public void Push_ResizesEnoughEvenWithLowIncreasingFactor() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Stack.html": {
    "href": "api/MoreStructures.Tests.Stack.html",
    "title": "Namespace MoreStructures.Tests.Stack",
    "keywords": "Namespace MoreStructures.Tests.Stack Classes ArrayListStackTests LinkedListStackTests StackTests"
  },
  "api/MoreStructures.Tests.Stack.LinkedListStackTests.html": {
    "href": "api/MoreStructures.Tests.Stack.LinkedListStackTests.html",
    "title": "Class LinkedListStackTests",
    "keywords": "Class LinkedListStackTests Inheritance System.Object StackTests LinkedListStackTests Inherited Members StackTests.Builder StackTests.Ctor_CreatesAnEmptyStack() StackTests.Peek_RaisesExceptionOnEmptyStack() StackTests.Peek_ReturnsTheLastPushedItem() StackTests.Peek_DoesntAlterTheStack() StackTests.Pop_RaisesExceptionOnEmptyStack() StackTests.PushAndPop_AreCorrect() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Stack Assembly : MoreStructures.Tests.dll Syntax public class LinkedListStackTests : StackTests Constructors | Improve this Doc View Source LinkedListStackTests() Declaration public LinkedListStackTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Stack.StackTests.html": {
    "href": "api/MoreStructures.Tests.Stack.StackTests.html",
    "title": "Class StackTests",
    "keywords": "Class StackTests Inheritance System.Object StackTests ArrayListStackTests LinkedListStackTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Stack Assembly : MoreStructures.Tests.dll Syntax public abstract class StackTests Constructors | Improve this Doc View Source StackTests(Func<IStack<Int32>>) Declaration protected StackTests(Func<IStack<int>> builder) Parameters Type Name Description Func < IStack < System.Int32 >> builder Properties | Improve this Doc View Source Builder Declaration protected Func<IStack<int>> Builder { get; } Property Value Type Description Func < IStack < System.Int32 >> Methods | Improve this Doc View Source Ctor_CreatesAnEmptyStack() Declaration public void Ctor_CreatesAnEmptyStack() | Improve this Doc View Source Peek_DoesntAlterTheStack() Declaration public void Peek_DoesntAlterTheStack() | Improve this Doc View Source Peek_RaisesExceptionOnEmptyStack() Declaration public void Peek_RaisesExceptionOnEmptyStack() | Improve this Doc View Source Peek_ReturnsTheLastPushedItem() Declaration public void Peek_ReturnsTheLastPushedItem() | Improve this Doc View Source Pop_RaisesExceptionOnEmptyStack() Declaration public void Pop_RaisesExceptionOnEmptyStack() | Improve this Doc View Source PushAndPop_AreCorrect() Declaration public void PushAndPop_AreCorrect() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.StringIncludingTerminatorComparerTests.html": {
    "href": "api/MoreStructures.Tests.StringIncludingTerminatorComparerTests.html",
    "title": "Class StringIncludingTerminatorComparerTests",
    "keywords": "Class StringIncludingTerminatorComparerTests Inheritance System.Object StringIncludingTerminatorComparerTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests Assembly : MoreStructures.Tests.dll Syntax public class StringIncludingTerminatorComparerTests Methods | Improve this Doc View Source Compare_IsCorrect_WithNoTerminatorIncluded() Declaration public void Compare_IsCorrect_WithNoTerminatorIncluded() | Improve this Doc View Source Compare_IsCorrect_WithTerminatorIncludedHigherInASCII() Declaration public void Compare_IsCorrect_WithTerminatorIncludedHigherInASCII() | Improve this Doc View Source Compare_IsCorrect_WithTerminatorIncludedLowerInASCII() Declaration public void Compare_IsCorrect_WithTerminatorIncludedLowerInASCII() | Improve this Doc View Source Equals_ByValue() Declaration public void Equals_ByValue() | Improve this Doc View Source GetHashCode_ByValue() Declaration public void GetHashCode_ByValue() | Improve this Doc View Source Terminator_IsSet() Declaration public void Terminator_IsSet() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Strings.Sorting.CharsSorterTests.html": {
    "href": "api/MoreStructures.Tests.Strings.Sorting.CharsSorterTests.html",
    "title": "Class CharsSorterTests",
    "keywords": "Class CharsSorterTests Inheritance System.Object CharsSorterTests CountingSortCharsSorterTests QuickSortCharsSorterTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Strings.Sorting Assembly : MoreStructures.Tests.dll Syntax public abstract class CharsSorterTests Constructors | Improve this Doc View Source CharsSorterTests(Func<Nullable<Char>, ICharsSorter>) Declaration protected CharsSorterTests(Func<char?, ICharsSorter> charsSorterBuilder) Parameters Type Name Description Func < System.Nullable < System.Char >, ICharsSorter > charsSorterBuilder Properties | Improve this Doc View Source CharsSorterBuilder Declaration protected Func<char?, ICharsSorter> CharsSorterBuilder { get; } Property Value Type Description Func < System.Nullable < System.Char >, ICharsSorter > Methods | Improve this Doc View Source Sort_IsCorrect(String, Nullable<Char>) Declaration public void Sort_IsCorrect(string input, char? maybeTerminator) Parameters Type Name Description System.String input System.Nullable < System.Char > maybeTerminator Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Strings.Sorting.CountingSortCharsSorterTests.html": {
    "href": "api/MoreStructures.Tests.Strings.Sorting.CountingSortCharsSorterTests.html",
    "title": "Class CountingSortCharsSorterTests",
    "keywords": "Class CountingSortCharsSorterTests Inheritance System.Object CharsSorterTests CountingSortCharsSorterTests Inherited Members CharsSorterTests.CharsSorterBuilder CharsSorterTests.Sort_IsCorrect(String, Nullable<Char>) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Strings.Sorting Assembly : MoreStructures.Tests.dll Syntax public class CountingSortCharsSorterTests : CharsSorterTests Constructors | Improve this Doc View Source CountingSortCharsSorterTests() Declaration public CountingSortCharsSorterTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Strings.Sorting.html": {
    "href": "api/MoreStructures.Tests.Strings.Sorting.html",
    "title": "Namespace MoreStructures.Tests.Strings.Sorting",
    "keywords": "Namespace MoreStructures.Tests.Strings.Sorting Classes CharsSorterTests CountingSortCharsSorterTests QuickSortCharsSorterTests"
  },
  "api/MoreStructures.Tests.Strings.Sorting.QuickSortCharsSorterTests.html": {
    "href": "api/MoreStructures.Tests.Strings.Sorting.QuickSortCharsSorterTests.html",
    "title": "Class QuickSortCharsSorterTests",
    "keywords": "Class QuickSortCharsSorterTests Inheritance System.Object CharsSorterTests QuickSortCharsSorterTests Inherited Members CharsSorterTests.CharsSorterBuilder CharsSorterTests.Sort_IsCorrect(String, Nullable<Char>) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Strings.Sorting Assembly : MoreStructures.Tests.dll Syntax public class QuickSortCharsSorterTests : CharsSorterTests Constructors | Improve this Doc View Source QuickSortCharsSorterTests() Declaration public QuickSortCharsSorterTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.Builders.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.Builders.html",
    "title": "Namespace MoreStructures.Tests.SuffixArrays.Builders",
    "keywords": "Namespace MoreStructures.Tests.SuffixArrays.Builders Classes NaiveSuffixArrayBuilderTests PcsBasedSuffixArrayBuilderCustomStepsTests PcsBasedSuffixArrayBuilderTests SuffixArrayBuilderTests<TEdge, TNode> SuffixTreeBasedSuffixArrayBuilderTests SuffixTrieBasedSuffixArrayBuilderTests"
  },
  "api/MoreStructures.Tests.SuffixArrays.Builders.NaiveSuffixArrayBuilderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.Builders.NaiveSuffixArrayBuilderTests.html",
    "title": "Class NaiveSuffixArrayBuilderTests",
    "keywords": "Class NaiveSuffixArrayBuilderTests Inheritance System.Object SuffixArrayBuilderTests < SuffixTreeEdge , SuffixTreeNode > NaiveSuffixArrayBuilderTests Inherited Members SuffixArrayBuilderTests<SuffixTreeEdge, SuffixTreeNode>.BuilderBuilder SuffixArrayBuilderTests<SuffixTreeEdge, SuffixTreeNode>.Build_IsCorrect(String, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.Builders Assembly : MoreStructures.Tests.dll Syntax public class NaiveSuffixArrayBuilderTests : SuffixArrayBuilderTests<SuffixTreeEdge, SuffixTreeNode> Constructors | Improve this Doc View Source NaiveSuffixArrayBuilderTests() Declaration public NaiveSuffixArrayBuilderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.Builders.PcsBasedSuffixArrayBuilderCustomStepsTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.Builders.PcsBasedSuffixArrayBuilderCustomStepsTests.html",
    "title": "Class PcsBasedSuffixArrayBuilderCustomStepsTests",
    "keywords": "Class PcsBasedSuffixArrayBuilderCustomStepsTests Inheritance System.Object SuffixArrayBuilderTests < SuffixTreeEdge , SuffixTreeNode > PcsBasedSuffixArrayBuilderCustomStepsTests Inherited Members SuffixArrayBuilderTests<SuffixTreeEdge, SuffixTreeNode>.BuilderBuilder SuffixArrayBuilderTests<SuffixTreeEdge, SuffixTreeNode>.Build_IsCorrect(String, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.Builders Assembly : MoreStructures.Tests.dll Syntax public class PcsBasedSuffixArrayBuilderCustomStepsTests : SuffixArrayBuilderTests<SuffixTreeEdge, SuffixTreeNode> Constructors | Improve this Doc View Source PcsBasedSuffixArrayBuilderCustomStepsTests() Declaration public PcsBasedSuffixArrayBuilderCustomStepsTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.Builders.PcsBasedSuffixArrayBuilderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.Builders.PcsBasedSuffixArrayBuilderTests.html",
    "title": "Class PcsBasedSuffixArrayBuilderTests",
    "keywords": "Class PcsBasedSuffixArrayBuilderTests Inheritance System.Object SuffixArrayBuilderTests < SuffixTreeEdge , SuffixTreeNode > PcsBasedSuffixArrayBuilderTests Inherited Members SuffixArrayBuilderTests<SuffixTreeEdge, SuffixTreeNode>.BuilderBuilder SuffixArrayBuilderTests<SuffixTreeEdge, SuffixTreeNode>.Build_IsCorrect(String, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.Builders Assembly : MoreStructures.Tests.dll Syntax public class PcsBasedSuffixArrayBuilderTests : SuffixArrayBuilderTests<SuffixTreeEdge, SuffixTreeNode> Constructors | Improve this Doc View Source PcsBasedSuffixArrayBuilderTests() Declaration public PcsBasedSuffixArrayBuilderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.Builders.SuffixArrayBuilderTests-2.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.Builders.SuffixArrayBuilderTests-2.html",
    "title": "Class SuffixArrayBuilderTests<TEdge, TNode>",
    "keywords": "Class SuffixArrayBuilderTests<TEdge, TNode> Inheritance System.Object SuffixArrayBuilderTests<TEdge, TNode> NaiveSuffixArrayBuilderTests PcsBasedSuffixArrayBuilderCustomStepsTests PcsBasedSuffixArrayBuilderTests SuffixTreeBasedSuffixArrayBuilderTests SuffixTrieBasedSuffixArrayBuilderTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.Builders Assembly : MoreStructures.Tests.dll Syntax public abstract class SuffixArrayBuilderTests<TEdge, TNode> where TEdge : ISuffixStructureEdge<TEdge, TNode> where TNode : ISuffixStructureNode<TEdge, TNode> Type Parameters Name Description TEdge TNode Constructors | Improve this Doc View Source SuffixArrayBuilderTests(Func<String, ISuffixArrayBuilder>) Declaration protected SuffixArrayBuilderTests(Func<string, ISuffixArrayBuilder> builderBuilder) Parameters Type Name Description Func < System.String , ISuffixArrayBuilder > builderBuilder Properties | Improve this Doc View Source BuilderBuilder Declaration protected Func<string, ISuffixArrayBuilder> BuilderBuilder { get; } Property Value Type Description Func < System.String , ISuffixArrayBuilder > Methods | Improve this Doc View Source Build_IsCorrect(String, Int32[]) Declaration public void Build_IsCorrect(string text, int[] expectedResult) Parameters Type Name Description System.String text System.Int32 [] expectedResult Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.Builders.SuffixTreeBasedSuffixArrayBuilderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.Builders.SuffixTreeBasedSuffixArrayBuilderTests.html",
    "title": "Class SuffixTreeBasedSuffixArrayBuilderTests",
    "keywords": "Class SuffixTreeBasedSuffixArrayBuilderTests Inheritance System.Object SuffixArrayBuilderTests < SuffixTreeEdge , SuffixTreeNode > SuffixTreeBasedSuffixArrayBuilderTests Inherited Members SuffixArrayBuilderTests<SuffixTreeEdge, SuffixTreeNode>.BuilderBuilder SuffixArrayBuilderTests<SuffixTreeEdge, SuffixTreeNode>.Build_IsCorrect(String, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.Builders Assembly : MoreStructures.Tests.dll Syntax public class SuffixTreeBasedSuffixArrayBuilderTests : SuffixArrayBuilderTests<SuffixTreeEdge, SuffixTreeNode> Constructors | Improve this Doc View Source SuffixTreeBasedSuffixArrayBuilderTests() Declaration public SuffixTreeBasedSuffixArrayBuilderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.Builders.SuffixTrieBasedSuffixArrayBuilderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.Builders.SuffixTrieBasedSuffixArrayBuilderTests.html",
    "title": "Class SuffixTrieBasedSuffixArrayBuilderTests",
    "keywords": "Class SuffixTrieBasedSuffixArrayBuilderTests Inheritance System.Object SuffixArrayBuilderTests < SuffixTrieEdge , SuffixTrieNode > SuffixTrieBasedSuffixArrayBuilderTests Inherited Members SuffixArrayBuilderTests<SuffixTrieEdge, SuffixTrieNode>.BuilderBuilder SuffixArrayBuilderTests<SuffixTrieEdge, SuffixTrieNode>.Build_IsCorrect(String, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.Builders Assembly : MoreStructures.Tests.dll Syntax public class SuffixTrieBasedSuffixArrayBuilderTests : SuffixArrayBuilderTests<SuffixTrieEdge, SuffixTrieNode> Constructors | Improve this Doc View Source SuffixTrieBasedSuffixArrayBuilderTests() Declaration public SuffixTrieBasedSuffixArrayBuilderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.CountingSortDoubleLengthPcsSorterTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.CountingSortDoubleLengthPcsSorterTests.html",
    "title": "Class CountingSortDoubleLengthPcsSorterTests",
    "keywords": "Class CountingSortDoubleLengthPcsSorterTests Inheritance System.Object DoubleLengthPcsSorterTests CountingSortDoubleLengthPcsSorterTests Inherited Members DoubleLengthPcsSorterTests.SorterBuilder DoubleLengthPcsSorterTests.Sort_IsCorrect(String, Int32, Int32[], Int32[], Boolean, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.CyclicShifts Assembly : MoreStructures.Tests.dll Syntax public class CountingSortDoubleLengthPcsSorterTests : DoubleLengthPcsSorterTests Constructors | Improve this Doc View Source CountingSortDoubleLengthPcsSorterTests() Declaration public CountingSortDoubleLengthPcsSorterTests() Methods | Improve this Doc View Source Ctor_RaisesExceptionWhenOrderAndEqClassesAreIncoherent() Declaration public void Ctor_RaisesExceptionWhenOrderAndEqClassesAreIncoherent() | Improve this Doc View Source Ctor_RaisesExceptionWhenPcsLengthIsInvalid() Declaration public void Ctor_RaisesExceptionWhenPcsLengthIsInvalid() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.DoubleLengthPcsClassifierTests.ClassifierBuilderInput.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.DoubleLengthPcsClassifierTests.ClassifierBuilderInput.html",
    "title": "Class DoubleLengthPcsClassifierTests.ClassifierBuilderInput",
    "keywords": "Class DoubleLengthPcsClassifierTests.ClassifierBuilderInput Inheritance System.Object DoubleLengthPcsClassifierTests.ClassifierBuilderInput Implements System.IEquatable < DoubleLengthPcsClassifierTests.ClassifierBuilderInput > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.CyclicShifts Assembly : MoreStructures.Tests.dll Syntax public sealed class ClassifierBuilderInput : IEquatable<DoubleLengthPcsClassifierTests.ClassifierBuilderInput> Constructors | Improve this Doc View Source ClassifierBuilderInput(String, Int32, Int32[], Int32[], Boolean) Declaration public ClassifierBuilderInput(string Input, int PcsLength, int[] Order, int[] EqClassesPcsHalfLength, bool InputWithTerminator) Parameters Type Name Description System.String Input System.Int32 PcsLength System.Int32 [] Order System.Int32 [] EqClassesPcsHalfLength System.Boolean InputWithTerminator Properties | Improve this Doc View Source EqClassesPcsHalfLength Declaration public int[] EqClassesPcsHalfLength { get; set; } Property Value Type Description System.Int32 [] | Improve this Doc View Source Input Declaration public string Input { get; set; } Property Value Type Description System.String | Improve this Doc View Source InputWithTerminator Declaration public bool InputWithTerminator { get; set; } Property Value Type Description System.Boolean | Improve this Doc View Source Order Declaration public int[] Order { get; set; } Property Value Type Description System.Int32 [] | Improve this Doc View Source PcsLength Declaration public int PcsLength { get; set; } Property Value Type Description System.Int32 Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.DoubleLengthPcsClassifierTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.DoubleLengthPcsClassifierTests.html",
    "title": "Class DoubleLengthPcsClassifierTests",
    "keywords": "Class DoubleLengthPcsClassifierTests Inheritance System.Object DoubleLengthPcsClassifierTests EqClassesBasedDoubleLengthPcsClassifierTests NaiveDoubleLengthPcsClassifierTests OrderBasedDoubleLengthPcsClassifierTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.CyclicShifts Assembly : MoreStructures.Tests.dll Syntax public abstract class DoubleLengthPcsClassifierTests Constructors | Improve this Doc View Source DoubleLengthPcsClassifierTests(Func<DoubleLengthPcsClassifierTests.ClassifierBuilderInput, IDoubleLengthPcsClassifier>) Declaration protected DoubleLengthPcsClassifierTests(Func<DoubleLengthPcsClassifierTests.ClassifierBuilderInput, IDoubleLengthPcsClassifier> classifierBuilder) Parameters Type Name Description Func < DoubleLengthPcsClassifierTests.ClassifierBuilderInput , IDoubleLengthPcsClassifier > classifierBuilder Properties | Improve this Doc View Source ClassifierBuilder Declaration protected Func<DoubleLengthPcsClassifierTests.ClassifierBuilderInput, IDoubleLengthPcsClassifier> ClassifierBuilder { get; } Property Value Type Description Func < DoubleLengthPcsClassifierTests.ClassifierBuilderInput , IDoubleLengthPcsClassifier > Methods | Improve this Doc View Source Classify_IsCorrect(String, Int32, Int32[], Int32[], Boolean, Int32[]) Declaration public void Classify_IsCorrect(string input, int pcsLength, int[] order, int[] eqClassesPcsHalfLength, bool inputWithTerminator, int[] expectedResult) Parameters Type Name Description System.String input System.Int32 pcsLength System.Int32 [] order System.Int32 [] eqClassesPcsHalfLength System.Boolean inputWithTerminator System.Int32 [] expectedResult Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.DoubleLengthPcsSorterTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.DoubleLengthPcsSorterTests.html",
    "title": "Class DoubleLengthPcsSorterTests",
    "keywords": "Class DoubleLengthPcsSorterTests Inheritance System.Object DoubleLengthPcsSorterTests CountingSortDoubleLengthPcsSorterTests NaiveDoubleLengthPcsSorterTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.CyclicShifts Assembly : MoreStructures.Tests.dll Syntax public abstract class DoubleLengthPcsSorterTests Constructors | Improve this Doc View Source DoubleLengthPcsSorterTests(Func<DoubleLengthPcsSorterTests.SorterBuilderInput, IDoubleLengthPcsSorter>) Declaration protected DoubleLengthPcsSorterTests(Func<DoubleLengthPcsSorterTests.SorterBuilderInput, IDoubleLengthPcsSorter> sorterBuilder) Parameters Type Name Description Func < DoubleLengthPcsSorterTests.SorterBuilderInput , IDoubleLengthPcsSorter > sorterBuilder Properties | Improve this Doc View Source SorterBuilder Declaration protected Func<DoubleLengthPcsSorterTests.SorterBuilderInput, IDoubleLengthPcsSorter> SorterBuilder { get; } Property Value Type Description Func < DoubleLengthPcsSorterTests.SorterBuilderInput , IDoubleLengthPcsSorter > Methods | Improve this Doc View Source Sort_IsCorrect(String, Int32, Int32[], Int32[], Boolean, Int32[]) Declaration public void Sort_IsCorrect(string input, int pcsLength, int[] order, int[] eqClasses, bool inputWithTerminator, int[] expectedResult) Parameters Type Name Description System.String input System.Int32 pcsLength System.Int32 [] order System.Int32 [] eqClasses System.Boolean inputWithTerminator System.Int32 [] expectedResult Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.DoubleLengthPcsSorterTests.SorterBuilderInput.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.DoubleLengthPcsSorterTests.SorterBuilderInput.html",
    "title": "Class DoubleLengthPcsSorterTests.SorterBuilderInput",
    "keywords": "Class DoubleLengthPcsSorterTests.SorterBuilderInput Inheritance System.Object DoubleLengthPcsSorterTests.SorterBuilderInput Implements System.IEquatable < DoubleLengthPcsSorterTests.SorterBuilderInput > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.CyclicShifts Assembly : MoreStructures.Tests.dll Syntax public sealed class SorterBuilderInput : IEquatable<DoubleLengthPcsSorterTests.SorterBuilderInput> Constructors | Improve this Doc View Source SorterBuilderInput(String, Int32, Int32[], Int32[], Boolean) Declaration public SorterBuilderInput(string Input, int PcsLength, int[] Order, int[] EqClasses, bool InputWithTerminator) Parameters Type Name Description System.String Input System.Int32 PcsLength System.Int32 [] Order System.Int32 [] EqClasses System.Boolean InputWithTerminator Properties | Improve this Doc View Source EqClasses Declaration public int[] EqClasses { get; set; } Property Value Type Description System.Int32 [] | Improve this Doc View Source Input Declaration public string Input { get; set; } Property Value Type Description System.String | Improve this Doc View Source InputWithTerminator Declaration public bool InputWithTerminator { get; set; } Property Value Type Description System.Boolean | Improve this Doc View Source Order Declaration public int[] Order { get; set; } Property Value Type Description System.Int32 [] | Improve this Doc View Source PcsLength Declaration public int PcsLength { get; set; } Property Value Type Description System.Int32 Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.EqClassesBasedDoubleLengthPcsClassifierTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.EqClassesBasedDoubleLengthPcsClassifierTests.html",
    "title": "Class EqClassesBasedDoubleLengthPcsClassifierTests",
    "keywords": "Class EqClassesBasedDoubleLengthPcsClassifierTests Inheritance System.Object DoubleLengthPcsClassifierTests EqClassesBasedDoubleLengthPcsClassifierTests Inherited Members DoubleLengthPcsClassifierTests.ClassifierBuilder DoubleLengthPcsClassifierTests.Classify_IsCorrect(String, Int32, Int32[], Int32[], Boolean, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.CyclicShifts Assembly : MoreStructures.Tests.dll Syntax public class EqClassesBasedDoubleLengthPcsClassifierTests : DoubleLengthPcsClassifierTests Constructors | Improve this Doc View Source EqClassesBasedDoubleLengthPcsClassifierTests() Declaration public EqClassesBasedDoubleLengthPcsClassifierTests() Methods | Improve this Doc View Source Ctor_RaisesExceptionWhenOrderIsNotCoherentWithEqClassesPcsHalfLength() Declaration public void Ctor_RaisesExceptionWhenOrderIsNotCoherentWithEqClassesPcsHalfLength() | Improve this Doc View Source Ctor_RaisesExceptionWhenPcsLengthIsNotCoherentWithEqClassesPcsHalfLength() Declaration public void Ctor_RaisesExceptionWhenPcsLengthIsNotCoherentWithEqClassesPcsHalfLength() | Improve this Doc View Source Ctor_RaisesExceptionWhenPcsLengthIsNotEven() Declaration public void Ctor_RaisesExceptionWhenPcsLengthIsNotEven() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.html",
    "title": "Namespace MoreStructures.Tests.SuffixArrays.CyclicShifts",
    "keywords": "Namespace MoreStructures.Tests.SuffixArrays.CyclicShifts Classes CountingSortDoubleLengthPcsSorterTests DoubleLengthPcsClassifierTests DoubleLengthPcsClassifierTests.ClassifierBuilderInput DoubleLengthPcsSorterTests DoubleLengthPcsSorterTests.SorterBuilderInput EqClassesBasedDoubleLengthPcsClassifierTests NaiveDoubleLengthPcsClassifierTests NaiveDoubleLengthPcsSorterTests NaiveSingleCharPcsClassifierTests OrderBasedDoubleLengthPcsClassifierTests OrderBasedSingleCharPcsClassifierTests SingleCharPcsClassifierTests SingleCharPcsClassifierTests.ClassifierBuilderInput"
  },
  "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.NaiveDoubleLengthPcsClassifierTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.NaiveDoubleLengthPcsClassifierTests.html",
    "title": "Class NaiveDoubleLengthPcsClassifierTests",
    "keywords": "Class NaiveDoubleLengthPcsClassifierTests Inheritance System.Object DoubleLengthPcsClassifierTests NaiveDoubleLengthPcsClassifierTests Inherited Members DoubleLengthPcsClassifierTests.ClassifierBuilder DoubleLengthPcsClassifierTests.Classify_IsCorrect(String, Int32, Int32[], Int32[], Boolean, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.CyclicShifts Assembly : MoreStructures.Tests.dll Syntax public class NaiveDoubleLengthPcsClassifierTests : DoubleLengthPcsClassifierTests Constructors | Improve this Doc View Source NaiveDoubleLengthPcsClassifierTests() Declaration public NaiveDoubleLengthPcsClassifierTests() Methods | Improve this Doc View Source Ctor_RaisesExceptionWithInvalidPcsLength() Declaration public void Ctor_RaisesExceptionWithInvalidPcsLength() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.NaiveDoubleLengthPcsSorterTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.NaiveDoubleLengthPcsSorterTests.html",
    "title": "Class NaiveDoubleLengthPcsSorterTests",
    "keywords": "Class NaiveDoubleLengthPcsSorterTests Inheritance System.Object DoubleLengthPcsSorterTests NaiveDoubleLengthPcsSorterTests Inherited Members DoubleLengthPcsSorterTests.SorterBuilder DoubleLengthPcsSorterTests.Sort_IsCorrect(String, Int32, Int32[], Int32[], Boolean, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.CyclicShifts Assembly : MoreStructures.Tests.dll Syntax public class NaiveDoubleLengthPcsSorterTests : DoubleLengthPcsSorterTests Constructors | Improve this Doc View Source NaiveDoubleLengthPcsSorterTests() Declaration public NaiveDoubleLengthPcsSorterTests() Methods | Improve this Doc View Source Ctor_RaisesExceptionWhenPcsLengthIsInvalid() Declaration public void Ctor_RaisesExceptionWhenPcsLengthIsInvalid() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.NaiveSingleCharPcsClassifierTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.NaiveSingleCharPcsClassifierTests.html",
    "title": "Class NaiveSingleCharPcsClassifierTests",
    "keywords": "Class NaiveSingleCharPcsClassifierTests Inheritance System.Object SingleCharPcsClassifierTests NaiveSingleCharPcsClassifierTests Inherited Members SingleCharPcsClassifierTests.ClassifierBuilder SingleCharPcsClassifierTests.Classify_IsCorrect(String, Boolean, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.CyclicShifts Assembly : MoreStructures.Tests.dll Syntax public class NaiveSingleCharPcsClassifierTests : SingleCharPcsClassifierTests Constructors | Improve this Doc View Source NaiveSingleCharPcsClassifierTests() Declaration public NaiveSingleCharPcsClassifierTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.OrderBasedDoubleLengthPcsClassifierTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.OrderBasedDoubleLengthPcsClassifierTests.html",
    "title": "Class OrderBasedDoubleLengthPcsClassifierTests",
    "keywords": "Class OrderBasedDoubleLengthPcsClassifierTests Inheritance System.Object DoubleLengthPcsClassifierTests OrderBasedDoubleLengthPcsClassifierTests Inherited Members DoubleLengthPcsClassifierTests.ClassifierBuilder DoubleLengthPcsClassifierTests.Classify_IsCorrect(String, Int32, Int32[], Int32[], Boolean, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.CyclicShifts Assembly : MoreStructures.Tests.dll Syntax public class OrderBasedDoubleLengthPcsClassifierTests : DoubleLengthPcsClassifierTests Constructors | Improve this Doc View Source OrderBasedDoubleLengthPcsClassifierTests() Declaration public OrderBasedDoubleLengthPcsClassifierTests() Methods | Improve this Doc View Source Ctor_RaisesExceptionWhenOrderIsNotCoherentWithInput() Declaration public void Ctor_RaisesExceptionWhenOrderIsNotCoherentWithInput() | Improve this Doc View Source Ctor_RaisesExceptionWhenPcsLengthIsNotCoherentWithInput() Declaration public void Ctor_RaisesExceptionWhenPcsLengthIsNotCoherentWithInput() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.OrderBasedSingleCharPcsClassifierTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.OrderBasedSingleCharPcsClassifierTests.html",
    "title": "Class OrderBasedSingleCharPcsClassifierTests",
    "keywords": "Class OrderBasedSingleCharPcsClassifierTests Inheritance System.Object SingleCharPcsClassifierTests OrderBasedSingleCharPcsClassifierTests Inherited Members SingleCharPcsClassifierTests.ClassifierBuilder SingleCharPcsClassifierTests.Classify_IsCorrect(String, Boolean, Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.CyclicShifts Assembly : MoreStructures.Tests.dll Syntax public class OrderBasedSingleCharPcsClassifierTests : SingleCharPcsClassifierTests Constructors | Improve this Doc View Source OrderBasedSingleCharPcsClassifierTests() Declaration public OrderBasedSingleCharPcsClassifierTests() Methods | Improve this Doc View Source Ctor_RaisesExceptionWhenInputAndOrderHaveDifferentLength() Declaration public void Ctor_RaisesExceptionWhenInputAndOrderHaveDifferentLength() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.SingleCharPcsClassifierTests.ClassifierBuilderInput.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.SingleCharPcsClassifierTests.ClassifierBuilderInput.html",
    "title": "Class SingleCharPcsClassifierTests.ClassifierBuilderInput",
    "keywords": "Class SingleCharPcsClassifierTests.ClassifierBuilderInput Inheritance System.Object SingleCharPcsClassifierTests.ClassifierBuilderInput Implements System.IEquatable < SingleCharPcsClassifierTests.ClassifierBuilderInput > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.CyclicShifts Assembly : MoreStructures.Tests.dll Syntax public sealed class ClassifierBuilderInput : IEquatable<SingleCharPcsClassifierTests.ClassifierBuilderInput> Constructors | Improve this Doc View Source ClassifierBuilderInput(String, Boolean) Declaration public ClassifierBuilderInput(string Input, bool InputWithTerminator) Parameters Type Name Description System.String Input System.Boolean InputWithTerminator Properties | Improve this Doc View Source Input Declaration public string Input { get; set; } Property Value Type Description System.String | Improve this Doc View Source InputWithTerminator Declaration public bool InputWithTerminator { get; set; } Property Value Type Description System.Boolean Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.SingleCharPcsClassifierTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.CyclicShifts.SingleCharPcsClassifierTests.html",
    "title": "Class SingleCharPcsClassifierTests",
    "keywords": "Class SingleCharPcsClassifierTests Inheritance System.Object SingleCharPcsClassifierTests NaiveSingleCharPcsClassifierTests OrderBasedSingleCharPcsClassifierTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.CyclicShifts Assembly : MoreStructures.Tests.dll Syntax public abstract class SingleCharPcsClassifierTests Constructors | Improve this Doc View Source SingleCharPcsClassifierTests(Func<SingleCharPcsClassifierTests.ClassifierBuilderInput, ISingleCharPcsClassifier>) Declaration protected SingleCharPcsClassifierTests(Func<SingleCharPcsClassifierTests.ClassifierBuilderInput, ISingleCharPcsClassifier> classifierBuilder) Parameters Type Name Description Func < SingleCharPcsClassifierTests.ClassifierBuilderInput , ISingleCharPcsClassifier > classifierBuilder Properties | Improve this Doc View Source ClassifierBuilder Declaration protected Func<SingleCharPcsClassifierTests.ClassifierBuilderInput, ISingleCharPcsClassifier> ClassifierBuilder { get; } Property Value Type Description Func < SingleCharPcsClassifierTests.ClassifierBuilderInput , ISingleCharPcsClassifier > Methods | Improve this Doc View Source Classify_IsCorrect(String, Boolean, Int32[]) Declaration public void Classify_IsCorrect(string input, bool inputWithTerminator, int[] expectedResult) Parameters Type Name Description System.String input System.Boolean inputWithTerminator System.Int32 [] expectedResult Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.LongestCommonPrefix.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.LongestCommonPrefix.html",
    "title": "Namespace MoreStructures.Tests.SuffixArrays.LongestCommonPrefix",
    "keywords": "Namespace MoreStructures.Tests.SuffixArrays.LongestCommonPrefix Classes KasaiLcpArrayBuilderTests LcpArrayBuilderTests LcpArrayBuilderTests.LcpArrayBuilderBuilderInput NaiveLcpArrayBuilderTests"
  },
  "api/MoreStructures.Tests.SuffixArrays.LongestCommonPrefix.KasaiLcpArrayBuilderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.LongestCommonPrefix.KasaiLcpArrayBuilderTests.html",
    "title": "Class KasaiLcpArrayBuilderTests",
    "keywords": "Class KasaiLcpArrayBuilderTests Inheritance System.Object LcpArrayBuilderTests KasaiLcpArrayBuilderTests Inherited Members LcpArrayBuilderTests.BuilderBuilder LcpArrayBuilderTests.Build_IsCorrect(String, Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.LongestCommonPrefix Assembly : MoreStructures.Tests.dll Syntax public class KasaiLcpArrayBuilderTests : LcpArrayBuilderTests Constructors | Improve this Doc View Source KasaiLcpArrayBuilderTests() Declaration public KasaiLcpArrayBuilderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.LongestCommonPrefix.LcpArrayBuilderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.LongestCommonPrefix.LcpArrayBuilderTests.html",
    "title": "Class LcpArrayBuilderTests",
    "keywords": "Class LcpArrayBuilderTests Inheritance System.Object LcpArrayBuilderTests KasaiLcpArrayBuilderTests NaiveLcpArrayBuilderTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.LongestCommonPrefix Assembly : MoreStructures.Tests.dll Syntax public abstract class LcpArrayBuilderTests Constructors | Improve this Doc View Source LcpArrayBuilderTests(Func<LcpArrayBuilderTests.LcpArrayBuilderBuilderInput, ILcpArrayBuilder>) Declaration protected LcpArrayBuilderTests(Func<LcpArrayBuilderTests.LcpArrayBuilderBuilderInput, ILcpArrayBuilder> builderBuilder) Parameters Type Name Description Func < LcpArrayBuilderTests.LcpArrayBuilderBuilderInput , ILcpArrayBuilder > builderBuilder Properties | Improve this Doc View Source BuilderBuilder Declaration protected Func<LcpArrayBuilderTests.LcpArrayBuilderBuilderInput, ILcpArrayBuilder> BuilderBuilder { get; } Property Value Type Description Func < LcpArrayBuilderTests.LcpArrayBuilderBuilderInput , ILcpArrayBuilder > Methods | Improve this Doc View Source Build_IsCorrect(String, Int32[], Int32[]) Declaration public void Build_IsCorrect(string textContent, int[] suffixArray, int[] expectedResult) Parameters Type Name Description System.String textContent System.Int32 [] suffixArray System.Int32 [] expectedResult Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.LongestCommonPrefix.LcpArrayBuilderTests.LcpArrayBuilderBuilderInput.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.LongestCommonPrefix.LcpArrayBuilderTests.LcpArrayBuilderBuilderInput.html",
    "title": "Class LcpArrayBuilderTests.LcpArrayBuilderBuilderInput",
    "keywords": "Class LcpArrayBuilderTests.LcpArrayBuilderBuilderInput Inheritance System.Object LcpArrayBuilderTests.LcpArrayBuilderBuilderInput Implements System.IEquatable < LcpArrayBuilderTests.LcpArrayBuilderBuilderInput > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.LongestCommonPrefix Assembly : MoreStructures.Tests.dll Syntax public class LcpArrayBuilderBuilderInput : IEquatable<LcpArrayBuilderTests.LcpArrayBuilderBuilderInput> Constructors | Improve this Doc View Source LcpArrayBuilderBuilderInput(TextWithTerminator, SuffixArray) Declaration public LcpArrayBuilderBuilderInput(TextWithTerminator Text, SuffixArray SuffixArray) Parameters Type Name Description TextWithTerminator Text MoreStructures.SuffixArrays.SuffixArray SuffixArray Properties | Improve this Doc View Source SuffixArray Declaration public SuffixArray SuffixArray { get; set; } Property Value Type Description MoreStructures.SuffixArrays.SuffixArray | Improve this Doc View Source Text Declaration public TextWithTerminator Text { get; set; } Property Value Type Description TextWithTerminator Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixArrays.LongestCommonPrefix.NaiveLcpArrayBuilderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixArrays.LongestCommonPrefix.NaiveLcpArrayBuilderTests.html",
    "title": "Class NaiveLcpArrayBuilderTests",
    "keywords": "Class NaiveLcpArrayBuilderTests Inheritance System.Object LcpArrayBuilderTests NaiveLcpArrayBuilderTests Inherited Members LcpArrayBuilderTests.BuilderBuilder LcpArrayBuilderTests.Build_IsCorrect(String, Int32[], Int32[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixArrays.LongestCommonPrefix Assembly : MoreStructures.Tests.dll Syntax public class NaiveLcpArrayBuilderTests : LcpArrayBuilderTests Constructors | Improve this Doc View Source NaiveLcpArrayBuilderTests() Declaration public NaiveLcpArrayBuilderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixStructures.AdjacencyOrdersTests.html": {
    "href": "api/MoreStructures.Tests.SuffixStructures.AdjacencyOrdersTests.html",
    "title": "Class AdjacencyOrdersTests",
    "keywords": "Class AdjacencyOrdersTests Inheritance System.Object AdjacencyOrdersTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixStructures Assembly : MoreStructures.Tests.dll Syntax public class AdjacencyOrdersTests Methods | Improve this Doc View Source FlagsConsistency() Declaration public void FlagsConsistency() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixStructures.BuilderExtensionsTests.html": {
    "href": "api/MoreStructures.Tests.SuffixStructures.BuilderExtensionsTests.html",
    "title": "Class BuilderExtensionsTests",
    "keywords": "Class BuilderExtensionsTests Inheritance System.Object BuilderExtensionsTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixStructures Assembly : MoreStructures.Tests.dll Syntax public class BuilderExtensionsTests Methods | Improve this Doc View Source BuildTree_CallsTheBuilderWithAnEquivalentTextWithTerminator() Declaration public void BuildTree_CallsTheBuilderWithAnEquivalentTextWithTerminator() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixStructures.Conversions.ConversionEquivalences.EquivalenceId.html": {
    "href": "api/MoreStructures.Tests.SuffixStructures.Conversions.ConversionEquivalences.EquivalenceId.html",
    "title": "Enum ConversionEquivalences.EquivalenceId",
    "keywords": "Enum ConversionEquivalences.EquivalenceId Namespace : MoreStructures.Tests.SuffixStructures.Conversions Assembly : MoreStructures.Tests.dll Syntax public enum EquivalenceId Fields Name Description Example Leaf OneLevelTreeToMostUnbalancedAHundredLevelsTrie OneLevelTreeToMostUnbalancedTenLevelsTrie ThreeLevelsTreeToFourLevelsTrie ThreeLevelsTreeToSixLevelsTrie TwoLevelsTreeSingleChainSingleLeafToThreeLevelsTrie TwoLevelsTreeSingleChainTwoLeafsToThreeLevelsTrie TwoLevelsTreeToFourLevelsTrie TwoLevelsTreeToTwoLevelsTrie TwoLevelsTreeWithSiblingToThreeLevelsTrie Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, ConversionEquivalences.EquivalenceId>(TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixStructures.Conversions.ConversionEquivalences.html": {
    "href": "api/MoreStructures.Tests.SuffixStructures.Conversions.ConversionEquivalences.html",
    "title": "Class ConversionEquivalences",
    "keywords": "Class ConversionEquivalences Inheritance System.Object ConversionEquivalences Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixStructures.Conversions Assembly : MoreStructures.Tests.dll Syntax public static class ConversionEquivalences Fields | Improve this Doc View Source Equivalences Declaration public static readonly Dictionary<ConversionEquivalences.EquivalenceId, (SuffixTreeNode treeNode, SuffixTrieNode trieNode)> Equivalences Field Value Type Description Dictionary < ConversionEquivalences.EquivalenceId , System.ValueTuple < SuffixTreeNode , SuffixTrieNode >>"
  },
  "api/MoreStructures.Tests.SuffixStructures.Conversions.ConverterTests.html": {
    "href": "api/MoreStructures.Tests.SuffixStructures.Conversions.ConverterTests.html",
    "title": "Class ConverterTests",
    "keywords": "Class ConverterTests Inheritance System.Object ConverterTests FullyIterativeConverterTests FullyRecursiveConverterTests PartiallyIterativeConverterTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixStructures.Conversions Assembly : MoreStructures.Tests.dll Syntax public abstract class ConverterTests Constructors | Improve this Doc View Source ConverterTests(IConverter) Declaration public ConverterTests(IConverter suffixStructuresConverter) Parameters Type Name Description IConverter suffixStructuresConverter Properties | Improve this Doc View Source Converter Declaration protected IConverter Converter { get; set; } Property Value Type Description IConverter Methods | Improve this Doc View Source TreeToTrie_IsCorrect(ConversionEquivalences.EquivalenceId) Declaration public void TreeToTrie_IsCorrect(ConversionEquivalences.EquivalenceId equivalenceId) Parameters Type Name Description ConversionEquivalences.EquivalenceId equivalenceId | Improve this Doc View Source TreeToTrie_OnlySupportsLeafAndIntermediateNodes_AsArgument() Declaration public void TreeToTrie_OnlySupportsLeafAndIntermediateNodes_AsArgument() | Improve this Doc View Source TreeToTrie_OnlySupportsLeafAndIntermediateNodes_DeepInTheStructure() Declaration public void TreeToTrie_OnlySupportsLeafAndIntermediateNodes_DeepInTheStructure() | Improve this Doc View Source TrieToTree_IsCorrect(ConversionEquivalences.EquivalenceId) Declaration public void TrieToTree_IsCorrect(ConversionEquivalences.EquivalenceId equivalenceId) Parameters Type Name Description ConversionEquivalences.EquivalenceId equivalenceId | Improve this Doc View Source TrieToTree_OnlySupportsLeafAndIntermediateNodes_AsArgument() Declaration public void TrieToTree_OnlySupportsLeafAndIntermediateNodes_AsArgument() | Improve this Doc View Source TrieToTree_OnlySupportsLeafAndIntermediateNodes_DeepInTheStructure() Declaration public void TrieToTree_OnlySupportsLeafAndIntermediateNodes_DeepInTheStructure() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixStructures.Conversions.FullyIterativeConverterTests.html": {
    "href": "api/MoreStructures.Tests.SuffixStructures.Conversions.FullyIterativeConverterTests.html",
    "title": "Class FullyIterativeConverterTests",
    "keywords": "Class FullyIterativeConverterTests Runs tests defined in ConverterTests for FullyIterativeConverter . Inheritance System.Object ConverterTests FullyIterativeConverterTests Inherited Members ConverterTests.TreeToTrie_IsCorrect(ConversionEquivalences.EquivalenceId) ConverterTests.TreeToTrie_OnlySupportsLeafAndIntermediateNodes_AsArgument() ConverterTests.TreeToTrie_OnlySupportsLeafAndIntermediateNodes_DeepInTheStructure() ConverterTests.Converter ConverterTests.TrieToTree_IsCorrect(ConversionEquivalences.EquivalenceId) ConverterTests.TrieToTree_OnlySupportsLeafAndIntermediateNodes_AsArgument() ConverterTests.TrieToTree_OnlySupportsLeafAndIntermediateNodes_DeepInTheStructure() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixStructures.Conversions Assembly : MoreStructures.Tests.dll Syntax public class FullyIterativeConverterTests : ConverterTests Constructors | Improve this Doc View Source FullyIterativeConverterTests() Declaration public FullyIterativeConverterTests() Methods | Improve this Doc View Source TrieToTree_DoesntStackOverflowWithDeepStructures() Declaration public void TrieToTree_DoesntStackOverflowWithDeepStructures() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixStructures.Conversions.FullyRecursiveConverterTests.html": {
    "href": "api/MoreStructures.Tests.SuffixStructures.Conversions.FullyRecursiveConverterTests.html",
    "title": "Class FullyRecursiveConverterTests",
    "keywords": "Class FullyRecursiveConverterTests Runs tests defined in ConverterTests for FullyRecursiveConverter . Inheritance System.Object ConverterTests FullyRecursiveConverterTests Inherited Members ConverterTests.TreeToTrie_IsCorrect(ConversionEquivalences.EquivalenceId) ConverterTests.TreeToTrie_OnlySupportsLeafAndIntermediateNodes_AsArgument() ConverterTests.TreeToTrie_OnlySupportsLeafAndIntermediateNodes_DeepInTheStructure() ConverterTests.Converter ConverterTests.TrieToTree_IsCorrect(ConversionEquivalences.EquivalenceId) ConverterTests.TrieToTree_OnlySupportsLeafAndIntermediateNodes_AsArgument() ConverterTests.TrieToTree_OnlySupportsLeafAndIntermediateNodes_DeepInTheStructure() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixStructures.Conversions Assembly : MoreStructures.Tests.dll Syntax public class FullyRecursiveConverterTests : ConverterTests Constructors | Improve this Doc View Source FullyRecursiveConverterTests() Declaration public FullyRecursiveConverterTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixStructures.Conversions.html": {
    "href": "api/MoreStructures.Tests.SuffixStructures.Conversions.html",
    "title": "Namespace MoreStructures.Tests.SuffixStructures.Conversions",
    "keywords": "Namespace MoreStructures.Tests.SuffixStructures.Conversions Classes ConversionEquivalences ConverterTests FullyIterativeConverterTests Runs tests defined in ConverterTests for FullyIterativeConverter . FullyRecursiveConverterTests Runs tests defined in ConverterTests for FullyRecursiveConverter . PartiallyIterativeConverterTests Runs tests defined in ConverterTests for PartiallyIterativeConverter . Enums ConversionEquivalences.EquivalenceId"
  },
  "api/MoreStructures.Tests.SuffixStructures.Conversions.PartiallyIterativeConverterTests.html": {
    "href": "api/MoreStructures.Tests.SuffixStructures.Conversions.PartiallyIterativeConverterTests.html",
    "title": "Class PartiallyIterativeConverterTests",
    "keywords": "Class PartiallyIterativeConverterTests Runs tests defined in ConverterTests for PartiallyIterativeConverter . Inheritance System.Object ConverterTests PartiallyIterativeConverterTests Inherited Members ConverterTests.TreeToTrie_IsCorrect(ConversionEquivalences.EquivalenceId) ConverterTests.TreeToTrie_OnlySupportsLeafAndIntermediateNodes_AsArgument() ConverterTests.TreeToTrie_OnlySupportsLeafAndIntermediateNodes_DeepInTheStructure() ConverterTests.Converter ConverterTests.TrieToTree_IsCorrect(ConversionEquivalences.EquivalenceId) ConverterTests.TrieToTree_OnlySupportsLeafAndIntermediateNodes_AsArgument() ConverterTests.TrieToTree_OnlySupportsLeafAndIntermediateNodes_DeepInTheStructure() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixStructures.Conversions Assembly : MoreStructures.Tests.dll Syntax public class PartiallyIterativeConverterTests : ConverterTests Constructors | Improve this Doc View Source PartiallyIterativeConverterTests() Declaration public PartiallyIterativeConverterTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixStructures.html": {
    "href": "api/MoreStructures.Tests.SuffixStructures.html",
    "title": "Namespace MoreStructures.Tests.SuffixStructures",
    "keywords": "Namespace MoreStructures.Tests.SuffixStructures Classes AdjacencyOrdersTests BuilderExtensionsTests SuffixStructuresEdgeExtensionsTests SuffixStructuresNodeExtensionsTests SuffixStructuresTreePathExtensionsTests"
  },
  "api/MoreStructures.Tests.SuffixStructures.SuffixStructuresEdgeExtensionsTests.html": {
    "href": "api/MoreStructures.Tests.SuffixStructures.SuffixStructuresEdgeExtensionsTests.html",
    "title": "Class SuffixStructuresEdgeExtensionsTests",
    "keywords": "Class SuffixStructuresEdgeExtensionsTests Inheritance System.Object SuffixStructuresEdgeExtensionsTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixStructures Assembly : MoreStructures.Tests.dll Syntax public class SuffixStructuresEdgeExtensionsTests Methods | Improve this Doc View Source ContainsIndex_IsCorrect() Declaration public void ContainsIndex_IsCorrect() | Improve this Doc View Source ContainsIndex_ThrowsExceptionOnInvalidIndex() Declaration public void ContainsIndex_ThrowsExceptionOnInvalidIndex() | Improve this Doc View Source ContainsIndexesNonBiggerThan_IsCorrect() Declaration public void ContainsIndexesNonBiggerThan_IsCorrect() | Improve this Doc View Source ContainsIndexesNonBiggerThan_ThrowsExceptionOnInvalidIndex() Declaration public void ContainsIndexesNonBiggerThan_ThrowsExceptionOnInvalidIndex() | Improve this Doc View Source IsAdjacentTo_IsCorrect() Declaration public void IsAdjacentTo_IsCorrect() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixStructures.SuffixStructuresNodeExtensionsTests.html": {
    "href": "api/MoreStructures.Tests.SuffixStructures.SuffixStructuresNodeExtensionsTests.html",
    "title": "Class SuffixStructuresNodeExtensionsTests",
    "keywords": "Class SuffixStructuresNodeExtensionsTests Inheritance System.Object SuffixStructuresNodeExtensionsTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixStructures Assembly : MoreStructures.Tests.dll Syntax public class SuffixStructuresNodeExtensionsTests Methods | Improve this Doc View Source GetAllSuffixesFor_IsCorrectWithTrees() Declaration public void GetAllSuffixesFor_IsCorrectWithTrees() | Improve this Doc View Source GetAllSuffixesFor_IsCorrectWithTries() Declaration public void GetAllSuffixesFor_IsCorrectWithTries() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixStructures.SuffixStructuresTreePathExtensionsTests.html": {
    "href": "api/MoreStructures.Tests.SuffixStructures.SuffixStructuresTreePathExtensionsTests.html",
    "title": "Class SuffixStructuresTreePathExtensionsTests",
    "keywords": "Class SuffixStructuresTreePathExtensionsTests Inheritance System.Object SuffixStructuresTreePathExtensionsTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixStructures Assembly : MoreStructures.Tests.dll Syntax public class SuffixStructuresTreePathExtensionsTests Methods | Improve this Doc View Source ContainsIndex_IsAlwaysFalseOnAEmptyPath() Declaration public void ContainsIndex_IsAlwaysFalseOnAEmptyPath() | Improve this Doc View Source ContainsIndex_IsCorrect() Declaration public void ContainsIndex_IsCorrect() | Improve this Doc View Source ContainsIndex_ThrowsExceptionOnInvalidIndex() Declaration public void ContainsIndex_ThrowsExceptionOnInvalidIndex() | Improve this Doc View Source ContainsIndexesNonBiggerThan_IsAlwaysFalseOnAEmptyPath() Declaration public void ContainsIndexesNonBiggerThan_IsAlwaysFalseOnAEmptyPath() | Improve this Doc View Source ContainsIndexesNonBiggerThan_IsCorrect() Declaration public void ContainsIndexesNonBiggerThan_IsCorrect() | Improve this Doc View Source ContainsIndexesNonBiggerThan_ThrowsExceptionOnInvalidIndex() Declaration public void ContainsIndexesNonBiggerThan_ThrowsExceptionOnInvalidIndex() | Improve this Doc View Source IsSuffixOf_IsCorrectForNonEmtpyPath() Declaration public void IsSuffixOf_IsCorrectForNonEmtpyPath() | Improve this Doc View Source IsSuffixOf_IsTrueForEmtpyPath() Declaration public void IsSuffixOf_IsTrueForEmtpyPath() | Improve this Doc View Source SuffixFor_IsCorrectForEmptyPath() Declaration public void SuffixFor_IsCorrectForEmptyPath() | Improve this Doc View Source SuffixFor_IsCorrectForNonEmptyPathOnSuffixTree() Declaration public void SuffixFor_IsCorrectForNonEmptyPathOnSuffixTree() | Improve this Doc View Source SuffixFor_IsCorrectForNonEmptyPathOnSuffixTrie() Declaration public void SuffixFor_IsCorrectForNonEmptyPathOnSuffixTrie() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.Builders.BuilderEquivalences.EquivalenceId.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Builders.BuilderEquivalences.EquivalenceId.html",
    "title": "Enum BuilderEquivalences.EquivalenceId",
    "keywords": "Enum BuilderEquivalences.EquivalenceId Namespace : MoreStructures.Tests.SuffixTrees.Builders Assembly : MoreStructures.Tests.dll Syntax public enum EquivalenceId Fields Name Description EmptyString EmptyStrings Issue75_BreakingUkkonen OneEmptyOneNonEmpty OneNonEmptyOneEmpty SingleChar ThreeChars_ExtendingPrefixes ThreeCharsString_DifferentPrefixes ThreeCharsString_PartiallySamePrefixes ThreeCharsString_SamePrefixes ThreeDifferent ThreeSame TwoChars_ExtendingPrefixes TwoCharsString_DifferentPrefixes TwoCharsString_SamePrefixes TwoEmptyOneNonEmpty TwoEmptyOneNonEmptyDifferentOrder TwoNonSharingChars TwoSame TwoSameOneDifferent TwoSharingChars Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, BuilderEquivalences.EquivalenceId>(TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.Builders.BuilderEquivalences.EquivalenceValue.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Builders.BuilderEquivalences.EquivalenceValue.html",
    "title": "Class BuilderEquivalences.EquivalenceValue",
    "keywords": "Class BuilderEquivalences.EquivalenceValue Inheritance System.Object BuilderEquivalences.EquivalenceValue Implements System.IEquatable < BuilderEquivalences.EquivalenceValue > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees.Builders Assembly : MoreStructures.Tests.dll Syntax public class EquivalenceValue : IEquatable<BuilderEquivalences.EquivalenceValue> Constructors | Improve this Doc View Source EquivalenceValue(TextWithTerminator[], SuffixTreeNode) Declaration public EquivalenceValue(TextWithTerminator[] Texts, SuffixTreeNode TreeNode) Parameters Type Name Description TextWithTerminator [] Texts SuffixTreeNode TreeNode Properties | Improve this Doc View Source Texts Declaration public TextWithTerminator[] Texts { get; set; } Property Value Type Description TextWithTerminator [] | Improve this Doc View Source TreeNode Declaration public SuffixTreeNode TreeNode { get; set; } Property Value Type Description SuffixTreeNode Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.Builders.BuilderEquivalences.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Builders.BuilderEquivalences.html",
    "title": "Class BuilderEquivalences",
    "keywords": "Class BuilderEquivalences Inheritance System.Object BuilderEquivalences Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees.Builders Assembly : MoreStructures.Tests.dll Syntax public static class BuilderEquivalences Fields | Improve this Doc View Source Equivalences Declaration public static readonly Dictionary<BuilderEquivalences.EquivalenceId, BuilderEquivalences.EquivalenceValue> Equivalences Field Value Type Description Dictionary < BuilderEquivalences.EquivalenceId , BuilderEquivalences.EquivalenceValue >"
  },
  "api/MoreStructures.Tests.SuffixTrees.Builders.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Builders.html",
    "title": "Namespace MoreStructures.Tests.SuffixTrees.Builders",
    "keywords": "Namespace MoreStructures.Tests.SuffixTrees.Builders Classes BuilderEquivalences BuilderEquivalences.EquivalenceValue NaivePartiallyRecursiveSuffixTreeBuilderTests SuffixAndLcpArraysBasedSuffixTreeBuilderTests SuffixTreeBuilderTests UkkonenSuffixTreeBuilderTests Enums BuilderEquivalences.EquivalenceId"
  },
  "api/MoreStructures.Tests.SuffixTrees.Builders.NaivePartiallyRecursiveSuffixTreeBuilderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Builders.NaivePartiallyRecursiveSuffixTreeBuilderTests.html",
    "title": "Class NaivePartiallyRecursiveSuffixTreeBuilderTests",
    "keywords": "Class NaivePartiallyRecursiveSuffixTreeBuilderTests Inheritance System.Object SuffixTreeBuilderTests NaivePartiallyRecursiveSuffixTreeBuilderTests Inherited Members SuffixTreeBuilderTests.NodeToLeafPathsBuilder SuffixTreeBuilderTests.Builder SuffixTreeBuilderTests.BuildTree_IsCorrectWithSingleText(BuilderEquivalences.EquivalenceId) SuffixTreeBuilderTests.BuildTree_IsCorrectWithMultipleTexts(BuilderEquivalences.EquivalenceId) SuffixTreeBuilderTests.BuildTree_StringIncludingTerminator() SuffixTreeBuilderTests.BuildTree_ReturnsOnlySuffixes() SuffixTreeBuilderTests.BuildTree_ReturnsAllSuffixes() SuffixTreeBuilderTests.BuildTree_UsesTerminatorForMatchToDistinguishSuffixesFromAnySubstring() SuffixTreeBuilderTests.BuildTree_StartLeftNullAtNonLeafNodes() SuffixTreeBuilderTests.BuildTree_StartCorrectlySetAtLeafNodes() SuffixTreeBuilderTests.BuildTree_BuildsExampleTreeFromExampleText() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees.Builders Assembly : MoreStructures.Tests.dll Syntax public class NaivePartiallyRecursiveSuffixTreeBuilderTests : SuffixTreeBuilderTests Constructors | Improve this Doc View Source NaivePartiallyRecursiveSuffixTreeBuilderTests() Declaration public NaivePartiallyRecursiveSuffixTreeBuilderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.Builders.SuffixAndLcpArraysBasedSuffixTreeBuilderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Builders.SuffixAndLcpArraysBasedSuffixTreeBuilderTests.html",
    "title": "Class SuffixAndLcpArraysBasedSuffixTreeBuilderTests",
    "keywords": "Class SuffixAndLcpArraysBasedSuffixTreeBuilderTests Inheritance System.Object SuffixTreeBuilderTests SuffixAndLcpArraysBasedSuffixTreeBuilderTests Inherited Members SuffixTreeBuilderTests.NodeToLeafPathsBuilder SuffixTreeBuilderTests.Builder SuffixTreeBuilderTests.BuildTree_IsCorrectWithSingleText(BuilderEquivalences.EquivalenceId) SuffixTreeBuilderTests.BuildTree_IsCorrectWithMultipleTexts(BuilderEquivalences.EquivalenceId) SuffixTreeBuilderTests.BuildTree_StringIncludingTerminator() SuffixTreeBuilderTests.BuildTree_ReturnsOnlySuffixes() SuffixTreeBuilderTests.BuildTree_ReturnsAllSuffixes() SuffixTreeBuilderTests.BuildTree_UsesTerminatorForMatchToDistinguishSuffixesFromAnySubstring() SuffixTreeBuilderTests.BuildTree_StartLeftNullAtNonLeafNodes() SuffixTreeBuilderTests.BuildTree_StartCorrectlySetAtLeafNodes() SuffixTreeBuilderTests.BuildTree_BuildsExampleTreeFromExampleText() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees.Builders Assembly : MoreStructures.Tests.dll Syntax public class SuffixAndLcpArraysBasedSuffixTreeBuilderTests : SuffixTreeBuilderTests Constructors | Improve this Doc View Source SuffixAndLcpArraysBasedSuffixTreeBuilderTests() Declaration public SuffixAndLcpArraysBasedSuffixTreeBuilderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.Builders.SuffixTreeBuilderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Builders.SuffixTreeBuilderTests.html",
    "title": "Class SuffixTreeBuilderTests",
    "keywords": "Class SuffixTreeBuilderTests Inheritance System.Object SuffixTreeBuilderTests NaivePartiallyRecursiveSuffixTreeBuilderTests SuffixAndLcpArraysBasedSuffixTreeBuilderTests UkkonenSuffixTreeBuilderTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees.Builders Assembly : MoreStructures.Tests.dll Syntax public abstract class SuffixTreeBuilderTests Constructors | Improve this Doc View Source SuffixTreeBuilderTests(IBuilder<SuffixTreeEdge, SuffixTreeNode>) Declaration public SuffixTreeBuilderTests(IBuilder<SuffixTreeEdge, SuffixTreeNode> builder) Parameters Type Name Description IBuilder < SuffixTreeEdge , SuffixTreeNode > builder Fields | Improve this Doc View Source Builder Declaration protected readonly IBuilder<SuffixTreeEdge, SuffixTreeNode> Builder Field Value Type Description IBuilder < SuffixTreeEdge , SuffixTreeNode > | Improve this Doc View Source NodeToLeafPathsBuilder Declaration protected static readonly INodeToLeafPathsBuilder NodeToLeafPathsBuilder Field Value Type Description INodeToLeafPathsBuilder Methods | Improve this Doc View Source BuildTree_BuildsExampleTreeFromExampleText() Declaration public void BuildTree_BuildsExampleTreeFromExampleText() | Improve this Doc View Source BuildTree_IsCorrectWithMultipleTexts(BuilderEquivalences.EquivalenceId) Declaration public void BuildTree_IsCorrectWithMultipleTexts(BuilderEquivalences.EquivalenceId equivalenceId) Parameters Type Name Description BuilderEquivalences.EquivalenceId equivalenceId | Improve this Doc View Source BuildTree_IsCorrectWithSingleText(BuilderEquivalences.EquivalenceId) Declaration public void BuildTree_IsCorrectWithSingleText(BuilderEquivalences.EquivalenceId equivalenceId) Parameters Type Name Description BuilderEquivalences.EquivalenceId equivalenceId | Improve this Doc View Source BuildTree_ReturnsAllSuffixes() Declaration public void BuildTree_ReturnsAllSuffixes() | Improve this Doc View Source BuildTree_ReturnsOnlySuffixes() Declaration public void BuildTree_ReturnsOnlySuffixes() | Improve this Doc View Source BuildTree_StartCorrectlySetAtLeafNodes() Declaration public void BuildTree_StartCorrectlySetAtLeafNodes() | Improve this Doc View Source BuildTree_StartLeftNullAtNonLeafNodes() Declaration public void BuildTree_StartLeftNullAtNonLeafNodes() | Improve this Doc View Source BuildTree_StringIncludingTerminator() Declaration public void BuildTree_StringIncludingTerminator() | Improve this Doc View Source BuildTree_UsesTerminatorForMatchToDistinguishSuffixesFromAnySubstring() Declaration public void BuildTree_UsesTerminatorForMatchToDistinguishSuffixesFromAnySubstring() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.Builders.Ukkonen.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Builders.Ukkonen.html",
    "title": "Namespace MoreStructures.Tests.SuffixTrees.Builders.Ukkonen",
    "keywords": "Namespace MoreStructures.Tests.SuffixTrees.Builders.Ukkonen Classes IterationStateTests MutableEdgeTests"
  },
  "api/MoreStructures.Tests.SuffixTrees.Builders.Ukkonen.IterationStateTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Builders.Ukkonen.IterationStateTests.html",
    "title": "Class IterationStateTests",
    "keywords": "Class IterationStateTests Inheritance System.Object IterationStateTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees.Builders.Ukkonen Assembly : MoreStructures.Tests.dll Syntax public class IterationStateTests Methods | Improve this Doc View Source ActivePointFollowedByCurrentChar_NullAtStart() Declaration public void ActivePointFollowedByCurrentChar_NullAtStart() | Improve this Doc View Source ActivePointFollowedByCurrentChar_ThrowsExceptionBeforeStartingAPhase() Declaration public void ActivePointFollowedByCurrentChar_ThrowsExceptionBeforeStartingAPhase() | Improve this Doc View Source ActivePointFollowedByCurrentChar_WhenActivePointIsDefined_FalseCases() Declaration public void ActivePointFollowedByCurrentChar_WhenActivePointIsDefined_FalseCases() | Improve this Doc View Source ActivePointFollowedByCurrentChar_WhenActivePointIsDefined_TrueCases() Declaration public void ActivePointFollowedByCurrentChar_WhenActivePointIsDefined_TrueCases() | Improve this Doc View Source InitializeActiveEdgeAndLength_ThrowsExceptionWhenInvalidActivePoint() Declaration public void InitializeActiveEdgeAndLength_ThrowsExceptionWhenInvalidActivePoint() | Improve this Doc View Source IsThereANextPhase_IsCorrect() Declaration public void IsThereANextPhase_IsCorrect() | Improve this Doc View Source Root_IsSetOnConstruction() Declaration public void Root_IsSetOnConstruction() | Improve this Doc View Source StillRemainingSuffixesInCurrentPhase_AccessProtectedWhenNotInPhase() Declaration public void StillRemainingSuffixesInCurrentPhase_AccessProtectedWhenNotInPhase() | Improve this Doc View Source Text_IsSetOnConstruction() Declaration public void Text_IsSetOnConstruction() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.Builders.Ukkonen.MutableEdgeTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Builders.Ukkonen.MutableEdgeTests.html",
    "title": "Class MutableEdgeTests",
    "keywords": "Class MutableEdgeTests Inheritance System.Object MutableEdgeTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees.Builders.Ukkonen Assembly : MoreStructures.Tests.dll Syntax public class MutableEdgeTests Methods | Improve this Doc View Source Equals_BasedOnStartAndEndValue() Declaration public void Equals_BasedOnStartAndEndValue() | Improve this Doc View Source GetHashCode_DoesntChangeWhenMovingEnd() Declaration public void GetHashCode_DoesntChangeWhenMovingEnd() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.Builders.UkkonenSuffixTreeBuilderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Builders.UkkonenSuffixTreeBuilderTests.html",
    "title": "Class UkkonenSuffixTreeBuilderTests",
    "keywords": "Class UkkonenSuffixTreeBuilderTests Inheritance System.Object SuffixTreeBuilderTests UkkonenSuffixTreeBuilderTests Inherited Members SuffixTreeBuilderTests.NodeToLeafPathsBuilder SuffixTreeBuilderTests.Builder SuffixTreeBuilderTests.BuildTree_IsCorrectWithSingleText(BuilderEquivalences.EquivalenceId) SuffixTreeBuilderTests.BuildTree_IsCorrectWithMultipleTexts(BuilderEquivalences.EquivalenceId) SuffixTreeBuilderTests.BuildTree_StringIncludingTerminator() SuffixTreeBuilderTests.BuildTree_ReturnsOnlySuffixes() SuffixTreeBuilderTests.BuildTree_ReturnsAllSuffixes() SuffixTreeBuilderTests.BuildTree_UsesTerminatorForMatchToDistinguishSuffixesFromAnySubstring() SuffixTreeBuilderTests.BuildTree_StartLeftNullAtNonLeafNodes() SuffixTreeBuilderTests.BuildTree_StartCorrectlySetAtLeafNodes() SuffixTreeBuilderTests.BuildTree_BuildsExampleTreeFromExampleText() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees.Builders Assembly : MoreStructures.Tests.dll Syntax public class UkkonenSuffixTreeBuilderTests : SuffixTreeBuilderTests Constructors | Improve this Doc View Source UkkonenSuffixTreeBuilderTests() Declaration public UkkonenSuffixTreeBuilderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.html",
    "title": "Namespace MoreStructures.Tests.SuffixTrees",
    "keywords": "Namespace MoreStructures.Tests.SuffixTrees Classes SuffixTreeEdgeTests SuffixTreeNodeTests"
  },
  "api/MoreStructures.Tests.SuffixTrees.Matching.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Matching.html",
    "title": "Namespace MoreStructures.Tests.SuffixTrees.Matching",
    "keywords": "Namespace MoreStructures.Tests.SuffixTrees.Matching Classes MatcherTests NaiveSnssFinderTests SnssFinderTests SuffixStructureBasedSnssFinderTests SuffixTreeBasedSnssFinderTests SuffixTrieBasedSnssFinderTests"
  },
  "api/MoreStructures.Tests.SuffixTrees.Matching.MatcherTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Matching.MatcherTests.html",
    "title": "Class MatcherTests",
    "keywords": "Class MatcherTests Inheritance System.Object MatcherTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees.Matching Assembly : MoreStructures.Tests.dll Syntax public class MatcherTests Methods | Improve this Doc View Source BuildTree_UsesTerminatorForMatchToDistinguishSuffixesFromAnySubstring() Declaration public void BuildTree_UsesTerminatorForMatchToDistinguishSuffixesFromAnySubstring() | Improve this Doc View Source Match_Preconditions() Declaration public void Match_Preconditions() | Improve this Doc View Source Match_SuccessAndMatchedCharsIsCorrect() Declaration public void Match_SuccessAndMatchedCharsIsCorrect() | Improve this Doc View Source Match_SuccessBeginAndPathIsCorrect() Declaration public void Match_SuccessBeginAndPathIsCorrect() | Improve this Doc View Source Match_UnsuccessAndMatchedCharsIsCorrect() Declaration public void Match_UnsuccessAndMatchedCharsIsCorrect() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.Matching.NaiveSnssFinderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Matching.NaiveSnssFinderTests.html",
    "title": "Class NaiveSnssFinderTests",
    "keywords": "Class NaiveSnssFinderTests Inheritance System.Object SnssFinderTests NaiveSnssFinderTests Inherited Members SnssFinderTests.Finder SnssFinderTests.Find_IsCorrect(String, String, String[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees.Matching Assembly : MoreStructures.Tests.dll Syntax public class NaiveSnssFinderTests : SnssFinderTests Constructors | Improve this Doc View Source NaiveSnssFinderTests() Declaration public NaiveSnssFinderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.Matching.SnssFinderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Matching.SnssFinderTests.html",
    "title": "Class SnssFinderTests",
    "keywords": "Class SnssFinderTests Inheritance System.Object SnssFinderTests NaiveSnssFinderTests SuffixStructureBasedSnssFinderTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees.Matching Assembly : MoreStructures.Tests.dll Syntax public abstract class SnssFinderTests Constructors | Improve this Doc View Source SnssFinderTests(ISnssFinder) Declaration protected SnssFinderTests(ISnssFinder finder) Parameters Type Name Description ISnssFinder finder Properties | Improve this Doc View Source Finder Declaration protected ISnssFinder Finder { get; } Property Value Type Description ISnssFinder Methods | Improve this Doc View Source Find_IsCorrect(String, String, String[]) Declaration public void Find_IsCorrect(string text1, string text2, string[] expectedResult) Parameters Type Name Description System.String text1 System.String text2 System.String [] expectedResult Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.Matching.SuffixStructureBasedSnssFinderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Matching.SuffixStructureBasedSnssFinderTests.html",
    "title": "Class SuffixStructureBasedSnssFinderTests",
    "keywords": "Class SuffixStructureBasedSnssFinderTests Inheritance System.Object SnssFinderTests SuffixStructureBasedSnssFinderTests SuffixTreeBasedSnssFinderTests SuffixTrieBasedSnssFinderTests Inherited Members SnssFinderTests.Finder SnssFinderTests.Find_IsCorrect(String, String, String[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees.Matching Assembly : MoreStructures.Tests.dll Syntax public abstract class SuffixStructureBasedSnssFinderTests : SnssFinderTests Constructors | Improve this Doc View Source SuffixStructureBasedSnssFinderTests(ISnssFinder) Declaration protected SuffixStructureBasedSnssFinderTests(ISnssFinder finder) Parameters Type Name Description ISnssFinder finder Fields | Improve this Doc View Source DefaultTerminator1 Declaration protected const char DefaultTerminator1 = '#' Field Value Type Description System.Char | Improve this Doc View Source DefaultTerminator2 Declaration protected const char DefaultTerminator2 = '$' Field Value Type Description System.Char Methods | Improve this Doc View Source Find_RaiseExceptionWhenAnyTerminatorIsInAnyText() Declaration public void Find_RaiseExceptionWhenAnyTerminatorIsInAnyText() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.Matching.SuffixTreeBasedSnssFinderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Matching.SuffixTreeBasedSnssFinderTests.html",
    "title": "Class SuffixTreeBasedSnssFinderTests",
    "keywords": "Class SuffixTreeBasedSnssFinderTests Inheritance System.Object SnssFinderTests SuffixStructureBasedSnssFinderTests SuffixTreeBasedSnssFinderTests Inherited Members SuffixStructureBasedSnssFinderTests.DefaultTerminator1 SuffixStructureBasedSnssFinderTests.DefaultTerminator2 SuffixStructureBasedSnssFinderTests.Find_RaiseExceptionWhenAnyTerminatorIsInAnyText() SnssFinderTests.Finder SnssFinderTests.Find_IsCorrect(String, String, String[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees.Matching Assembly : MoreStructures.Tests.dll Syntax public class SuffixTreeBasedSnssFinderTests : SuffixStructureBasedSnssFinderTests Constructors | Improve this Doc View Source SuffixTreeBasedSnssFinderTests() Declaration public SuffixTreeBasedSnssFinderTests() Methods | Improve this Doc View Source Ctor_RaiseExceptionWhenTerminatorsAreEqual() Declaration public void Ctor_RaiseExceptionWhenTerminatorsAreEqual() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.Matching.SuffixTrieBasedSnssFinderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.Matching.SuffixTrieBasedSnssFinderTests.html",
    "title": "Class SuffixTrieBasedSnssFinderTests",
    "keywords": "Class SuffixTrieBasedSnssFinderTests Inheritance System.Object SnssFinderTests SuffixStructureBasedSnssFinderTests SuffixTrieBasedSnssFinderTests Inherited Members SuffixStructureBasedSnssFinderTests.DefaultTerminator1 SuffixStructureBasedSnssFinderTests.DefaultTerminator2 SuffixStructureBasedSnssFinderTests.Find_RaiseExceptionWhenAnyTerminatorIsInAnyText() SnssFinderTests.Finder SnssFinderTests.Find_IsCorrect(String, String, String[]) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees.Matching Assembly : MoreStructures.Tests.dll Syntax public class SuffixTrieBasedSnssFinderTests : SuffixStructureBasedSnssFinderTests Constructors | Improve this Doc View Source SuffixTrieBasedSnssFinderTests() Declaration public SuffixTrieBasedSnssFinderTests() Methods | Improve this Doc View Source Ctor_RaiseExceptionWhenTerminatorsAreEqual() Declaration public void Ctor_RaiseExceptionWhenTerminatorsAreEqual() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.SuffixTreeEdgeTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.SuffixTreeEdgeTests.html",
    "title": "Class SuffixTreeEdgeTests",
    "keywords": "Class SuffixTreeEdgeTests Inheritance System.Object SuffixTreeEdgeTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees Assembly : MoreStructures.Tests.dll Syntax public class SuffixTreeEdgeTests Methods | Improve this Doc View Source CompareTo_IsCorrect() Declaration public void CompareTo_IsCorrect() | Improve this Doc View Source Ctor_ValidIndex() Declaration public void Ctor_ValidIndex() | Improve this Doc View Source Ctor_ZeroLengthIsValid() Declaration public void Ctor_ZeroLengthIsValid() | Improve this Doc View Source Of_InboundIndexes() Declaration public void Of_InboundIndexes() | Improve this Doc View Source Of_OutOfBoundsIndexes() Declaration public void Of_OutOfBoundsIndexes() | Improve this Doc View Source OfRotated_InboundIndexes() Declaration public void OfRotated_InboundIndexes() | Improve this Doc View Source OfRotated_OutOfBoundsIndexes() Declaration public void OfRotated_OutOfBoundsIndexes() | Improve this Doc View Source ToString_OfEquivalentInstancesAreTheSame() Declaration public void ToString_OfEquivalentInstancesAreTheSame() | Improve this Doc View Source ToString_WithDifferentStartOrLengthAreDifferent() Declaration public void ToString_WithDifferentStartOrLengthAreDifferent() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTrees.SuffixTreeNodeTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTrees.SuffixTreeNodeTests.html",
    "title": "Class SuffixTreeNodeTests",
    "keywords": "Class SuffixTreeNodeTests Inheritance System.Object SuffixTreeNodeTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTrees Assembly : MoreStructures.Tests.dll Syntax public class SuffixTreeNodeTests Methods | Improve this Doc View Source Children_Immutability_FromCtorParam() Declaration public void Children_Immutability_FromCtorParam() | Improve this Doc View Source Children_Immutability_OnGet() Declaration public void Children_Immutability_OnGet() | Improve this Doc View Source Ctor_InvalidArguments() Declaration public void Ctor_InvalidArguments() | Improve this Doc View Source Equality_IsAlwaysByValue() Declaration public void Equality_IsAlwaysByValue() | Improve this Doc View Source Indexer_RetrievesChild() Declaration public void Indexer_RetrievesChild() | Improve this Doc View Source IsEquivalent_IsCorrectWithIntermediateWithMultipleCharsEdges() Declaration public void IsEquivalent_IsCorrectWithIntermediateWithMultipleCharsEdges() | Improve this Doc View Source IsEquivalent_IsCorrectWithIntermediateWithSameChildrenButShuffledEdges() Declaration public void IsEquivalent_IsCorrectWithIntermediateWithSameChildrenButShuffledEdges() | Improve this Doc View Source IsEquivalent_IsCorrectWithIntermediateWithSingleCharEdges() Declaration public void IsEquivalent_IsCorrectWithIntermediateWithSingleCharEdges() | Improve this Doc View Source IsEquivalent_IsCorrectWithLeaves() Declaration public void IsEquivalent_IsCorrectWithLeaves() | Improve this Doc View Source ToString_IsTheSameOnEquivalentTrees() Declaration public void ToString_IsTheSameOnEquivalentTrees() | Improve this Doc View Source ToString_OnLeafIncludesStart() Declaration public void ToString_OnLeafIncludesStart() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTries.Builders.BuilderEquivalences.EquivalenceId.html": {
    "href": "api/MoreStructures.Tests.SuffixTries.Builders.BuilderEquivalences.EquivalenceId.html",
    "title": "Enum BuilderEquivalences.EquivalenceId",
    "keywords": "Enum BuilderEquivalences.EquivalenceId Namespace : MoreStructures.Tests.SuffixTries.Builders Assembly : MoreStructures.Tests.dll Syntax public enum EquivalenceId Fields Name Description EmptyStrings OneEmptyOneNonEmpty OneNonEmptyOneEmpty ThreeDifferent ThreeSame TwoEmptyOneNonEmpty TwoEmptyOneNonEmptyDifferentOrder TwoNonSharingChars TwoSame TwoSameOneDifferent TwoSharingChars Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, BuilderEquivalences.EquivalenceId>(TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTries.Builders.BuilderEquivalences.EquivalenceValue.html": {
    "href": "api/MoreStructures.Tests.SuffixTries.Builders.BuilderEquivalences.EquivalenceValue.html",
    "title": "Class BuilderEquivalences.EquivalenceValue",
    "keywords": "Class BuilderEquivalences.EquivalenceValue Inheritance System.Object BuilderEquivalences.EquivalenceValue Implements System.IEquatable < BuilderEquivalences.EquivalenceValue > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTries.Builders Assembly : MoreStructures.Tests.dll Syntax public class EquivalenceValue : IEquatable<BuilderEquivalences.EquivalenceValue> Constructors | Improve this Doc View Source EquivalenceValue(TextWithTerminator[], SuffixTrieNode) Declaration public EquivalenceValue(TextWithTerminator[] Texts, SuffixTrieNode TreeNode) Parameters Type Name Description TextWithTerminator [] Texts SuffixTrieNode TreeNode Properties | Improve this Doc View Source Texts Declaration public TextWithTerminator[] Texts { get; set; } Property Value Type Description TextWithTerminator [] | Improve this Doc View Source TreeNode Declaration public SuffixTrieNode TreeNode { get; set; } Property Value Type Description SuffixTrieNode Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTries.Builders.BuilderEquivalences.html": {
    "href": "api/MoreStructures.Tests.SuffixTries.Builders.BuilderEquivalences.html",
    "title": "Class BuilderEquivalences",
    "keywords": "Class BuilderEquivalences Inheritance System.Object BuilderEquivalences Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTries.Builders Assembly : MoreStructures.Tests.dll Syntax public static class BuilderEquivalences Fields | Improve this Doc View Source Equivalences Declaration public static readonly Dictionary<BuilderEquivalences.EquivalenceId, BuilderEquivalences.EquivalenceValue> Equivalences Field Value Type Description Dictionary < BuilderEquivalences.EquivalenceId , BuilderEquivalences.EquivalenceValue >"
  },
  "api/MoreStructures.Tests.SuffixTries.Builders.html": {
    "href": "api/MoreStructures.Tests.SuffixTries.Builders.html",
    "title": "Namespace MoreStructures.Tests.SuffixTries.Builders",
    "keywords": "Namespace MoreStructures.Tests.SuffixTries.Builders Classes BuilderEquivalences BuilderEquivalences.EquivalenceValue NaivePartiallyRecursiveSuffixTrieBuilderTests SuffixTrieBuilderTests Enums BuilderEquivalences.EquivalenceId"
  },
  "api/MoreStructures.Tests.SuffixTries.Builders.NaivePartiallyRecursiveSuffixTrieBuilderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTries.Builders.NaivePartiallyRecursiveSuffixTrieBuilderTests.html",
    "title": "Class NaivePartiallyRecursiveSuffixTrieBuilderTests",
    "keywords": "Class NaivePartiallyRecursiveSuffixTrieBuilderTests Inheritance System.Object SuffixTrieBuilderTests NaivePartiallyRecursiveSuffixTrieBuilderTests Inherited Members SuffixTrieBuilderTests.NodeToLeafPathsBuilder SuffixTrieBuilderTests.BuildTree_WithTextWithTerminatorInput() SuffixTrieBuilderTests.BuildTree_EmptyString() SuffixTrieBuilderTests.BuildTree_StringIncludingTerminator() SuffixTrieBuilderTests.BuildTree_SingleCharString() SuffixTrieBuilderTests.BuildTree_TwoCharsString_DifferentPrefixes() SuffixTrieBuilderTests.BuildTree_TwoCharsString_SamePrefixes() SuffixTrieBuilderTests.BuildTree_ThreeCharsString_SamePrefixes() SuffixTrieBuilderTests.BuildTree_ThreeCharsString_PartiallySamePrefixes() SuffixTrieBuilderTests.BuildTree_ThreeCharsString_DifferentPrefixes() SuffixTrieBuilderTests.BuildTree_ReturnsOnlySuffixes() SuffixTrieBuilderTests.BuildTree_ReturnsAllSuffixes() SuffixTrieBuilderTests.BuildTree_StartLeftNullAtNonLeafNodes() SuffixTrieBuilderTests.BuildTree_StartCorrectlySetAtLeafNodes() SuffixTrieBuilderTests.BuildTree_BuildsExampleTrieFromExampleText() SuffixTrieBuilderTests.BuildTree_IsCorrectWithMultipleTexts(BuilderEquivalences.EquivalenceId) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTries.Builders Assembly : MoreStructures.Tests.dll Syntax public class NaivePartiallyRecursiveSuffixTrieBuilderTests : SuffixTrieBuilderTests Constructors | Improve this Doc View Source NaivePartiallyRecursiveSuffixTrieBuilderTests() Declaration public NaivePartiallyRecursiveSuffixTrieBuilderTests() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTries.Builders.SuffixTrieBuilderTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTries.Builders.SuffixTrieBuilderTests.html",
    "title": "Class SuffixTrieBuilderTests",
    "keywords": "Class SuffixTrieBuilderTests Inheritance System.Object SuffixTrieBuilderTests NaivePartiallyRecursiveSuffixTrieBuilderTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTries.Builders Assembly : MoreStructures.Tests.dll Syntax public abstract class SuffixTrieBuilderTests Constructors | Improve this Doc View Source SuffixTrieBuilderTests(IBuilder<SuffixTrieEdge, SuffixTrieNode>) Declaration public SuffixTrieBuilderTests(IBuilder<SuffixTrieEdge, SuffixTrieNode> builder) Parameters Type Name Description IBuilder < SuffixTrieEdge , SuffixTrieNode > builder Fields | Improve this Doc View Source NodeToLeafPathsBuilder Declaration protected static readonly INodeToLeafPathsBuilder NodeToLeafPathsBuilder Field Value Type Description INodeToLeafPathsBuilder Methods | Improve this Doc View Source BuildTree_BuildsExampleTrieFromExampleText() Declaration public void BuildTree_BuildsExampleTrieFromExampleText() | Improve this Doc View Source BuildTree_EmptyString() Declaration public void BuildTree_EmptyString() | Improve this Doc View Source BuildTree_IsCorrectWithMultipleTexts(BuilderEquivalences.EquivalenceId) Declaration public void BuildTree_IsCorrectWithMultipleTexts(BuilderEquivalences.EquivalenceId equivalenceId) Parameters Type Name Description BuilderEquivalences.EquivalenceId equivalenceId | Improve this Doc View Source BuildTree_ReturnsAllSuffixes() Declaration public void BuildTree_ReturnsAllSuffixes() | Improve this Doc View Source BuildTree_ReturnsOnlySuffixes() Declaration public void BuildTree_ReturnsOnlySuffixes() | Improve this Doc View Source BuildTree_SingleCharString() Declaration public void BuildTree_SingleCharString() | Improve this Doc View Source BuildTree_StartCorrectlySetAtLeafNodes() Declaration public void BuildTree_StartCorrectlySetAtLeafNodes() | Improve this Doc View Source BuildTree_StartLeftNullAtNonLeafNodes() Declaration public void BuildTree_StartLeftNullAtNonLeafNodes() | Improve this Doc View Source BuildTree_StringIncludingTerminator() Declaration public void BuildTree_StringIncludingTerminator() | Improve this Doc View Source BuildTree_ThreeCharsString_DifferentPrefixes() Declaration public void BuildTree_ThreeCharsString_DifferentPrefixes() | Improve this Doc View Source BuildTree_ThreeCharsString_PartiallySamePrefixes() Declaration public void BuildTree_ThreeCharsString_PartiallySamePrefixes() | Improve this Doc View Source BuildTree_ThreeCharsString_SamePrefixes() Declaration public void BuildTree_ThreeCharsString_SamePrefixes() | Improve this Doc View Source BuildTree_TwoCharsString_DifferentPrefixes() Declaration public void BuildTree_TwoCharsString_DifferentPrefixes() | Improve this Doc View Source BuildTree_TwoCharsString_SamePrefixes() Declaration public void BuildTree_TwoCharsString_SamePrefixes() | Improve this Doc View Source BuildTree_WithTextWithTerminatorInput() Declaration public void BuildTree_WithTextWithTerminatorInput() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTries.html": {
    "href": "api/MoreStructures.Tests.SuffixTries.html",
    "title": "Namespace MoreStructures.Tests.SuffixTries",
    "keywords": "Namespace MoreStructures.Tests.SuffixTries Classes SuffixTrieEdgeTests SuffixTrieNodeTests"
  },
  "api/MoreStructures.Tests.SuffixTries.SuffixTrieEdgeTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTries.SuffixTrieEdgeTests.html",
    "title": "Class SuffixTrieEdgeTests",
    "keywords": "Class SuffixTrieEdgeTests Inheritance System.Object SuffixTrieEdgeTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTries Assembly : MoreStructures.Tests.dll Syntax public class SuffixTrieEdgeTests Methods | Improve this Doc View Source CompareTo_IsCorrect() Declaration public void CompareTo_IsCorrect() | Improve this Doc View Source Ctor_ValidIndex() Declaration public void Ctor_ValidIndex() | Improve this Doc View Source Of_InboundIndexes() Declaration public void Of_InboundIndexes() | Improve this Doc View Source Of_OutOfBoundsIndexes() Declaration public void Of_OutOfBoundsIndexes() | Improve this Doc View Source ToString_OfEquivalentInstancesAreTheSame() Declaration public void ToString_OfEquivalentInstancesAreTheSame() | Improve this Doc View Source ToString_WithDifferentStart() Declaration public void ToString_WithDifferentStart() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.SuffixTries.SuffixTrieNodeTests.html": {
    "href": "api/MoreStructures.Tests.SuffixTries.SuffixTrieNodeTests.html",
    "title": "Class SuffixTrieNodeTests",
    "keywords": "Class SuffixTrieNodeTests Inheritance System.Object SuffixTrieNodeTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.SuffixTries Assembly : MoreStructures.Tests.dll Syntax public class SuffixTrieNodeTests Methods | Improve this Doc View Source Children_Immutability_FromCtorParam() Declaration public void Children_Immutability_FromCtorParam() | Improve this Doc View Source Children_ImmutabilityOnGet() Declaration public void Children_ImmutabilityOnGet() | Improve this Doc View Source Ctor_InvalidArguments() Declaration public void Ctor_InvalidArguments() | Improve this Doc View Source Equality_IsAlwaysByValue() Declaration public void Equality_IsAlwaysByValue() | Improve this Doc View Source Indexer_RetrievesChild() Declaration public void Indexer_RetrievesChild() | Improve this Doc View Source ToString_IsTheSameOnEquivalentTrees() Declaration public void ToString_IsTheSameOnEquivalentTrees() | Improve this Doc View Source ToString_OnLeafIncludesStart() Declaration public void ToString_OnLeafIncludesStart() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.TextWithTerminatorExtensionsTests.html": {
    "href": "api/MoreStructures.Tests.TextWithTerminatorExtensionsTests.html",
    "title": "Class TextWithTerminatorExtensionsTests",
    "keywords": "Class TextWithTerminatorExtensionsTests Inheritance System.Object TextWithTerminatorExtensionsTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests Assembly : MoreStructures.Tests.dll Syntax public class TextWithTerminatorExtensionsTests Methods | Improve this Doc View Source BuildTerminatorsCDF_IsCorrect(String[], Int32[]) Declaration public void BuildTerminatorsCDF_IsCorrect(string[] textContentsWithTerminator, int[] expectedResult) Parameters Type Name Description System.String [] textContentsWithTerminator System.Int32 [] expectedResult | Improve this Doc View Source BuildTerminatorsIndexMap_IsCorrect(String[], Int32[]) Declaration public void BuildTerminatorsIndexMap_IsCorrect(string[] textContentsWithTerminator, int[] expectedResult) Parameters Type Name Description System.String [] textContentsWithTerminator System.Int32 [] expectedResult | Improve this Doc View Source GenerateFullText_IsCorrect(String, Char, String[], Char[]) Declaration public void GenerateFullText_IsCorrect(string expectedText, char expectedTerminator, string[] textContents, char[] terminators) Parameters Type Name Description System.String expectedText System.Char expectedTerminator System.String [] textContents System.Char [] terminators | Improve this Doc View Source GenerateFullText_RaiseExceptionOnRepeatedTerminators() Declaration public void GenerateFullText_RaiseExceptionOnRepeatedTerminators() | Improve this Doc View Source ToVirtuallyRotated() Declaration public void ToVirtuallyRotated() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.TextWithTerminatorTests.html": {
    "href": "api/MoreStructures.Tests.TextWithTerminatorTests.html",
    "title": "Class TextWithTerminatorTests",
    "keywords": "Class TextWithTerminatorTests Inheritance System.Object TextWithTerminatorTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests Assembly : MoreStructures.Tests.dll Syntax public class TextWithTerminatorTests Methods | Improve this Doc View Source Ctor_BrokenInvariant_WithoutValidateInput() Declaration public void Ctor_BrokenInvariant_WithoutValidateInput() | Improve this Doc View Source Ctor_Preconditions_WithValidateInput() Declaration public void Ctor_Preconditions_WithValidateInput() | Improve this Doc View Source EndsWith_IsCorrect() Declaration public void EndsWith_IsCorrect() | Improve this Doc View Source GetEnumerator_Generic_IsCorrect() Declaration public void GetEnumerator_Generic_IsCorrect() | Improve this Doc View Source GetEnumerator_Generic_WorksWithLinq() Declaration public void GetEnumerator_Generic_WorksWithLinq() | Improve this Doc View Source GetEnumerator_NonGeneric_IsCorrect() Declaration public void GetEnumerator_NonGeneric_IsCorrect() | Improve this Doc View Source Indexer_WithIndexOfEnumerable() Declaration public void Indexer_WithIndexOfEnumerable() | Improve this Doc View Source Indexer_WithIndexOfString() Declaration public void Indexer_WithIndexOfString() | Improve this Doc View Source Indexer_WithRangeOfEnumerable() Declaration public void Indexer_WithRangeOfEnumerable() | Improve this Doc View Source Indexer_WithRangeOfString() Declaration public void Indexer_WithRangeOfString() | Improve this Doc View Source Indexer_WithSelector() Declaration public void Indexer_WithSelector() | Improve this Doc View Source Length_IsCorrect() Declaration public void Length_IsCorrect() | Improve this Doc View Source StartsWith_IsCorrect() Declaration public void StartsWith_IsCorrect() | Improve this Doc View Source TerminatorIndex_IsCorrect() Declaration public void TerminatorIndex_IsCorrect() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Utilities.CharOrTerminatorComparerTests.html": {
    "href": "api/MoreStructures.Tests.Utilities.CharOrTerminatorComparerTests.html",
    "title": "Class CharOrTerminatorComparerTests",
    "keywords": "Class CharOrTerminatorComparerTests Inheritance System.Object CharOrTerminatorComparerTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Utilities Assembly : MoreStructures.Tests.dll Syntax public class CharOrTerminatorComparerTests Methods | Improve this Doc View Source Compare_IsCorrect_WithTerminatorHigherInASCII() Declaration public void Compare_IsCorrect_WithTerminatorHigherInASCII() | Improve this Doc View Source Compare_IsCorrect_WithTerminatorLowerInASCII() Declaration public void Compare_IsCorrect_WithTerminatorLowerInASCII() | Improve this Doc View Source Equals_ByValue() Declaration public void Equals_ByValue() | Improve this Doc View Source GetHashCode_ByValue() Declaration public void GetHashCode_ByValue() | Improve this Doc View Source Terminator_IsSet() Declaration public void Terminator_IsSet() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Utilities.EnumerableExtensionsTests.html": {
    "href": "api/MoreStructures.Tests.Utilities.EnumerableExtensionsTests.html",
    "title": "Class EnumerableExtensionsTests",
    "keywords": "Class EnumerableExtensionsTests Inheritance System.Object EnumerableExtensionsTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Utilities Assembly : MoreStructures.Tests.dll Syntax public class EnumerableExtensionsTests Methods | Improve this Doc View Source CountO1_DoesntEnumerateGenericIListImplementers() Declaration public void CountO1_DoesntEnumerateGenericIListImplementers() | Improve this Doc View Source CountO1_DoesntEnumerateNonGenericIListImplementers() Declaration public void CountO1_DoesntEnumerateNonGenericIListImplementers() | Improve this Doc View Source CountO1_EnumeratesGenericEnumerables() Declaration public void CountO1_EnumeratesGenericEnumerables() | Improve this Doc View Source CountO1_IsCorrectWithEmptyEnumerables() Declaration public void CountO1_IsCorrectWithEmptyEnumerables() | Improve this Doc View Source CountO1_IsCorrectWithMultipleValues() Declaration public void CountO1_IsCorrectWithMultipleValues() | Improve this Doc View Source CountO1_IsCorrectWithSingletons() Declaration public void CountO1_IsCorrectWithSingletons() | Improve this Doc View Source ElementAtO1_DoesntEnumerateGenericIListImplementers() Declaration public void ElementAtO1_DoesntEnumerateGenericIListImplementers() | Improve this Doc View Source ElementAtO1_DoesntEnumerateNonGenericIListImplementers() Declaration public void ElementAtO1_DoesntEnumerateNonGenericIListImplementers() | Improve this Doc View Source ElementAtO1_EnumeratesGenericEnumerables() Declaration public void ElementAtO1_EnumeratesGenericEnumerables() | Improve this Doc View Source ElementAtO1_IsCorrect() Declaration public void ElementAtO1_IsCorrect() | Improve this Doc View Source ElementAtO1_ThrowsExceptionForInvalidIndexes() Declaration public void ElementAtO1_ThrowsExceptionForInvalidIndexes() | Improve this Doc View Source ElementAtO1OrDefault_DoesntEnumerateGenericIListImplementers() Declaration public void ElementAtO1OrDefault_DoesntEnumerateGenericIListImplementers() | Improve this Doc View Source ElementAtO1OrDefault_DoesntEnumerateNonGenericIListImplementers() Declaration public void ElementAtO1OrDefault_DoesntEnumerateNonGenericIListImplementers() | Improve this Doc View Source ElementAtO1OrDefault_EnumeratesGenericEnumerables() Declaration public void ElementAtO1OrDefault_EnumeratesGenericEnumerables() | Improve this Doc View Source ElementAtO1OrDefault_IsCorrect() Declaration public void ElementAtO1OrDefault_IsCorrect() | Improve this Doc View Source ElementAtO1OrDefault_ReturnsDefaultForBigIndexes() Declaration public void ElementAtO1OrDefault_ReturnsDefaultForBigIndexes() | Improve this Doc View Source ElementAtO1OrDefault_ThrowsExceptionForNegativeIndexes() Declaration public void ElementAtO1OrDefault_ThrowsExceptionForNegativeIndexes() | Improve this Doc View Source EnumerateAtMostFirst_DoesntRaiseExceptionOnShorterEnumerables() Declaration public void EnumerateAtMostFirst_DoesntRaiseExceptionOnShorterEnumerables() | Improve this Doc View Source EnumerateExactlyFirst_DoesntEnumerateReminder() Declaration public void EnumerateExactlyFirst_DoesntEnumerateReminder() | Improve this Doc View Source EnumerateExactlyFirst_EnumeratesFirstNItemsCorrectly() Declaration public void EnumerateExactlyFirst_EnumeratesFirstNItemsCorrectly() | Improve this Doc View Source EnumerateExactlyFirst_RaisesExceptionOnInvalidCount() Declaration public void EnumerateExactlyFirst_RaisesExceptionOnInvalidCount() | Improve this Doc View Source EnumerateExactlyFirst_RaisesExceptionOnShorterEnumerables() Declaration public void EnumerateExactlyFirst_RaisesExceptionOnShorterEnumerables() | Improve this Doc View Source EnumerateExactlyFirst_ReminderIsCorrect() Declaration public void EnumerateExactlyFirst_ReminderIsCorrect() | Improve this Doc View Source SkipO1_IsCorrectWithEnumerables() Declaration public void SkipO1_IsCorrectWithEnumerables() | Improve this Doc View Source SkipO1_IsCorrectWithGenericLists() Declaration public void SkipO1_IsCorrectWithGenericLists() | Improve this Doc View Source SkipO1_IsCorrectWithNonGenericLists() Declaration public void SkipO1_IsCorrectWithNonGenericLists() | Improve this Doc View Source SkipO1_IsCorrectWithStrings() Declaration public void SkipO1_IsCorrectWithStrings() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Utilities.html": {
    "href": "api/MoreStructures.Tests.Utilities.html",
    "title": "Namespace MoreStructures.Tests.Utilities",
    "keywords": "Namespace MoreStructures.Tests.Utilities Classes CharOrTerminatorComparerTests EnumerableExtensionsTests LinkedListExtensionsTests LockValueObjectTests StringUtilitiesTests StringValueEnumerableTests ValueEnumerableExtensionsTests ValueEnumerableTests ValueReadOnlyCollectionsExtensionsTests ValueReadOnlyCollectionTests ValueReadOnlyDictionaryTests"
  },
  "api/MoreStructures.Tests.Utilities.LinkedListExtensionsTests.html": {
    "href": "api/MoreStructures.Tests.Utilities.LinkedListExtensionsTests.html",
    "title": "Class LinkedListExtensionsTests",
    "keywords": "Class LinkedListExtensionsTests Inheritance System.Object LinkedListExtensionsTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Utilities Assembly : MoreStructures.Tests.dll Syntax public class LinkedListExtensionsTests Methods | Improve this Doc View Source AsNode_IntermediateCoincide() Declaration public void AsNode_IntermediateCoincide() | Improve this Doc View Source AsNodes_FirstCoincide() Declaration public void AsNodes_FirstCoincide() | Improve this Doc View Source AsNodes_IsEmptyOnEmptyList() Declaration public void AsNodes_IsEmptyOnEmptyList() | Improve this Doc View Source AsNodes_LastCoincide() Declaration public void AsNodes_LastCoincide() | Improve this Doc View Source AsNodes_ReturnsItemsInOrder() Declaration public void AsNodes_ReturnsItemsInOrder() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Utilities.LockValueObjectTests.html": {
    "href": "api/MoreStructures.Tests.Utilities.LockValueObjectTests.html",
    "title": "Class LockValueObjectTests",
    "keywords": "Class LockValueObjectTests Inheritance System.Object LockValueObjectTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Utilities Assembly : MoreStructures.Tests.dll Syntax public class LockValueObjectTests Methods | Improve this Doc View Source Equals_IsByValue() Declaration public void Equals_IsByValue() | Improve this Doc View Source GetHashCode_IsByValue() Declaration public void GetHashCode_IsByValue() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Utilities.StringUtilitiesTests.html": {
    "href": "api/MoreStructures.Tests.Utilities.StringUtilitiesTests.html",
    "title": "Class StringUtilitiesTests",
    "keywords": "Class StringUtilitiesTests Inheritance System.Object StringUtilitiesTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Utilities Assembly : MoreStructures.Tests.dll Syntax public class StringUtilitiesTests Methods | Improve this Doc View Source LongestCommonPrefix_IsCorrect(String, String, Int32) Declaration public void LongestCommonPrefix_IsCorrect(string first, string second, int expected) Parameters Type Name Description System.String first System.String second System.Int32 expected | Improve this Doc View Source LongestCommonPrefix_RaisesExceptionWithInvalidIndexes() Declaration public void LongestCommonPrefix_RaisesExceptionWithInvalidIndexes() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Utilities.StringValueEnumerableTests.html": {
    "href": "api/MoreStructures.Tests.Utilities.StringValueEnumerableTests.html",
    "title": "Class StringValueEnumerableTests",
    "keywords": "Class StringValueEnumerableTests Inheritance System.Object StringValueEnumerableTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Utilities Assembly : MoreStructures.Tests.dll Syntax public class StringValueEnumerableTests Methods | Improve this Doc View Source Equals_ByValueOnItemsOfUnderlyingEnumerable() Declaration public void Equals_ByValueOnItemsOfUnderlyingEnumerable() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Utilities.ValueEnumerableExtensionsTests.html": {
    "href": "api/MoreStructures.Tests.Utilities.ValueEnumerableExtensionsTests.html",
    "title": "Class ValueEnumerableExtensionsTests",
    "keywords": "Class ValueEnumerableExtensionsTests Inheritance System.Object ValueEnumerableExtensionsTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Utilities Assembly : MoreStructures.Tests.dll Syntax public class ValueEnumerableExtensionsTests Methods | Improve this Doc View Source AsValue_WrapsProvidedEnumerableIntoAValueEnumerable() Declaration public void AsValue_WrapsProvidedEnumerableIntoAValueEnumerable() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Utilities.ValueEnumerableTests.html": {
    "href": "api/MoreStructures.Tests.Utilities.ValueEnumerableTests.html",
    "title": "Class ValueEnumerableTests",
    "keywords": "Class ValueEnumerableTests Inheritance System.Object ValueEnumerableTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Utilities Assembly : MoreStructures.Tests.dll Syntax public class ValueEnumerableTests Methods | Improve this Doc View Source Ctor_DoesntEnumerateUnderlyingEnumerable() Declaration public void Ctor_DoesntEnumerateUnderlyingEnumerable() | Improve this Doc View Source Ctor_IsIdempotent() Declaration public void Ctor_IsIdempotent() | Improve this Doc View Source Equals_ByValueOnItemsOfUnderlyingEnumerable() Declaration public void Equals_ByValueOnItemsOfUnderlyingEnumerable() | Improve this Doc View Source GetEnumerator_WithGeneric_GivesItemsOfUnderlyingEnumerable() Declaration public void GetEnumerator_WithGeneric_GivesItemsOfUnderlyingEnumerable() | Improve this Doc View Source GetEnumerator_WithoutGeneric_GivesItemsOfUnderlyingEnumerable() Declaration public void GetEnumerator_WithoutGeneric_GivesItemsOfUnderlyingEnumerable() | Improve this Doc View Source GetHashCode_ByValueOnItemsOfUnderlyingEnumerable() Declaration public void GetHashCode_ByValueOnItemsOfUnderlyingEnumerable() | Improve this Doc View Source ToString_IncludesUnderlyingEnumerableToString() Declaration public void ToString_IncludesUnderlyingEnumerableToString() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Utilities.ValueReadOnlyCollectionsExtensionsTests.html": {
    "href": "api/MoreStructures.Tests.Utilities.ValueReadOnlyCollectionsExtensionsTests.html",
    "title": "Class ValueReadOnlyCollectionsExtensionsTests",
    "keywords": "Class ValueReadOnlyCollectionsExtensionsTests Inheritance System.Object ValueReadOnlyCollectionsExtensionsTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Utilities Assembly : MoreStructures.Tests.dll Syntax public class ValueReadOnlyCollectionsExtensionsTests Methods | Improve this Doc View Source ToValueReadOnlyCollection_IsCorrect() Declaration public void ToValueReadOnlyCollection_IsCorrect() | Improve this Doc View Source ToValueReadOnlyDictionary_IsCorrectWithDictionary() Declaration public void ToValueReadOnlyDictionary_IsCorrectWithDictionary() | Improve this Doc View Source ToValueReadOnlyDictionary_IsCorrectWithEnumerable() Declaration public void ToValueReadOnlyDictionary_IsCorrectWithEnumerable() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Utilities.ValueReadOnlyCollectionTests.html": {
    "href": "api/MoreStructures.Tests.Utilities.ValueReadOnlyCollectionTests.html",
    "title": "Class ValueReadOnlyCollectionTests",
    "keywords": "Class ValueReadOnlyCollectionTests Inheritance System.Object ValueReadOnlyCollectionTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Utilities Assembly : MoreStructures.Tests.dll Syntax public class ValueReadOnlyCollectionTests Methods | Improve this Doc View Source Ctor_EmbedInputEnumerable() Declaration public void Ctor_EmbedInputEnumerable() | Improve this Doc View Source Ctor_IndependenceFromInputEnumerable() Declaration public void Ctor_IndependenceFromInputEnumerable() | Improve this Doc View Source DifferentOperator_IsByValue() Declaration public void DifferentOperator_IsByValue() | Improve this Doc View Source Equals_CheckForNull() Declaration public void Equals_CheckForNull() | Improve this Doc View Source Equals_CheckType() Declaration public void Equals_CheckType() | Improve this Doc View Source Equals_IsByValue() Declaration public void Equals_IsByValue() | Improve this Doc View Source Equals_IsSensitiveToTheOrderOfAddition() Declaration public void Equals_IsSensitiveToTheOrderOfAddition() | Improve this Doc View Source EqualsOperator_IsByValue() Declaration public void EqualsOperator_IsByValue() | Improve this Doc View Source GetHashCode_IsByValue_WithPrimitiveType() Declaration public void GetHashCode_IsByValue_WithPrimitiveType() | Improve this Doc View Source GetHashCode_IsByValue_WithRecordType() Declaration public void GetHashCode_IsByValue_WithRecordType() | Improve this Doc View Source GetHashCode_WorksWithEmptyCollection() Declaration public void GetHashCode_WorksWithEmptyCollection() | Improve this Doc View Source ToString_IncludesToStringOfItems() Declaration public void ToString_IncludesToStringOfItems() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.Utilities.ValueReadOnlyDictionaryTests.html": {
    "href": "api/MoreStructures.Tests.Utilities.ValueReadOnlyDictionaryTests.html",
    "title": "Class ValueReadOnlyDictionaryTests",
    "keywords": "Class ValueReadOnlyDictionaryTests Inheritance System.Object ValueReadOnlyDictionaryTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.Utilities Assembly : MoreStructures.Tests.dll Syntax public class ValueReadOnlyDictionaryTests Methods | Improve this Doc View Source Ctor_EmbedInputEnumerable() Declaration public void Ctor_EmbedInputEnumerable() | Improve this Doc View Source Ctor_IndependenceFromInputEnumerable() Declaration public void Ctor_IndependenceFromInputEnumerable() | Improve this Doc View Source Ctor_WithEnumerableOfEntries() Declaration public void Ctor_WithEnumerableOfEntries() | Improve this Doc View Source DifferentOperator_IsByValue() Declaration public void DifferentOperator_IsByValue() | Improve this Doc View Source Equals_CheckType() Declaration public void Equals_CheckType() | Improve this Doc View Source Equals_IsByValue() Declaration public void Equals_IsByValue() | Improve this Doc View Source Equals_IsInsensitiveToTheOrderOfAddition() Declaration public void Equals_IsInsensitiveToTheOrderOfAddition() | Improve this Doc View Source EqualsOperator_IsByValue() Declaration public void EqualsOperator_IsByValue() | Improve this Doc View Source GetHashCode_IsByValue_WithPrimitiveType() Declaration public void GetHashCode_IsByValue_WithPrimitiveType() | Improve this Doc View Source GetHashCode_IsByValue_WithRecordType() Declaration public void GetHashCode_IsByValue_WithRecordType() | Improve this Doc View Source GetHashCode_WorksWithEmptyDictionary() Declaration public void GetHashCode_WorksWithEmptyDictionary() | Improve this Doc View Source ToString_IncludesToStringOfKeysAndValues() Declaration public void ToString_IncludesToStringOfKeysAndValues() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.VirtuallyRotatedTextWithTerminatorTests.html": {
    "href": "api/MoreStructures.Tests.VirtuallyRotatedTextWithTerminatorTests.html",
    "title": "Class VirtuallyRotatedTextWithTerminatorTests",
    "keywords": "Class VirtuallyRotatedTextWithTerminatorTests Inheritance System.Object VirtuallyRotatedTextWithTerminatorTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests Assembly : MoreStructures.Tests.dll Syntax public class VirtuallyRotatedTextWithTerminatorTests Methods | Improve this Doc View Source CompareTo_IsCorrect() Declaration public void CompareTo_IsCorrect() | Improve this Doc View Source GetEnumerator_AsIEnumerable_IteratesCorrectly() Declaration public void GetEnumerator_AsIEnumerable_IteratesCorrectly() | Improve this Doc View Source GetEnumerator_AsIEnumerable_ResetsCorrectly() Declaration public void GetEnumerator_AsIEnumerable_ResetsCorrectly() | Improve this Doc View Source GetEnumerator_CurrentRaisesExceptionBeforeAndAfter() Declaration public void GetEnumerator_CurrentRaisesExceptionBeforeAndAfter() | Improve this Doc View Source GetEnumerator_IteratesCorrectly() Declaration public void GetEnumerator_IteratesCorrectly() | Improve this Doc View Source GetEnumerator_ResetsCorrectly() Declaration public void GetEnumerator_ResetsCorrectly() | Improve this Doc View Source Indexer_FollowsRotation() Declaration public void Indexer_FollowsRotation() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.XifoStructures.html": {
    "href": "api/MoreStructures.Tests.XifoStructures.html",
    "title": "Namespace MoreStructures.Tests.XifoStructures",
    "keywords": "Namespace MoreStructures.Tests.XifoStructures Classes XifoStructureTests XQueueTests XStackTests"
  },
  "api/MoreStructures.Tests.XifoStructures.XifoStructureTests.html": {
    "href": "api/MoreStructures.Tests.XifoStructures.XifoStructureTests.html",
    "title": "Class XifoStructureTests",
    "keywords": "Class XifoStructureTests Inheritance System.Object XifoStructureTests XQueueTests XStackTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.XifoStructures Assembly : MoreStructures.Tests.dll Syntax public abstract class XifoStructureTests Constructors | Improve this Doc View Source XifoStructureTests(Func<IXifoStructure<Int32>>) Declaration protected XifoStructureTests(Func<IXifoStructure<int>> xifoBuilder) Parameters Type Name Description Func < IXifoStructure < System.Int32 >> xifoBuilder Properties | Improve this Doc View Source XifoBuilder Declaration protected Func<IXifoStructure<int>> XifoBuilder { get; } Property Value Type Description Func < IXifoStructure < System.Int32 >> Methods | Improve this Doc View Source Count_IsCorrect() Declaration public void Count_IsCorrect() | Improve this Doc View Source Pop_ThrowsExceptionOnEmptyXifo() Declaration public void Pop_ThrowsExceptionOnEmptyXifo() | Improve this Doc View Source PushAndPop_AreCorrect() Declaration public void PushAndPop_AreCorrect() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.XifoStructures.XQueueTests.html": {
    "href": "api/MoreStructures.Tests.XifoStructures.XQueueTests.html",
    "title": "Class XQueueTests",
    "keywords": "Class XQueueTests Inheritance System.Object XifoStructureTests XQueueTests Inherited Members XifoStructureTests.XifoBuilder XifoStructureTests.Count_IsCorrect() XifoStructureTests.Pop_ThrowsExceptionOnEmptyXifo() XifoStructureTests.PushAndPop_AreCorrect() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.XifoStructures Assembly : MoreStructures.Tests.dll Syntax public class XQueueTests : XifoStructureTests Constructors | Improve this Doc View Source XQueueTests() Declaration public XQueueTests() Methods | Improve this Doc View Source PushAndPop_AreInQueueOrder() Declaration public void PushAndPop_AreInQueueOrder() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Tests.XifoStructures.XStackTests.html": {
    "href": "api/MoreStructures.Tests.XifoStructures.XStackTests.html",
    "title": "Class XStackTests",
    "keywords": "Class XStackTests Inheritance System.Object XifoStructureTests XStackTests Inherited Members XifoStructureTests.XifoBuilder XifoStructureTests.Count_IsCorrect() XifoStructureTests.Pop_ThrowsExceptionOnEmptyXifo() XifoStructureTests.PushAndPop_AreCorrect() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Tests.XifoStructures Assembly : MoreStructures.Tests.dll Syntax public class XStackTests : XifoStructureTests Constructors | Improve this Doc View Source XStackTests() Declaration public XStackTests() Methods | Improve this Doc View Source PushAndPop_AreInStackOrder() Declaration public void PushAndPop_AreInStackOrder() Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.TextWithTerminator.html": {
    "href": "api/MoreStructures.TextWithTerminator.html",
    "title": "Class TextWithTerminator",
    "keywords": "Class TextWithTerminator A text string with a terminator character, not present in the text. Inheritance System.Object TextWithTerminator Implements IValueEnumerable < System.Char > IEnumerable < System.Char > System.IEquatable < TextWithTerminator > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures Assembly : MoreStructures.dll Syntax public class TextWithTerminator : IValueEnumerable<char>, IEquatable<TextWithTerminator> Remarks USECASES - A terminator-terminated text is required by data structures like Suffix Tries, Trees or Arrays. - This object provides type safety, as it allows to tell apart terminator-terminated strings from generic ones. - Consistently using TextWithTerminator , rather than System.String , in all library functionalities ensures that the invariant of a terminator-terminated string is always respected. - Most string-related functionalities provided by TextWithTerminator , such as Length and Item[Index] , as well as and System.Collections.IEnumerable support, are delegated to the underlying string. Constructors | Improve this Doc View Source TextWithTerminator(IEnumerable<Char>, Char, Boolean) A text string with a terminator character, not present in the text. Declaration public TextWithTerminator(IEnumerable<char> Text, char Terminator = '$', bool ValidateInput = true) Parameters Type Name Description System.Collections.IEnumerable < System.Char > Text A sequence of chars, of any length (including the empty sequence). System.Char Terminator A terminator character, not present in Text . If not specified DefaultTerminator is used. System.Boolean ValidateInput Whether the input, and in particular Text should be validated, while this object is created. Validation takes O(n) time, where n = number of chars in Text and can be an heavy operation. Remarks USECASES - A terminator-terminated text is required by data structures like Suffix Tries, Trees or Arrays. - This object provides type safety, as it allows to tell apart terminator-terminated strings from generic ones. - Consistently using TextWithTerminator , rather than System.String , in all library functionalities ensures that the invariant of a terminator-terminated string is always respected. - Most string-related functionalities provided by TextWithTerminator , such as Length and Item[Index] , as well as and System.Collections.IEnumerable support, are delegated to the underlying string. Fields | Improve this Doc View Source DefaultTerminator The special character used as a default terminator for the text to build the Suffix Tree of, when no custom terminator is specified. Should not be present in the text. Declaration public const char DefaultTerminator = '$' Field Value Type Description System.Char A single char. Properties | Improve this Doc View Source Item[Index] Select a part of this text by the provided index (either w.r.t. the start or to the end of the text). Declaration public char this[Index index] { get; } Parameters Type Name Description Index index The index applied to the underlying string. Property Value Type Description System.Char A char containing the selected part. | Improve this Doc View Source Item[TextWithTerminator.ISelector] Select a part of this text by the provided selector. Declaration public string this[TextWithTerminator.ISelector selector] { get; } Parameters Type Name Description TextWithTerminator.ISelector selector Any selector acting on a TextWithTerminator . Property Value Type Description System.String A string containing the selected part. | Improve this Doc View Source Item[Range] Select a part of this text by the provided range (start index included, end index excluded). Declaration public IEnumerable<char> this[Range range] { get; } Parameters Type Name Description Range range The range applied to the underlying string. Property Value Type Description System.Collections.IEnumerable < System.Char > An of chars containing the selected part. | Improve this Doc View Source Length The total length of this text, including the terminator. Declaration public int Length { get; } Property Value Type Description System.Int32 A positive integer (at least 1). Remarks CACHING Calculated just once, and cached for later use. Immutability guarantees correctness. COMPLEXITY - If the text was built with a System.String as input, the operation is O(1) in time. - If the text was built with a type optimized by CountO1<TSource>(IEnumerable<TSource>) , such as an System.Collections.IList or the operation is O(1) as well. - Otherwise, the operation is O(n), where n is the length of Text . | Improve this Doc View Source Terminator Declaration public char Terminator { get; set; } Property Value Type Description System.Char A single char. | Improve this Doc View Source TerminatorIndex Returns the index of Terminator in this MoreStructures.TextWithTerminator.TextAndTerminator . Declaration public int TerminatorIndex { get; } Property Value Type Description System.Int32 A 0-based index. 0 when Text is empty, positive otherwise. | Improve this Doc View Source Text Declaration public IEnumerable<char> Text { get; set; } Property Value Type Description System.Collections.IEnumerable < System.Char > A sequence of chars. Remarks Wrapped into a IValueEnumerable<T> to preserve value equality. | Improve this Doc View Source ValidateInput Declaration public bool ValidateInput { get; set; } Property Value Type Description System.Boolean Methods | Improve this Doc View Source EndsWith(IEnumerable<Char>) Whether this text ends with the provided suffix. Declaration public bool EndsWith(IEnumerable<char> suffix) Parameters Type Name Description System.Collections.IEnumerable < System.Char > suffix A terminator-included of System.Char . Returns Type Description System.Boolean True if this text ends by the suffix. | Improve this Doc View Source GetEnumerator() Returns an enumerator that iterates through the collection of chars of the underlying Text string, including the Terminator char. Declaration public IEnumerator<char> GetEnumerator() Returns Type Description System.Collections.IEnumerator < System.Char > | Improve this Doc View Source StartsWith(IEnumerable<Char>) Whether this text starts with the provided suffix. Declaration public bool StartsWith(IEnumerable<char> prefix) Parameters Type Name Description System.Collections.IEnumerable < System.Char > prefix A terminator-included of System.Char . Returns Type Description System.Boolean True if this text starts by the prefix. Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Returns an enumerator that iterates through the collection of chars of the underlying Text string, including the Terminator char. Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description System.Collections.IEnumerator Implements IValueEnumerable<T> IEnumerable<> System.IEquatable<T> Extension Methods TextWithTerminatorExtensions.ToVirtuallyRotated(TextWithTerminator, Int32) SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.TextWithTerminator.ISelector.html": {
    "href": "api/MoreStructures.TextWithTerminator.ISelector.html",
    "title": "Interface TextWithTerminator.ISelector",
    "keywords": "Interface TextWithTerminator.ISelector A selector of a part of a TextWithTerminator or RotatedTextWithTerminator . Namespace : MoreStructures Assembly : MoreStructures.dll Syntax public interface ISelector Methods | Improve this Doc View Source Of(TextWithTerminator) Extract the substring identified by this selector, out of the provided TextWithTerminator . Declaration string Of(TextWithTerminator text) Parameters Type Name Description TextWithTerminator text The text with terminator, to extract a substring of. Returns Type Description System.String A substring, whose length depends on the selector. | Improve this Doc View Source OfRotated(RotatedTextWithTerminator) Extract the substring identified by this selector, out of the provided RotatedTextWithTerminator . Declaration string OfRotated(RotatedTextWithTerminator text) Parameters Type Name Description RotatedTextWithTerminator text The text with terminator, to extract a substring of. Returns Type Description System.String A substring, whose length depends on the selector. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.TextWithTerminatorExtensions.html": {
    "href": "api/MoreStructures.TextWithTerminatorExtensions.html",
    "title": "Class TextWithTerminatorExtensions",
    "keywords": "Class TextWithTerminatorExtensions Extension methods for TextWithTerminator . Inheritance System.Object TextWithTerminatorExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures Assembly : MoreStructures.dll Syntax public static class TextWithTerminatorExtensions Methods | Improve this Doc View Source BuildTerminatorsCDF(TextWithTerminator, ISet<Char>) Builds the Cumulative Distribution Function (CDF) of the provided terminators in the provided fullText . Declaration public static IEnumerable<int> BuildTerminatorsCDF(TextWithTerminator fullText, ISet<char> terminators) Parameters Type Name Description TextWithTerminator fullText The text, composed of a single or multiple concatenated TextWithTerminator . ISet < System.Char > terminators The set of terminators of fullText . Returns Type Description IEnumerable < System.Int32 > A lazy-generated sequence of integers, representing the values of the CDF, indexed by char index in fullText . Remarks DEFINITION - The Cumulative Distribution Function of a text T with terminators t is a function CDF such that CDF at index i is the number of chars in T up to index i included which are in t. - In other terms, CDF[i] = sum(j = 0 to i, isTerminator(T[j])) , where isTerminator(c) = 1 if c is in t, 0 otherwise . ALGORITHM - The definition is applied, iterating over the chars of fullText and yielding item by item. - The algorithm is online. COMPLEXITY - Time Complexity is O(n * Ttc), where n is the length of fullText and Ttc is the time required to check whether a char of the text is a terminator or not. - The \"terminator checking\" performance depends on the implementation of , terminators is an instance of. - If terminators is an , is executed in constant time, and Time Complexity becomes O(n). - Space Complexity is O(n) in all cases, since the only data structure instantiated by the algorithm is the output, which has as many items as the input text. | Improve this Doc View Source BuildTerminatorsIndexMap(TextWithTerminator, ISet<Char>) Builds the Terminators Index Map of the provided terminators in the provided fullText . Declaration public static IEnumerable<int> BuildTerminatorsIndexMap(TextWithTerminator fullText, ISet<char> terminators) Parameters Type Name Description TextWithTerminator fullText The text, composed of a single or multiple concatenated TextWithTerminator . ISet < System.Char > terminators The set of terminators of fullText . Returns Type Description IEnumerable < System.Int32 > A lazy-generated sequence of integers, representing the values of the index map, indexed by char index in fullText . Remarks DEFINITION - The terminators index map of a text T with terminators t is a function TIM such that TIM at index i is the index in T of the last encountered terminator of T up to index i included. - In other terms, TIM[i] = max(j = 0 to i, isTerminator(T[j])) , where isTerminator(c) = 1 if c is in t, 0 otherwise . ALGORITHM - The definition is applied, iterating over the chars of fullText and yielding the index of a new terminator each time one is encountered, for all indexes of the text from the one following the last emitted, to the current one, included. - The algorithm keeps track of the last emitted index and assumes the full text terminates with a terminator (which is the case for every well-formed TextWithTerminator issued by GenerateFullText(TextWithTerminator[]) ). - The algorithm is online. However, it requires consuming the input up to the next terminator, in order to emit values for indexes of chars in the text which refer to such terminator. - For example, if the text is \"ab1cde2fghilm3\" , where terminators are new[] {'1', '2', '3'} , emitting the first item of the output sequence requires consuming the input up to the terminator '1', emitting the second item of the output sequence requires consuming the input up to the terminator '2', etc. COMPLEXITY - Time Complexity is O(n * Ttc), where n is the length of fullText and Ttc is the time required to check whether a char of the text is a terminator or not. - The \"terminator checking\" performance depends on the implementation of , terminators is an instance of. - If terminators is an , is executed in constant time, and Time Complexity becomes O(n). - Space Complexity is O(n) in all cases, since the only data structure instantiated by the algorithm is the output, which has as many items as the input text. | Improve this Doc View Source GenerateFullText(TextWithTerminator[]) Builds a single TextWithTerminator , concatenating the TextWithTerminator instances in texts . Returns as well the of all the terminators and their indexes. Declaration public static (TextWithTerminator fullText, ISet<char> terminators) GenerateFullText(this TextWithTerminator[] texts) Parameters Type Name Description TextWithTerminator [] texts The text instances to join into a single text. Returns Type Description System.ValueTuple < TextWithTerminator , ISet < System.Char >> A couple. The first item of the couple is a text with the Text of all items of texts concatenated, each followed by its own Terminator except the last, and the Terminator of the last item. The second item of the couple is a set of all the terminators included in the resulting text. Remarks COMPLEXITY Requires iterating over the TextWithTerminator items of texts , but not on their content. Therefore, Time Complexity is O(n), where n is the number of items of texts , and not O(t), where t is the length of the concatenated text. Space Complexity is also O(n), since the of terminators contains n items and the generated full text receives a lazy evaluated of the System.Char in each TextWithTerminator of texts . | Improve this Doc View Source ToVirtuallyRotated(TextWithTerminator, Int32) Builds a virtual rotation of the provided TextWithTerminator , by a number of chars defined by rotation , in constant time. Declaration public static VirtuallyRotatedTextWithTerminator ToVirtuallyRotated(this TextWithTerminator text, int rotation) Parameters Type Name Description TextWithTerminator text The text which has to be rotated. System.Int32 rotation The number of chars to virtually rotate text . Returns Type Description VirtuallyRotatedTextWithTerminator An object constructed in constant time and behaving like a rotation of the provided text. Remarks COMPLEXITY - The rotation is \"virtual\" because no new string of length n is computed (which would make the constructor take linear time in the number of chars of text ). - Instead, a new object storing the rotation and keeping the reference to text is created in O(1) time and space. - Such an object is able to appear as if the underlying string was recomputed, taking into account the rotation in all its exposed functionalities."
  },
  "api/MoreStructures.Utilities.CharOrTerminatorComparer.html": {
    "href": "api/MoreStructures.Utilities.CharOrTerminatorComparer.html",
    "title": "Class CharOrTerminatorComparer",
    "keywords": "Class CharOrTerminatorComparer An implementation of for System.Char , which compares chars taking into account the fact that the char may be a special char, called terminator, which has to be considered smaller than any other char. Inheritance System.Object CharOrTerminatorComparer Namespace : MoreStructures.Utilities Assembly : MoreStructures.dll Syntax public class CharOrTerminatorComparer : IComparer<char> Properties | Improve this Doc View Source Terminator The character acting as terminator, and which has to be considered smaller than any other char. Declaration public char Terminator { get; } Property Value Type Description System.Char Methods | Improve this Doc View Source Build(Char) Builds a CharOrTerminatorComparer with the provided terminator . Caches instances. Declaration public static CharOrTerminatorComparer Build(char terminator) Parameters Type Name Description System.Char terminator Returns Type Description CharOrTerminatorComparer An instance of CharOrTerminatorComparer , new or previously created and cached. | Improve this Doc View Source Compare(Char, Char) Declaration public int Compare(char x, char y) Parameters Type Name Description System.Char x System.Char y Returns Type Description System.Int32 Remarks Special rules applied by CharOrTerminatorComparer : If one char is the terminator, and the other isn't, the one which is the terminator is smaller. If none of the cases above applies, System.Char.CompareTo(System.Char) is used on x and y . | Improve this Doc View Source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Remarks Two CharOrTerminatorComparer are equal if they have the same Terminator . | Improve this Doc View Source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Remarks The GetHashCode() is based on Terminator hash. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Utilities.EnumerableExtensions.html": {
    "href": "api/MoreStructures.Utilities.EnumerableExtensions.html",
    "title": "Class EnumerableExtensions",
    "keywords": "Class EnumerableExtensions Extension methods for all concretions. Inheritance System.Object EnumerableExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Utilities Assembly : MoreStructures.dll Syntax public static class EnumerableExtensions Methods | Improve this Doc View Source CountO1<TSource>(IEnumerable<TSource>) Optimized version of , which runs in constant time on source of type System.String , System.Collections.IDictionary , and System.Collections.IList , and calls for any source which cannot be assigned to either of these types. Declaration public static int CountO1<TSource>(this IEnumerable<TSource> source) Parameters Type Name Description System.Collections.IEnumerable <TSource> source Returns Type Description System.Int32 Type Parameters Name Description TSource | Improve this Doc View Source ElementAtO1<TSource>(IEnumerable<TSource>, Index) Optimized version of , which runs in constant time on source of type System.String , and System.Collections.IList , and calls for any source which cannot be assigned to either of these types. Declaration public static TSource ElementAtO1<TSource>(this IEnumerable<TSource> source, Index index) Parameters Type Name Description System.Collections.IEnumerable <TSource> source Index index Returns Type Description TSource Type Parameters Name Description TSource | Improve this Doc View Source ElementAtO1<TSource>(IEnumerable<TSource>, Int32) Optimized version of , which runs in constant time on source of type System.String , and System.Collections.IList , and calls for any source which cannot be assigned to either of these types. Declaration public static TSource ElementAtO1<TSource>(this IEnumerable<TSource> source, int index) Parameters Type Name Description System.Collections.IEnumerable <TSource> source System.Int32 index Returns Type Description TSource Type Parameters Name Description TSource | Improve this Doc View Source ElementAtO1OrDefault<TSource>(IEnumerable<TSource>, Int32) Optimized version of , which runs in constant time on source of type System.String , and System.Collections.IList , and calls for any source which cannot be assigned to either of these types. Declaration public static TSource ElementAtO1OrDefault<TSource>(this IEnumerable<TSource> source, int index) Parameters Type Name Description System.Collections.IEnumerable <TSource> source System.Int32 index Returns Type Description TSource Type Parameters Name Description TSource | Improve this Doc View Source EnumerateAtMostFirst<TSource>(IEnumerable<TSource>, Int32) Eagerly enumerates the first count items of source , or less if there aren't enough, returning an of them and the reminder, as a lazily evaluated . Declaration public static (IList<TSource> firstNItems, IEnumerable<TSource> reminder) EnumerateAtMostFirst<TSource>(this IEnumerable<TSource> source, int count) Parameters Type Name Description System.Collections.IEnumerable <TSource> source The to split into two pieces. System.Int32 count The number of items of source to eagerly evaluate and return (at most). Returns Type Description System.ValueTuple < System.Collections.IList <TSource>, System.Collections.IEnumerable <TSource>> A couple of an instance and an instance. Type Parameters Name Description TSource The type of elements of source . | Improve this Doc View Source EnumerateExactlyFirst<TSource>(IEnumerable<TSource>, Int32) Eagerly enumerates the first count items of source , returning an of them and the reminder, as a lazily evaluated . Declaration public static (IList<TSource> firstNItems, IEnumerable<TSource> reminder) EnumerateExactlyFirst<TSource>(this IEnumerable<TSource> source, int count) Parameters Type Name Description System.Collections.IEnumerable <TSource> source The to split into two pieces. System.Int32 count The number of items of source to eagerly evaluate and return. Returns Type Description System.ValueTuple < System.Collections.IList <TSource>, System.Collections.IEnumerable <TSource>> A couple of an instance and an instance. Type Parameters Name Description TSource The type of elements of source . | Improve this Doc View Source SkipO1<TSource>(IEnumerable<TSource>, Int32) Optimized version of , which runs in constant time on source of type System.String , and System.Collections.IList , and calls for any source which cannot be assigned to either of these types. Declaration public static IEnumerable<TSource> SkipO1<TSource>(this IEnumerable<TSource> source, int count) Parameters Type Name Description System.Collections.IEnumerable <TSource> source System.Int32 count Returns Type Description System.Collections.IEnumerable <TSource> Type Parameters Name Description TSource"
  },
  "api/MoreStructures.Utilities.html": {
    "href": "api/MoreStructures.Utilities.html",
    "title": "Namespace MoreStructures.Utilities",
    "keywords": "Namespace MoreStructures.Utilities Classes CharOrTerminatorComparer An implementation of for System.Char , which compares chars taking into account the fact that the char may be a special char, called terminator, which has to be considered smaller than any other char. EnumerableExtensions Extension methods for all concretions. LinkedListExtensions Extensions for . LockValueObject An empty object with value equality (always true), to be used as lock object in records and other value structures. StringIncludingTerminatorComparer An implementation of for System.String , which compares string taking into account the fact that the string may contain (at any index, not necessarily at then end) a special char, called terminator, which has to be considered smaller than any other char. StringUtilities Generic utilities and extensions for strings. StringValueEnumerable A IValueEnumerable<T> implementation, wrapping a System.String . ValueEnumerable<T> A IValueEnumerable<T> implementation, wrapping a generic . ValueEnumerableExtensions Extension methods for IValueEnumerable<T> . ValueReadOnlyCollection<T> A readonly immutable generic collection of non-null items which performs equality by value. ValueReadOnlyCollectionsExtensions Extension methods for value readonly collections defined in MoreStructures.Utilities . ValueReadOnlyDictionary<TKey, TValue> A readonly immutable generic dictionary of non-null keys and values which performs equality by value. Interfaces IValueEnumerable<T> An which is compared by value, by using . To be used to be used as interface for enumerables in records and other value structures."
  },
  "api/MoreStructures.Utilities.IValueEnumerable-1.html": {
    "href": "api/MoreStructures.Utilities.IValueEnumerable-1.html",
    "title": "Interface IValueEnumerable<T>",
    "keywords": "Interface IValueEnumerable<T> An which is compared by value, by using . To be used to be used as interface for enumerables in records and other value structures. Namespace : MoreStructures.Utilities Assembly : MoreStructures.dll Syntax public interface IValueEnumerable<out T> Type Parameters Name Description T Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Utilities.LinkedListExtensions.html": {
    "href": "api/MoreStructures.Utilities.LinkedListExtensions.html",
    "title": "Class LinkedListExtensions",
    "keywords": "Class LinkedListExtensions Extensions for . Inheritance System.Object LinkedListExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Utilities Assembly : MoreStructures.dll Syntax public static class LinkedListExtensions Methods | Improve this Doc View Source AsNodes<T>(LinkedList<T>) Generates an of the of the provided list . Declaration public static IEnumerable<LinkedListNode<T>> AsNodes<T>(this LinkedList<T> list) Parameters Type Name Description LinkedList <T> list The list, to iterate over. Returns Type Description IEnumerable < LinkedListNode <T>> A sequence of . Type Parameters Name Description T The type of objects contained by list ."
  },
  "api/MoreStructures.Utilities.LockValueObject.html": {
    "href": "api/MoreStructures.Utilities.LockValueObject.html",
    "title": "Class LockValueObject",
    "keywords": "Class LockValueObject An empty object with value equality (always true), to be used as lock object in records and other value structures. Inheritance System.Object LockValueObject Implements System.IEquatable < LockValueObject > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Utilities Assembly : MoreStructures.dll Syntax public class LockValueObject : IEquatable<LockValueObject> Remarks Since all instances are empty, and equality is done by value, always returns true , when the provided object is of type , and always returns the same value (0). Examples record ARecord() { private readonly LockValueObject _lockObject = new LockValueObject(); private void AMethod() { ... lock (_lockObject) { ... } ... } } Implements System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Utilities.StringIncludingTerminatorComparer.html": {
    "href": "api/MoreStructures.Utilities.StringIncludingTerminatorComparer.html",
    "title": "Class StringIncludingTerminatorComparer",
    "keywords": "Class StringIncludingTerminatorComparer An implementation of for System.String , which compares string taking into account the fact that the string may contain (at any index, not necessarily at then end) a special char, called terminator, which has to be considered smaller than any other char. Inheritance System.Object StringIncludingTerminatorComparer Namespace : MoreStructures.Utilities Assembly : MoreStructures.dll Syntax public class StringIncludingTerminatorComparer : IComparer<string> Properties | Improve this Doc View Source Terminator The character acting as terminator, and which has to be considered smaller than any other char. Declaration public char Terminator { get; } Property Value Type Description System.Char Methods | Improve this Doc View Source Build(Char) Builds a StringIncludingTerminatorComparer with the provided terminator . Caches instances. Declaration public static StringIncludingTerminatorComparer Build(char terminator) Parameters Type Name Description System.Char terminator Returns Type Description StringIncludingTerminatorComparer An instance of StringIncludingTerminatorComparer , new or previously created and cached. | Improve this Doc View Source Compare(String, String) Declaration public int Compare(string x, string y) Parameters Type Name Description System.String x System.String y Returns Type Description System.Int32 Remarks Special rules applied by StringIncludingTerminatorComparer : If either string is null or empty, the standard System.String.Compare(System.String,System.String) is used. If one string starts with the terminator, and the other doesn't, the one which does is smaller. If none of the cases above applies, System.String.Compare(System.String,System.String) is used on the substring starting from index 1 of each of the strings x and y . Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Utilities.StringUtilities.html": {
    "href": "api/MoreStructures.Utilities.StringUtilities.html",
    "title": "Class StringUtilities",
    "keywords": "Class StringUtilities Generic utilities and extensions for strings. Inheritance System.Object StringUtilities Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Utilities Assembly : MoreStructures.dll Syntax public static class StringUtilities Methods | Improve this Doc View Source LongestCommonPrefix(IEnumerable<Char>, IEnumerable<Char>) Returns the length of the longest prefix in common between the provided of System.Char . Declaration public static int LongestCommonPrefix(IEnumerable<char> enumerable1, IEnumerable<char> enumerable2) Parameters Type Name Description IEnumerable < System.Char > enumerable1 IEnumerable < System.Char > enumerable2 Returns Type Description System.Int32 An integer betwen 0 and the length of the shortest of the enumerables provided. Remarks ALGORITHM - The algorithm iterates over two enumerators in parallel, one enumerator per enumerable provided. - It keeps running the enumerators until one of the two is over, or the current items of the two enumerators are different. - It keeps a counter of the number of chars found equal from the beginning, which is returned as result. COMPLEXITY - Enumerator creation, moving to next item and accessing the current item are all constant-time operations. - If the two enumerables have length l1 and l2 respectively, there are at most max(l1, l2) iterations. - The current item of each enumerable has a constant size. - If l1 and l2 are O(n), Time Complexity is O(n) and Space Complexity is O(1). | Improve this Doc View Source LongestCommonPrefix(String, Int32, String, Int32) Returns the length of the longest prefix in common between the substrings of the provided System.String instances, starting at the provided indexes. Declaration public static int LongestCommonPrefix(string string1, int index1, string string2, int index2) Parameters Type Name Description System.String string1 System.Int32 index1 System.String string2 System.Int32 index2 Returns Type Description System.Int32 An integer betwen 0 and the length of the shortest of the strings provided, minus related starting index. Remarks ADVANTAGES AND DISADVANTAGES - While LongestCommonPrefix(s1, i1, s2, i2) is conceptually equivalent to LongestCommonPrefix(s1.Skip(i1), s2.Skip(i2)) , making use of the general implementation of LCP given by LongestCommonPrefix(IEnumerable<Char>, IEnumerable<Char>) , this specific implementation, with System.String instances and System.Int32 starting indexes, has been provided. - The reason behind the decision of providing a specialized implementation is that the LINQ method is O(n), rather than O(1). - Moreover, the performance \"suboptimality\" cannot be overcome by using ranges on System.String : LongestCommonPrefix(s1[i1..], s2[i2..]) builds two new strings, s1[i1..] and s2[i2..] , by copying the part of the underlying arrays of s1 and s2 starting at index i1 and i2 respectively. This results in s1[i1..] and s2[i2..] being O(n) both in time and space. - Check https://stackoverflow.com/questions/6742923/, and the answer from Eric Lippert, for further information about the performance of substring extraction from a System.String instance. ALGORITHM - The algorithm iterates over two strings in parallel, each from the provided index. - It keeps checking chars from the two strings until one of the two strings is over, or the current char of the two strings are different. - It keeps a counter of the number of chars found equal from the beginning, which is returned as result. COMPLEXITY - Direct char accessm on a string, as well as checking its length, are constant-time operations. - If the two strings have length l1 and l2 respectively, and starting indexes are i1 and i2 respectively, there are at most max(l1 - i1, l2 - i2) iterations. - If l1, i1, l2 and i2 are O(n), Time Complexity is O(n) and Space Complexity is O(1)."
  },
  "api/MoreStructures.Utilities.StringValueEnumerable.html": {
    "href": "api/MoreStructures.Utilities.StringValueEnumerable.html",
    "title": "Class StringValueEnumerable",
    "keywords": "Class StringValueEnumerable A IValueEnumerable<T> implementation, wrapping a System.String . Inheritance System.Object ValueEnumerable < System.Char > StringValueEnumerable Implements IValueEnumerable < System.Char > IEnumerable < System.Char > Inherited Members ValueEnumerable<Char>.GetEnumerator() ValueEnumerable<Char>.IEnumerable.GetEnumerator() ValueEnumerable<Char>.Equals(Object) ValueEnumerable<Char>.GetHashCode() ValueEnumerable<Char>.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.Utilities Assembly : MoreStructures.dll Syntax public class StringValueEnumerable : ValueEnumerable<char>, IValueEnumerable<char> Remarks Useful when a System.String property/field should be equatable to an by value. For example, when a property or field is declared as of System.Char , and can be assigned either a System.String or a generic , and it has to be solely compared by value (i.e. on the actual chars in the System.String and ). Constructors | Improve this Doc View Source StringValueEnumerable(String) Builds a ValueEnumerable<T> around the provided stringValue . Declaration public StringValueEnumerable(string stringValue) Parameters Type Name Description System.String stringValue The string to wrap. Remarks Time and Space Complexity are O(1), as this constructor doesn't iterate over stringValue . Properties | Improve this Doc View Source StringValue The System.String value underlying this IValueEnumerable<T> . Declaration public string StringValue { get; } Property Value Type Description System.String Implements IValueEnumerable<T> IEnumerable<> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Utilities.ValueEnumerable-1.html": {
    "href": "api/MoreStructures.Utilities.ValueEnumerable-1.html",
    "title": "Class ValueEnumerable<T>",
    "keywords": "Class ValueEnumerable<T> A IValueEnumerable<T> implementation, wrapping a generic . Inheritance System.Object ValueEnumerable<T> StringValueEnumerable Implements IValueEnumerable <T> IEnumerable <T> Inherited Members System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.Utilities Assembly : MoreStructures.dll Syntax public class ValueEnumerable<T> : IValueEnumerable<T> Type Parameters Name Description T The type of objects of the wrapped enumerable. Remarks Useful to preserve equality by value in records and other value structures which contain enumerable objects. It doesn't cache nor enumerate the underlying MoreStructures.Utilities.ValueEnumerable`1.Enumerable unless GetEnumerator() or a method requiring MoreStructures.Utilities.ValueEnumerable`1.Enumerable items is called. Constructors | Improve this Doc View Source ValueEnumerable(IEnumerable<T>) Builds a ValueEnumerable<T> around the provided enumerable . Declaration public ValueEnumerable(IEnumerable<T> enumerable) Parameters Type Name Description System.Collections.IEnumerable <T> enumerable The enumerable to wrap. Remarks Time and Space Complexity is O(1), as this constructor doesn't enumerate enumerable . Methods | Improve this Doc View Source Equals(Object) Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) Remarks In the specific case, equality is based on the of the wrapped objects. Therefore, Time Complexity is O(n * Te) and Space Complexity is O(Se), where n is the number of elements of the longest MoreStructures.Utilities.ValueEnumerable`1.Enumerable and Te/Se are the time and space costs of System.Object.Equals(System.Object) of two T instances. | Improve this Doc View Source GetEnumerator() Declaration public IEnumerator<T> GetEnumerator() Returns Type Description System.Collections.IEnumerator <T> | Improve this Doc View Source GetHashCode() Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() Remarks In the specific case, the hash is calculated as an aggregation of the hash codes of the items of the wrapped MoreStructures.Utilities.ValueEnumerable`1.Enumerable object. Therefore, Time Complexity is O(n * Te) and Space Complexity is O(Se), where n is the number of elements of the longest MoreStructures.Utilities.ValueEnumerable`1.Enumerable and Te/Se are the time and space costs of System.Object.GetHashCode() of a T instance. | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Remarks In the specific case, the string calculation is delegated to the wrapped object. Therefore, Time and Space Complexity are the ones of the specific implementation of System.Object.ToString() of the underlying MoreStructures.Utilities.ValueEnumerable`1.Enumerable . Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description System.Collections.IEnumerator Implements IValueEnumerable<T> IEnumerable<> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Utilities.ValueEnumerableExtensions.html": {
    "href": "api/MoreStructures.Utilities.ValueEnumerableExtensions.html",
    "title": "Class ValueEnumerableExtensions",
    "keywords": "Class ValueEnumerableExtensions Extension methods for IValueEnumerable<T> . Inheritance System.Object ValueEnumerableExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Utilities Assembly : MoreStructures.dll Syntax public static class ValueEnumerableExtensions Methods | Improve this Doc View Source AsValue<T>(IEnumerable<T>) Wraps the provided enumerable into a IValueEnumerable<T> , which uses to check for equality. Declaration public static IValueEnumerable<T> AsValue<T>(this IEnumerable<T> enumerable) Parameters Type Name Description IEnumerable <T> enumerable The enumerable to wrap. Returns Type Description IValueEnumerable <T> A IValueEnumerable<T> wrapping the provided . Type Parameters Name Description T The type of objects of enumerable . Remarks Useful to preserve equality by value in records and other value structures which contain enumerable objects. Passing a System.String as enumerable will result in the instantiation of a specialized concretion of IValueEnumerable<T> which handles strings specifically: StringValueEnumerable . Time and Space Complexity are O(1), as this method doesn't iterate over enumerable ."
  },
  "api/MoreStructures.Utilities.ValueReadOnlyCollection-1.html": {
    "href": "api/MoreStructures.Utilities.ValueReadOnlyCollection-1.html",
    "title": "Class ValueReadOnlyCollection<T>",
    "keywords": "Class ValueReadOnlyCollection<T> A readonly immutable generic collection of non-null items which performs equality by value. Inheritance System.Object System.Collections.ObjectModel.ReadOnlyCollection <T> ValueReadOnlyCollection<T> Implements System.Collections.Generic.IList <T> System.Collections.Generic.ICollection <T> System.Collections.Generic.IReadOnlyList <T> System.Collections.Generic.IReadOnlyCollection <T> System.Collections.Generic.IEnumerable <T> System.Collections.IList System.Collections.ICollection System.Collections.IEnumerable IEquatable < ValueReadOnlyCollection <T>> Inherited Members System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.Generic.IList<T>.get_Item(System.Int32) System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.Generic.IList<T>.set_Item(System.Int32, T) System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.IList.get_Item(System.Int32) System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.IList.set_Item(System.Int32, System.Object) System.Collections.ObjectModel.ReadOnlyCollection<T>.Contains(T) System.Collections.ObjectModel.ReadOnlyCollection<T>.CopyTo(T[], System.Int32) System.Collections.ObjectModel.ReadOnlyCollection<T>.GetEnumerator() System.Collections.ObjectModel.ReadOnlyCollection<T>.IndexOf(T) System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.Generic.ICollection<T>.Add(T) System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.Generic.ICollection<T>.Clear() System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.Generic.ICollection<T>.Remove(T) System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.Generic.IList<T>.Insert(System.Int32, T) System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.Generic.IList<T>.RemoveAt(System.Int32) System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.ICollection.CopyTo(System.Array, System.Int32) System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.IEnumerable.GetEnumerator() System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.IList.Add(System.Object) System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.IList.Clear() System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.IList.Contains(System.Object) System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.IList.IndexOf(System.Object) System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.IList.Insert(System.Int32, System.Object) System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.IList.Remove(System.Object) System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.IList.RemoveAt(System.Int32) System.Collections.ObjectModel.ReadOnlyCollection<T>.Count System.Collections.ObjectModel.ReadOnlyCollection<T>.Item[System.Int32] System.Collections.ObjectModel.ReadOnlyCollection<T>.Items System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.Generic.ICollection<T>.IsReadOnly System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.Generic.IList<T>.Item[System.Int32] System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.ICollection.IsSynchronized System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.ICollection.SyncRoot System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.IList.IsFixedSize System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.IList.IsReadOnly System.Collections.ObjectModel.ReadOnlyCollection<T>.System.Collections.IList.Item[System.Int32] System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.Utilities Assembly : MoreStructures.dll Syntax public class ValueReadOnlyCollection<T> : ReadOnlyCollection<T>, IList<T>, ICollection<T>, IReadOnlyList<T>, IReadOnlyCollection<T>, IEnumerable<T>, IList, ICollection, IEnumerable Type Parameters Name Description T The type of items in the collection. Remarks Immutability can be guaranteed by cloning the provided enumerable and exposing a readonly view of it, but only if immutability of underlying T is provided, for example, by using immutable records. Constructors | Improve this Doc View Source ValueReadOnlyCollection(IEnumerable<T>) Creates value readonly collection out of the provided enumerable, and independent from it. Declaration public ValueReadOnlyCollection(IEnumerable<T> enumerable) Parameters Type Name Description IEnumerable <T> enumerable The enumerable to be used to build the readonly collection. Methods | Improve this Doc View Source Equals(ValueReadOnlyCollection<T>) Equality is calculated by value, i.e. on the collections items directly. Declaration public virtual bool Equals(ValueReadOnlyCollection<T> other) Parameters Type Name Description ValueReadOnlyCollection <T> other Returns Type Description System.Boolean | Improve this Doc View Source Equals(Object) Equality is calculated by value, i.e. on the collections items directly. Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) | Improve this Doc View Source GetHashCode() The hash code is calculated by value, as an aggregate of the hash codes of its items. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this Doc View Source ToString() Format: \"[v1, v2, ...]\". Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Operators | Improve this Doc View Source Equality(ValueReadOnlyCollection<T>, ValueReadOnlyCollection<T>) Compare the two provided value read-only collections for equality by value. Declaration public static bool operator ==(ValueReadOnlyCollection<T> left, ValueReadOnlyCollection<T> right) Parameters Type Name Description ValueReadOnlyCollection <T> left The first term of comparison. ValueReadOnlyCollection <T> right The second term of comparison. Returns Type Description System.Boolean True if the two collections are equal by their items, false otherwise. | Improve this Doc View Source Inequality(ValueReadOnlyCollection<T>, ValueReadOnlyCollection<T>) Compare the two provided value read-only collections for inequality by value. Declaration public static bool operator !=(ValueReadOnlyCollection<T> left, ValueReadOnlyCollection<T> right) Parameters Type Name Description ValueReadOnlyCollection <T> left The first term of comparison. ValueReadOnlyCollection <T> right The second term of comparison. Returns Type Description System.Boolean True if the two collections are different by their items, false otherwise. Implements System.Collections.Generic.IList<T> System.Collections.Generic.ICollection<T> System.Collections.Generic.IReadOnlyList<T> System.Collections.Generic.IReadOnlyCollection<T> System.Collections.Generic.IEnumerable<T> System.Collections.IList System.Collections.ICollection System.Collections.IEnumerable IEquatable<> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.Utilities.ValueReadOnlyCollectionsExtensions.html": {
    "href": "api/MoreStructures.Utilities.ValueReadOnlyCollectionsExtensions.html",
    "title": "Class ValueReadOnlyCollectionsExtensions",
    "keywords": "Class ValueReadOnlyCollectionsExtensions Extension methods for value readonly collections defined in MoreStructures.Utilities . Inheritance System.Object ValueReadOnlyCollectionsExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.Utilities Assembly : MoreStructures.dll Syntax public static class ValueReadOnlyCollectionsExtensions Methods | Improve this Doc View Source ToValueReadOnlyCollection<T>(IEnumerable<T>) Builds a ValueReadOnlyCollection<T> out of the provided dictionary. Declaration public static ValueReadOnlyCollection<T> ToValueReadOnlyCollection<T>(this IEnumerable<T> enumerable) Parameters Type Name Description IEnumerable <T> enumerable Returns Type Description ValueReadOnlyCollection <T> An instance of ValueReadOnlyCollection<T> , independent from the provided enumerable. Type Parameters Name Description T | Improve this Doc View Source ToValueReadOnlyDictionary<TKey, TValue>(IDictionary<TKey, TValue>) Builds a ValueReadOnlyDictionary<TKey, TValue> out of the provided dictionary. Declaration public static ValueReadOnlyDictionary<TKey, TValue> ToValueReadOnlyDictionary<TKey, TValue>(this IDictionary<TKey, TValue> dictionary) Parameters Type Name Description IDictionary <TKey, TValue> dictionary Returns Type Description ValueReadOnlyDictionary <TKey, TValue> An instance of ValueReadOnlyDictionary<TKey, TValue> , independent from the provided dictionary. Type Parameters Name Description TKey TValue | Improve this Doc View Source ToValueReadOnlyDictionary<TKey, TValue>(IEnumerable<KeyValuePair<TKey, TValue>>) Builds a ValueReadOnlyDictionary<TKey, TValue> out of the provided enumerable of entries. Declaration public static ValueReadOnlyDictionary<TKey, TValue> ToValueReadOnlyDictionary<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> entries) Parameters Type Name Description IEnumerable < KeyValuePair <TKey, TValue>> entries Returns Type Description ValueReadOnlyDictionary <TKey, TValue> An instance of ValueReadOnlyDictionary<TKey, TValue> , independent from the provided enumerable of entries. Type Parameters Name Description TKey TValue"
  },
  "api/MoreStructures.Utilities.ValueReadOnlyDictionary-2.html": {
    "href": "api/MoreStructures.Utilities.ValueReadOnlyDictionary-2.html",
    "title": "Class ValueReadOnlyDictionary<TKey, TValue>",
    "keywords": "Class ValueReadOnlyDictionary<TKey, TValue> A readonly immutable generic dictionary of non-null keys and values which performs equality by value. Inheritance System.Object System.Collections.ObjectModel.ReadOnlyDictionary <TKey, TValue> ValueReadOnlyDictionary<TKey, TValue> Implements System.Collections.Generic.IDictionary <TKey, TValue> System.Collections.Generic.ICollection < System.Collections.Generic.KeyValuePair <TKey, TValue>> System.Collections.Generic.IReadOnlyDictionary <TKey, TValue> System.Collections.Generic.IReadOnlyCollection < System.Collections.Generic.KeyValuePair <TKey, TValue>> System.Collections.Generic.IEnumerable < System.Collections.Generic.KeyValuePair <TKey, TValue>> System.Collections.IDictionary System.Collections.ICollection System.Collections.IEnumerable Inherited Members System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.IDictionary<TKey, TValue>.get_Item(TKey) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.IDictionary<TKey, TValue>.set_Item(TKey, TValue) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.IDictionary.get_Item(System.Object) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.IDictionary.set_Item(System.Object, System.Object) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.ContainsKey(TKey) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.GetEnumerator() System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Add(System.Collections.Generic.KeyValuePair<TKey, TValue>) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Clear() System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Contains(System.Collections.Generic.KeyValuePair<TKey, TValue>) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue>[], System.Int32) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Remove(System.Collections.Generic.KeyValuePair<TKey, TValue>) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.IDictionary<TKey, TValue>.Add(TKey, TValue) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.IDictionary<TKey, TValue>.Remove(TKey) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.ICollection.CopyTo(System.Array, System.Int32) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.IDictionary.Add(System.Object, System.Object) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.IDictionary.Clear() System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.IDictionary.Contains(System.Object) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.IDictionary.GetEnumerator() System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.IDictionary.Remove(System.Object) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.IEnumerable.GetEnumerator() System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.TryGetValue(TKey, TValue) System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.Count System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.Dictionary System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.Item[TKey] System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.Keys System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.IsReadOnly System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.IDictionary<TKey, TValue>.Item[TKey] System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.IDictionary<TKey, TValue>.Keys System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.IDictionary<TKey, TValue>.Values System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>.Keys System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>.Values System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.ICollection.IsSynchronized System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.ICollection.SyncRoot System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.IDictionary.IsFixedSize System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.IDictionary.IsReadOnly System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.IDictionary.Item[System.Object] System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.IDictionary.Keys System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.System.Collections.IDictionary.Values System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.Values System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : MoreStructures.Utilities Assembly : MoreStructures.dll Syntax public class ValueReadOnlyDictionary<TKey, TValue> : ReadOnlyDictionary<TKey, TValue>, IDictionary<TKey, TValue>, ICollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IDictionary, ICollection, IEnumerable Type Parameters Name Description TKey The type of keys in the dictionary. TValue The type of values in the dictionary. Remarks Immutability can be guaranteed by cloning the provided dictionary and exposing a readonly view of it, but only if immutability of underlying TKey and TValue is provided, for example, by using immutable records. Constructors | Improve this Doc View Source ValueReadOnlyDictionary(IDictionary<TKey, TValue>) Creates value readonly dictionary out of the provided dictionary, and independent from it. Declaration public ValueReadOnlyDictionary(IDictionary<TKey, TValue> dictionary) Parameters Type Name Description IDictionary <TKey, TValue> dictionary The dictionary to be used to build the readonly dictionary. | Improve this Doc View Source ValueReadOnlyDictionary(IEnumerable<KeyValuePair<TKey, TValue>>) Creates value readonly dictionary out of the provided entries, and independent from the provided enumerable of them. Declaration public ValueReadOnlyDictionary(IEnumerable<KeyValuePair<TKey, TValue>> entries) Parameters Type Name Description IEnumerable < KeyValuePair <TKey, TValue>> entries The enumerable of entries to be used to build the readonly dictionary. Methods | Improve this Doc View Source Equals(Object) Equality is calculated by value, i.e. on the dictionary key-value pairs directly. Declaration public override bool Equals(object obj) Parameters Type Name Description System.Object obj Returns Type Description System.Boolean Overrides System.Object.Equals(System.Object) Remarks Two dictionaries are considered equal by value if: they have the same set of keys and the value associated, with each of the key by the two dictionaries are equal with each other. | Improve this Doc View Source GetHashCode() The hash code is calculated by value, as an aggregate of the hash codes of its key value pairs. Declaration public override int GetHashCode() Returns Type Description System.Int32 Overrides System.Object.GetHashCode() | Improve this Doc View Source ToString() Format: \"{[k1] = v1, [k2] = v2, ...}\". Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Operators | Improve this Doc View Source Equality(ValueReadOnlyDictionary<TKey, TValue>, ValueReadOnlyDictionary<TKey, TValue>) Compare the two provided value read-only dictionaries for equality by value. Declaration public static bool operator ==(ValueReadOnlyDictionary<TKey, TValue> left, ValueReadOnlyDictionary<TKey, TValue> right) Parameters Type Name Description ValueReadOnlyDictionary <TKey, TValue> left The first term of comparison. ValueReadOnlyDictionary <TKey, TValue> right The second term of comparison. Returns Type Description System.Boolean True if the two dictionaries are equal by their items, false otherwise. | Improve this Doc View Source Inequality(ValueReadOnlyDictionary<TKey, TValue>, ValueReadOnlyDictionary<TKey, TValue>) Compare the two provided value read-only dictionaries for inequality by value. Declaration public static bool operator !=(ValueReadOnlyDictionary<TKey, TValue> left, ValueReadOnlyDictionary<TKey, TValue> right) Parameters Type Name Description ValueReadOnlyDictionary <TKey, TValue> left The first term of comparison. ValueReadOnlyDictionary <TKey, TValue> right The second term of comparison. Returns Type Description System.Boolean True if the two dictionaries are different by their items, false otherwise. Implements System.Collections.Generic.IDictionary<TKey, TValue> System.Collections.Generic.ICollection<T> System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> System.Collections.Generic.IReadOnlyCollection<T> System.Collections.Generic.IEnumerable<T> System.Collections.IDictionary System.Collections.ICollection System.Collections.IEnumerable Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.VirtuallyRotatedTextWithTerminator.html": {
    "href": "api/MoreStructures.VirtuallyRotatedTextWithTerminator.html",
    "title": "Class VirtuallyRotatedTextWithTerminator",
    "keywords": "Class VirtuallyRotatedTextWithTerminator A text string with a terminator character which has been rotated leftwards or rightwards, of a number of positions (0 included). Inheritance System.Object VirtuallyRotatedTextWithTerminator Implements IValueEnumerable < System.Char > IEnumerable < System.Char > IComparable < VirtuallyRotatedTextWithTerminator > System.IEquatable < VirtuallyRotatedTextWithTerminator > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures Assembly : MoreStructures.dll Syntax public class VirtuallyRotatedTextWithTerminator : IValueEnumerable<char>, IEquatable<VirtuallyRotatedTextWithTerminator> Remarks A virtually rotated terminator-terminated text is required by Burrows-Wheeler Transform construction, when the length of the text is too high to build the Burrows-Wheeler Matrix, which would have n^2 items. Constructors | Improve this Doc View Source VirtuallyRotatedTextWithTerminator(RotatedTextWithTerminator, Int32) A text string with a terminator character which has been rotated leftwards or rightwards, of a number of positions (0 included). Declaration public VirtuallyRotatedTextWithTerminator(RotatedTextWithTerminator Underlying, int Rotation) Parameters Type Name Description RotatedTextWithTerminator Underlying The TextWithTerminator instance which has been rotated. System.Int32 Rotation The number of characters to rotate: positive = rightwards, negative = leftwards. Remarks A virtually rotated terminator-terminated text is required by Burrows-Wheeler Transform construction, when the length of the text is too high to build the Burrows-Wheeler Matrix, which would have n^2 items. Properties | Improve this Doc View Source Item[Index] Select a part of Underlying by the provided index (either w.r.t. the start or to the end of the text), applying the Rotation . Treat index as circular, over modulo the length of Underlying . Declaration public char this[Index index] { get; } Parameters Type Name Description Index index The index applied to the underlying string. Property Value Type Description System.Char A char containing the selected part. | Improve this Doc View Source Rotation Declaration public int Rotation { get; set; } Property Value Type Description System.Int32 | Improve this Doc View Source Underlying Declaration public RotatedTextWithTerminator Underlying { get; set; } Property Value Type Description RotatedTextWithTerminator Methods | Improve this Doc View Source CompareTo(VirtuallyRotatedTextWithTerminator) Declaration public int CompareTo(VirtuallyRotatedTextWithTerminator other) Parameters Type Name Description VirtuallyRotatedTextWithTerminator other Returns Type Description System.Int32 | Improve this Doc View Source GetEnumerator() Declaration public IEnumerator<char> GetEnumerator() Returns Type Description IEnumerator < System.Char > Explicit Interface Implementations | Improve this Doc View Source IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description System.Collections.IEnumerator Implements IValueEnumerable<T> IEnumerable<> IComparable<> System.IEquatable<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.XifoStructures.html": {
    "href": "api/MoreStructures.XifoStructures.html",
    "title": "Namespace MoreStructures.XifoStructures",
    "keywords": "Namespace MoreStructures.XifoStructures Classes XQueue<T> A IXifoStructure<T> based on a . XStack<T> A IXifoStructure<T> based on a . Interfaces IXifoStructure<T> An Abstract Data Type modelling a generic XIFO structure: either a LIFO (such as a XStack<T> ), or a FIFO (such as a XQueue<T> )."
  },
  "api/MoreStructures.XifoStructures.IXifoStructure-1.html": {
    "href": "api/MoreStructures.XifoStructures.IXifoStructure-1.html",
    "title": "Interface IXifoStructure<T>",
    "keywords": "Interface IXifoStructure<T> An Abstract Data Type modelling a generic XIFO structure: either a LIFO (such as a XStack<T> ), or a FIFO (such as a XQueue<T> ). Namespace : MoreStructures.XifoStructures Assembly : MoreStructures.dll Syntax public interface IXifoStructure<T> Type Parameters Name Description T The type of items of the data structure. Remarks This interface is implemented by adapters for standard data structures present in the framework, such as XStack<T> and XQueue<T> . The advantage of using this interface is that the order of insertion and extraction of the items of the structure can be changed in the code of the client using the data structure without changing the code itself. Properties | Improve this Doc View Source Count Returns the number of items in this data structure. Declaration int Count { get; } Property Value Type Description System.Int32 A non-negative value. Methods | Improve this Doc View Source Pop() Extracts the first available item from this data structure. Declaration T Pop() Returns Type Description T An item of the data structure, of type T . Remarks Extraction is done in a way to minimize the cost of the operation. For example extraction from a stack is done from the top of the stack, since it can be accessed in O(1) time. Extraction from a queue is done at the beginning of the queue, since it can be modified in O(1) time. | Improve this Doc View Source Push(T) Inserts the provided item into this data structure. Declaration void Push(T item) Parameters Type Name Description T item The item to be inserted. Remarks Insertion is done in a way to minimize the cost of the operation. For example insertion into a stack is done on top of the stack, since prepending is a O(1) operation. Insertion into a queue is done at the end of the queue instead, since appending is the O(1) way of inserting. Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.XifoStructures.XQueue-1.html": {
    "href": "api/MoreStructures.XifoStructures.XQueue-1.html",
    "title": "Class XQueue<T>",
    "keywords": "Class XQueue<T> A IXifoStructure<T> based on a . Inheritance System.Object XQueue<T> Implements IXifoStructure <T> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.XifoStructures Assembly : MoreStructures.dll Syntax public class XQueue<T> : IXifoStructure<T> Type Parameters Name Description T The type of items of the data structure, and of the underlying . Properties | Improve this Doc View Source Count Invokes on the underlying . Declaration public int Count { get; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source Pop() Invokes on the underlying . Declaration public T Pop() Returns Type Description T An item of type T . | Improve this Doc View Source Push(T) Invokes on the underlying . Declaration public void Push(T item) Parameters Type Name Description T item An item of type T . Implements IXifoStructure<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "api/MoreStructures.XifoStructures.XStack-1.html": {
    "href": "api/MoreStructures.XifoStructures.XStack-1.html",
    "title": "Class XStack<T>",
    "keywords": "Class XStack<T> A IXifoStructure<T> based on a . Inheritance System.Object XStack<T> Implements IXifoStructure <T> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : MoreStructures.XifoStructures Assembly : MoreStructures.dll Syntax public class XStack<T> : IXifoStructure<T> Type Parameters Name Description T The type of items of the data structure, and of the underlying . Properties | Improve this Doc View Source Count Invokes on the underlying . Declaration public int Count { get; } Property Value Type Description System.Int32 Methods | Improve this Doc View Source Pop() Invokes on the underlying . Declaration public T Pop() Returns Type Description T An item of type T . | Improve this Doc View Source Push(T) Invokes on the underlying . Declaration public void Push(T item) Parameters Type Name Description T item An item of type T . Implements IXifoStructure<T> Extension Methods SuffixStructureNodeExtensions.GetAllSuffixesFor<TEdge, TNode>(TNode, TextWithTerminator)"
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "",
    "keywords": "Sorry, no articles for the time being..."
  },
  "index.html": {
    "href": "index.html",
    "title": "More Structures .NET",
    "keywords": "More Structures .NET More Structure .NET is a OS-agnostic library written in .NET6 and C# 10, targeting Any CPU. API Documentation The API Documentation, generated from XML documentation comments , and compiled into a navigable website via DocFX , is available here . Prerequisites Windows, Linux or macOS Having .NET6 or later installed check here for supported OS, macOS releases and Linux distributions, dependencies and installation instructions. You can check whether and which .NET is installed in your system by running the following command dotnet --list-sdks dotnet --list-runtimes Build The library can be built on Windows, Linux and macOS. To build a Release version of the library, run the following commands in the directory containing MoreStructures.sln : dotnet restore dotnet build --no-restore --configuration Release To build a Debug version of the library, run the following commands in the directory containing MoreStructures.sln : dotnet restore dotnet build --no-restore --configuration Debug Test To run unit tests, after having built the project, run the following command in the directory containing MoreStructures.sln : dotnet test --no-build --verbosity normal --configuration Debug Dependencies The library is 100% C# and .NET Managed code, with no OS dependencies and with minimal nuget external dependencies, listed below. MoreLINQ More Structures depends on MoreLINQ, a battle-tested library used for many typical LINQ operations which are not out of the box in .NET. Visit https://morelinq.github.io/ for further information."
  }
}